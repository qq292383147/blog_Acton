---
title: 小程序-笔记
date: 2019-04-08 22:40:41
tags: 小程序
categories: 小程序
---

# 微信小程序开发

## 下载开发工具

开发工具下载地址https://developers.weixin.qq.com/miniprogram/dev/devtools/download.html

 

## 获取appid

小程序的appid相当于小程序平台的一个身份证，很多地方需要用到appid，比如在创建小程序项目时候就需要用到appid

 

![img](http://zhanglong292383147.gitee.io/picture_images/picture/smallRoutine/1.png) 

![img](http://zhanglong292383147.gitee.io/picture_images/picture/smallRoutine/1_1.png)

## window配置示例

```json
    // app.json

    {

      "window":{

        "navigationBarBackgroundColor": "#fff", // 导航栏背景颜色 

        "navigationBarTextStyle": "black",      // 导航栏标题颜色，仅支持 black / white

        "navigationBarTitleText": "weChart",    // 导航栏标题文字内容

        "backgroundColor": "#fff",				// 窗口的背景色

        "backgroundTextStyle": "light"，			// 下拉 loading 的样式，仅支持 dark / light

        "enablePullDownRefresh": true			// 设置允许下拉刷新

      }

    }

```


## 注意： window的配置

>1. navigationBarTextStyle导航栏标题颜色，仅支持 black / white
>2. backgroundTextStyle下拉 loading 的样式，仅支持 dark / light

 

 

## tabBar配置示例

```json
    // app.json

    {

      "tabBar": {

      	"color": "#000",   // tab 上的文字默认颜色

      	"selectedColor": "#000",   // tab 上的文字选中时的颜色

      	"backgroundColor": "#f5f5f5",   // tab 的背景色

        "list": [{

          "pagePath": "pages/index/index",   // 页面路径，必须在 pages 中先定义（必填）

          "text": "首页",  // tab 上按钮文字（必填）

          "iconPath": "",  // tab 上的图片路径,不支持网络图片

          "selectedIconPath": "",  // 选中时的图片路径

        }, {

          "pagePath": "pages/logs/logs",

          "text": "日志",

          "iconPath": "",

          "selectedIconPath": ""

        }]

      }

    }
```

<font color="red">注意：配置了tabBar后，底部栏只对配置的页面可见, 而且tabBar的设置至少两个，最多5个</font>

 

## view容器组件

 

### view组价的基本使用

```html
	<view class="container">

		<!-- 页面内容 -->

	</view>
```


### text文本组件

 

#### text的基本使用

```html
	<view class="container">

		<!-- text组件 -->

		<text>文本内容</text>

	</view>
```

```
text组件内只支持 text 嵌套

除了文本节点以外的其他节点都无法长按选中

text组件不能嵌套其他组件, 除了text组件自身

<text>这是一个段落<text>这是二个段落</text></text>
```


## navigator页面链接组件

 

### navigator的基本使用

```html
<!--  url的连接前面必须加上斜杆 “/” -->

	<navigator url="/pages/demo/domo">

		跳转到demo

	</navigator>
```



<font color="red">注意：navigator不支持跳转到外部的url，例如url="https://www.baidu.com"
如果要跳转到tabBar上配置过的页面，需要open-type="switchTab"</font>

 

## 跳转到tabBar的页面

设置open-type值为switchTab，比如index页面是tabBar的页面，可以这样来设置



### 跳转到tabBar的使用方法

```html
    <navigator url="/pages/index/index" open-type="switchTab">
            	跳转到首页
    </navigator>
```


### image图片组件

```html
<image 

	style="width: 200px; height: 200px;"

	mode="aspectFill" 

	src="图片地址">

</image>
```

<font color="red">注意：image组件默认宽度300px、高度240px 注2：image组件中二维码|小程序码图片不支持长按识别</font>

 

## 图片的裁剪模式

 

### 常用的mode 有效值

 

>scaleToFill	不保持纵横比缩放图片，使图片的宽高完全拉伸至填满 image 元素
>aspectFit		保持纵横比缩放图片，使图片的长边能完全显示出来
>aspectFill	保持纵横比缩放图片，只保证图片的短边能完全显示出来

 

## input组件

 

### input的简单使用

```html
<input placeholder="请输入文字" type="text"/>
```



![img](http://zhanglong292383147.gitee.io/picture_images/picture/smallRoutine/2.png) 

 

## button 按钮组件

## form表单组件

### form表单基本提交案例


>第一步，设置button form-type='submit 
>
>第二步，通过bindsubmit设置form的提交事件处理函数 

 

## wxml

```html
<form bindsubmit="formSubmit">

  <input type="text" name="username" placeholder></input>

  <button form-type="submit">提交</button>

</form>
```


```js
//js
formSubmit: function(e){
    console.log(e.detail.value)
}
```

## rpx 尺寸单位

### 什么是rpx？


rpx可以使元素根据屏幕宽度进行自适应，小程序规定屏幕的宽度为750rpx， 也就是 
<br>
100% = 750rpx; 50% = (750 / 2)rpx
<br>
在开发小程序是建议使用750像素宽度的设计稿，这样设计稿的元素宽度是多少像素就直接设置为多少rpx

 

<font color="red">注意1rpx在某些屏幕上可能无效</font>


## 样式导入

通过@import导入外部的样式，常用语公共样式



## 总结：

>1.wxss 不需要导入到wxml，在页面目录下创建即可生效
>2.app.wxss是全局样式,page中的wxss是页面的局部样式
>3.rpx 尺寸单位 
>4.@import 样式导入


## 小程序生命周期

生命周期有程序的生命周期和页面的生命周期



### 常用的生命周期：

| 属性 | 描述         | 触发时机                         |
| -------- | ---------------- | ------------------------------------ |
| onLaunch | 监听小程序初始化 | 小程序初始化完成时（全局只触发一次） |
| onShow   | 监听小程序显示   | 小程序启动，或从后台进入前台显示时   |
| onHide   | 监听小程序隐藏   | 小程序从前台进入后台时               |

 

 

## 小程序的运行机制

 

### 小程序没有重启的概念

当小程序进入后台，客户端会维持一段时间的运行状态，超过一定时间后（目前是5分钟）会被微信主动销毁



页面需要通过Page(Object) 函数用来注册一个页面。接受一个 Object 类型参数，其指定页面的初始数据、生命周期回调、事件处理函数等。




### 常用的生命周期：

 属性  描述 

 `onLoad`----监听页面加载

 `onShow`----监听页面显示

 `onReady`----监听页面初次渲染完成

 `onHide`----监听页面隐藏


![img](http://zhanglong292383147.gitee.io/picture_images/picture/smallRoutine/3.png) 

 

 

## onLoad

页面加载时触发。一个页面只会调用一次，可以在 onLoad 的参数中获取打开当前页面路径中的参数。


参数说明, 通过query获取当前页面路径中的参数




| 名称 | 类型 | 说明                 |
| -------- | -------- | ------------------------ |
| query    | Object   | 打开当前页面路径中的参数 |



<font color="color">注意：页面需要访问api接口来初始化页面， 都可以在onLoad中调用</font>


程序的生命周期: `app.js`中`onLaunch`在小程序初始化中触发

页面的生命周期: `onLoad` 只在页面加载的时候执行一次, `onShow`每次访问页面都会执行, 通常`onLoad`在`onShow`之前执行

 

## 什么是mpvue？



>1. mpvue不是vue框架
>2. Vue框架是用来开发普通的网站网站
>3. Mpvue是使用vue语法开发小程序的前端框架，即把vue文件编译成微信小程序文件

 

## 如何安装？

```shell
npm install --global [vue-cli@2.9](mailto:vue-cli@2.9)

Vue init mpvue/mpvue-quickstart shop

```



<font color="red">注意：appid需要输入个人的appid，vuex(y/n) 和 eslint(y/n) 都输入n</font>


## 安装依赖

```shell
   npm install
```


## 启动服务

```shell
   npm run dev
```

<font color="red">注意：运行成功后，可以看到本地多了个dist目录，这个目录里就是生成的小程序相关代码.</font>


## mpvue基本结构介绍


### 描述


`mpvue`的项目结构和普通的网页开发没太大区别，只是最终的编译会生成到dist/wx目录下，微信开发工具所打开的文件目录也是dist/wx

 

## 结构视图


build - 把mpvue构建成小程序的配置文件(忽略)

config - 基础的配置文件(忽略)

dist - 构建后的小程序项目(忽略)

src - 项目开发文件

​    components - 项目公共组件

​    pages - 小程序页面

​    utils - 工具文件夹 (忽略)

​    app.json - 小程序项目配置文件

​    App.vue - 项目VUE入口文件

​    main.js - 项目入口文件

static - 静态资源文件

....

project.config.json - 同原生小程序的配置文件

 

## 添加scss样式的支持

### 安装依赖包

需要安装包：

```shell
npm install sass-loader node-sass --save-dev
```


## 导入拆分样式文件

```html
<style scoped lang=scss>

@import "./style.scss"

</style>
```


## async await的使用


主要解决使用同步的方法处理多个异步请求


async函数执行的时候，一旦遇到await就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。

 

注意：

>1.await后面接的是Promise对象
>2.await的返回值是Promise对象then方法的参数

 

## Promise封装

通常使用`promise`解决函数嵌套, 当你一个函数需要接受多个函数作为参数时候，并且是异步处理，那么可以考虑实用`promise`, 当前解决办法并不是唯一的(可以了解下thunk函数)

![img](http://zhanglong292383147.gitee.io/picture_images/picture/smallRoutine/4.png) 

![img](http://zhanglong292383147.gitee.io/picture_images/picture/smallRoutine/5.png) 


## 固定伸缩性布局子元素的宽度


当父元素为`display：flex`; 布局时，如果子元素的内容宽度超出会挤压另一侧的内容宽度，导致另一侧的宽度不生效，这时可以设置子元素的`css`属性为：

flex-shrink：0;

## 使元素宽度撑开整个屏幕的高度


在需要div元素撑开整个屏幕高度的时候，可以把元素定位为固定定位或者绝对定位，然后同时设置top值bottom值，那么这两个值之间的距离就是元素高度（同理也可以同时设置left和right）

```css
.content{

    position: fixed;

    left:0;

    right:0;

    top:100rpx; 

    bottom:0;

}
```



## 封装search组件

把首页的顶部搜索提取到`components`目录下作为组件，供首页和分类页调用

### 分类页




## 1、新知识点：



使用固定定位设置{top：0,bottom:0} 实现div高度相对于屏幕100%显示

scroll-view内容滚动组件的使用

小程序中的点击事件@tap(也可以使用@click)

## 2、布局：



### 分类页左侧布局

```html
<div class="content">
    <!--左侧的列表 -->
    <div class="left">
        <scroll-view scroll-y class="scroll-left" >
            <div class="category-item" 
            :class="{active: currentTab == index}"
            v-for="(item, index) in menus" 
            :key="index"
            @tap="handleTab(index)">
                {{item}}
            </div>
        </scroll-view>
    </div>    
    <!--左侧的列表 end-->

    <!--右侧的界面 -->

    <!--右侧的界面 end-->
</div>
```


### 分类页右侧布局

```html
<!-- 右侧的界面 -->
<div class="right">
    <!-- rightData是右侧的动态数据 -->
    <div>
        <div class="right-title">
            <span>/</span>
            电视
            <span>/</span>
        </div>
        <div class="wares">
            <!-- 右侧的商品列表 -->
            <div  
            v-for="(item, index) in [1,1,1,1,1,1,1,1]" 
            :key="index"
            class="ware-item">
                <img src="https://img.alicdn.com/i2/2/TB1r23ZRXXXXXaxXXXXXXXXXXXX?abtest=&pos=6&abbucket=&acm=03014.1003.1.765824&scm=1007.13143.56636.100200300000000_90x90q90.jpg"/>
                <span>小米</span>
            </div>
        </div>
    </div>
</div>
```


## 正在加载组件的使用

文档地址：<https://developers.weixin.qq.com/miniprogram/dev/api/wx.showLoading.html> 

组件示例：

```js
wx.showLoading({
  title: '加载中',
})
setTimeout(function () {
  wx.hideLoading()
}, 2000)
```


<font color="red">注意：该例子在src/utils/request.js请求函数内部使用</font>

 

## 搜索结果页上拉加载更多


### 1.添加上拉触底事件


文档地址: [https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/page.html#](https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/page.html)页面事件处理函数

```js
export default {
    onReachBottom(){
        console.log("加载更多")
    }
}
```

## 2.封装请求处理函数

```js
data(){
    return {
        pageSize: 20, // 每页数据条数
        hasMore: true // 是否有更多数据
    }
},

methods: {
    getGoods(pagenum){
        
        // 如果没有更多不在继续加载, 直接返回
        if(!hasMore){
            return;
        }

        request.get("https://itjustfun.cn/api/public/v1/goods/search", {
          pagenum,
          query: query.keyword
          }).then(res => {
            const {goods} = res.data.data;
            
            // 如果请求返回的数据小于20条时候没有更多数据
            if(goods.length < this.pageSize){
                this.hasMore = false
            }

            // 装换商品的价格
            const newGoods = goods.map(v => {
              v.goods_price = Number(v.goods_price).toFixed(2);
              return v;
            })
            
            // 把新数据追加到goods列表
            this.goods = [
                ...this.goods,
                ...newGoods
            ];
        })
    }
}
```

## 3.页面控制正在加载的

### 搜索页实现


### 1.监听input输入事件

```html
<input 
@input="handleInput"
/>

export default {
    methods: {
        handleInput(event){
            //获取input的值
            console.log(event.target.value)
        }
    }
}
```

### 2.触发搜索 手机键盘上点击完成触发搜索

```html
<input 
@input="handleInput"
@confirm="handleConfirm"
/>

export default {
    methods: {
        handleInput(event){
            //获取input的值
            console.log(event.target.value)
        },
        handleConfirm(){
            // 跳转到搜索列表页     
        }
    }
}
```

### 2. 把搜索关键存储到本地 通过wx.setStorageSync存入本地 

文档地址： <https://developers.weixin.qq.com/miniprogram/dev/api/storage/wx.setStorageSync.html>


### 通过wx.getStorageSync获取本地的数据 

文档地址：<https://developers.weixin.qq.com/miniprogram/dev/api/storage/wx.getStorageSync.html>


### 用户登录获取token


### 拼接接口所需的参数

```js
data = {
    code: "", //通过 wx.login()  获取
    encryptedData: "", //通过 getUserInfo 获取
    iv: "", // 可通过 getUserInfo 获取
    rawData: "", // 通过 getUserInfo 获取，JSON.stringify() 转字符串
    signature: "", // 可通过 getUserInfo 获取
}

getUserInfo: function(res) {
  const data = {};

  wx.login({
    success: res => {
      data.code = res.code;

      wx.getUserInfo({
        success: res => {
            data.encryptedData = res.encryptedData;
            data.iv = res.iv;
            data.rawData = res.rawData;
            data.signature = res.signature;

            wx.request({
                url: "https://www.itjustfun.cn/api/public/v1/users/wxlogin",
                method: "POST",
                data,
                success: res => {
                    const {token} = res.data.data;
                    // 设置token到本地

                    wx.navigateBack();
                }
            })
            
        }
      });
    }
  });
}
```

### 给post请求加上过滤和header

```js
 	// 专门处理post请求

	request.auth= function(url, data){

		if(!wx.getStorageSync("token")){

			// 跳转到授权页

			wx.navigator({

				url: "/pages/authrize/main"

			})

		}

	    return request(url, "POST", data, header = {

			// 头部的授权token

	    });

	}
```


## 原生小程序

### 1. 在原生小程序定义data


和vuejs不一样，小程序定义data直接等于对象
```js
data: {

}
```


## 2.wx:for循环

小程序的for循环使用为`wx:for`指令， 在循环体内，有两个默认变量， 一个item代表的是当前项，还有一个index代表的是索引

使用wx:key="{{index}}"消除warning提示

代码示例

```html
<!-- tab -->
<view class="tab">
    <!-- 循环data里面的tabs -->
  <view class="tab-item" wx:for="{{tabs}}" wx:key="{{index}}">
    <!-- item.text获取文本 -->
    {{index}}  {{item.text}}
  </view>
</view>
```

### 3.两个大括号的作用

```
使用两个大括号把变量的值渲染到页面上 {{ }},和vuejs不一样，组件属性需要渲染变量值，也需要使用两个大括号
```

参考

```js
wx:for="{{tabs}}"
```


### 4.条件判断wx:if

wx:if的用法和作用vue的v-if一模一样


## 5.添加高亮的样式

在小程序里面不能和vuejs一样使用：class， 需要用过class类型的拼接,在设置class类名时候在属性里面使用两个大括号进行运算

代码示例： 是否加上active

```js
class="tab-item {{ currentTab === index? 'active': '' }}"
```

 

## 6.事件

6.1 通过什么 bindtap绑定点击事件

6.2 在js文件中添加事件处理函数，函数和onLoad/data同级， 没有methods

6.3 获取事件参数

在组件中使用data-xx绑定参数到自定义属性

在事件处理函数中通过事件对象 event.currentTarget.dataset获取自定义的属性的值，实现传参

 

## 7. 修改data的值

和vuejs不一样，不能通过直接赋值的方法来修改,必须使用this.setData方法

使用示例:

```js
this.setData({
    currentTab: 1
})
```

## 8.获取data的值

通过`this.data.xxx`获取`data`里的值


## 腾讯地图的使用:


>1.把腾讯地图显示到小程序
>2.实现地图的当前用户的定位
>3.通过搜索关键字反回附近的信息
>4.导航寻路功能

 

**1.把腾讯地图显示到小程序**

文档地址 : <https://lbs.qq.com/qqmap_wx_jssdk/index.html>

**1.1 注册腾讯地图的账号，生成key**

生成key时候需要勾选上所有的产品,特别是最后一个

![img](http://zhanglong292383147.gitee.io/picture_images/picture/smallRoutine/6.png) 

**1.2下载jssdk，可以在当前页面地址中下载**

地址：<https://lbs.qq.com/qqmap_wx_jssdk/index.html>

**1.3 根据文档的示例调用腾讯地图**

**1.4 在小程序中使用map组件显示地图**


​
```js
// js
<map
  id="map"
  longitude="{{markers.longitude}}"
  latitude="{{markers.latitude}}"
  markers="{{markers}}"
  show-location
  class="map"
></map>
Page({
  data: {
    markers: [{
      iconPath: '/resources/others.png',
      id: 0,
      // latitude: 23.099994,
      // longitude: 113.324520,
      width: 50,
      height: 50
    }],
  },
}
```

1.5 配置app.json中的permission字段

```json
{
  "pages":[
    "pages/index/index"
  ],
  "window":{
    "backgroundTextStyle":"light",
    "navigationBarBackgroundColor": "#fff",
    "navigationBarTitleText": "WeChat",
    "navigationBarTextStyle":"black"
  },
  "permission": {
    "scope.userLocation": {
      "desc": "xxx"
    }
  }
}
```



**2.实现地图的当前用户的定位**

使用wx.getLocation获取用户当前的经纬度, 把经纬度设置为map组件


```js
     // 获取当前的位置
    wx.getLocation({
      success: res => {
    // 修改markers的经纬度
    this.setData({
      markers: {
        ...this.data.markers,
        latitude: res.latitude ,
        longitude: res.longitude 
      }
    })
  },
})
```



**3.通过搜索关键字反回附近的信息**

通过sdk实例对象的search方法搜索结果， 拿到列表后显示在页面上，

当前用户点当前的地址时候在地图上进行定位，就是修改markers的值

```js
// 点击搜索结果列表
  handleResClick: function(event){
    // 获取参数
    // item就是当前点击选中的地址对象
    const {item} = event.currentTarget.dataset;

    // 设置当前点击的地址定位
    this.setData({
      markers: [{
        iconPath: '/resources/others.png',
        latitude: item.location.lat,
        longitude: item.location.lng,
        label: {
          content: item.title,
          textAlign: "center"
        }
      }],
      searchRes: {}
    })
  }
```



**4.导航寻路功能**

小程序JavascriptSDK，目前暂未提供路线规划能力 ,需要调用网页的方式api，

参考下面的官网文档

<https://lbs.qq.com/qqmap_wx_jssdk/method-direction.html>



## mpvue框架下使用高德地图

```js
import store from '../store/index'
/**
 * 这是封装的用户位置信息
 * return: address 用户的地理位置
 *         latitude 纬度
 *         longitude 经度
 */
export default function position(item){
  var amapFile = require('../libs/amap-wx.js');
  var key = 'xxxxxxxxxx';
  var myAmapFun = new amapFile.AMapWX({ key: key })
  myAmapFun.getPoiAround({
    success: function (res) {
      // 当前的位置
      item = {
        address: res.markers[0].address,
        latitude: res.markers[0].latitude,
        longitude: res.markers[0].longitude,
      }
      store.commit('setTab',item);
    },
    fail: function (info) {
      console.log(info)
    }
  })
}
```

说明：amap-wx.js要去高德官网下载

## mpvue框架下引入腾讯地图

```js
<template>
 <div>
    <!-- <view class="section">
      <input :data-city="city" :data-longitude="longitude" :data-latitude="latitude" bindtouchstart="bindInput" placeholder="搜索"/>
    </view> -->
    <view class="map_container">
      <map class="map" id="map" :longitude="longitude" :latitude="latitude" scale="14" show-location="true" :markers="markers" @bindmarkertap="makertap"></map>
    </view>
    <view class="map_text">
      <text class="h1">{{textData.name}}</text>
      <text>{{textData.desc}}</text>
      <!-- <text class="h1">{{addr}}</text>
      <text>{{marketName}}</text> -->
    </view>
 </div>
  
</template>

<script>

var amapFile = require('../../libs/amap-wx.js');

var markersData = [];

  export default {
    data(){
      return{
        markers: [],
        latitude: '',
        longitude: '',
        textData: {},
        city: '',
      }
    },
    onLoad: function(e) {
      console.log(e)
      //接受传过来的location
      var locationgo = e.location ? e.location : ''
      var that = this;
      var key = 'key值';
      var myAmapFun = new amapFile.AMapWX({key: key});
      // var params = {
      //   // iconPathSelected: '../../../static/me/cart5.png',
      //   // iconPath: '../../../static/me/cart6.png',
      //   success: function(data){
      //     markersData = data.markers;
      //     var poisData = data.poisData;
      //     var markers_new = [];
      //     // markersData.forEach(function(item,index){
      //       // markers_new.push({
      //       //   id: item.id,
      //       //   latitude: item.latitude,
      //       //   longitude: item.longitude,
      //       //   iconPath: item.iconPath,
      //       //   width: item.width,
      //       //   height: item.height
      //       // })

      //     // })
      //     if(markersData.length > 0){
      //         that.markers = markers_new
      //         that.city = poisData[0].cityname || ''
      //         that.latitude = markersData[0].latitude
      //         that.longitude = markersData[0].longitude
      //       that.showMarkerInfo(markersData,0);
      //     }else{
      //       wx.getLocation({
      //         type: 'gcj02',
      //         success: function(res) {
      //             that.latitude = res.latitude
      //             that.longitude = res.longitude
      //             that.city = '北京市'
      //         },
      //         fail: function(){
      //             that.latitude = 39.909729
      //             that.longitude = 116.398419
      //             that.city = '北京市'
      //         }
      //       })
            
      //         that.textData = {
      //           name: '抱歉，未找到结果',
      //           desc: ''
      //         }
      //     }
          
      //   },
      //   fail: function(info){
      //     // wx.showModal({title:info.errMsg})
      //   }
      // }
      // if(e && e.keywords){
      //   params.querykeywords = e.keywords;
      // }
      // myAmapFun.getPoiAround(params)
      // 获取定位位置或指定位置
      myAmapFun.getRegeo({
        iconWidth: 22,
        iconHeight: 32,
        location:locationgo,      //传入要定位的地址，不传的话，默认是当前位置
        success: function(data){
          console.log('777')
          console.log(data)
          var marker = [{
            id: data[0].id,
            latitude: data[0].latitude,
            longitude: data[0].longitude,
            iconPath: data[0].iconPath,
            width: data[0].width,
            height: data[0].height
          }]
            that.markers = marker
            that.latitude = data[0].latitude
            that.longitude = data[0].longitude
            that.textData = {
              name: e.address,
              desc: e.market
              // name: data[0].name,
              // desc: data[0].desc
            }
            wx.openLocation({
              latitude: data[0].latitude,
              longitude: data[0].longitude,
              address: e.address,
              name: e.market,
              scale: 18
            })
        },
        fail: function(info){
          // wx.showModal({title:info.errMsg})
        }
      })
    },
    computed: {
    },
    methods: {
      showMarkerInfo: function(data,i){
        var that = this;
          that.textData = {
            name: data[i].name,
            desc: data[i].address
          }
      },
      changeMarkerColor: function(data,i){
        var that = this;
        var markers = [];
        for(var j = 0; j < data.length; j++){
          // if(j==i){
          //   data[j].iconPath = "../../../static/me/cart5.png";
          // }else{
          //   data[j].iconPath = "../../../static/me/cart5.png";
          // }
          markers.push({
            id: data[j].id,
            latitude: data[j].latitude,
            longitude: data[j].longitude,
            iconPath: data[j].iconPath,
            width: data[j].width,
            height: data[j].height
          })
        }
          that.markers = markers
      },
      // bindInput: function(e){
      //   var that = this;
      //   var url = '../inputtips/input';
      //   if(e.target.dataset.latitude && e.target.dataset.longitude && e.target.dataset.city){
      //     var dataset = e.target.dataset;
      //     url = url + '?lonlat=' + dataset.longitude + ',' + dataset.latitude + '&city=' + dataset.city;
      //   }
      //   wx.redirectTo({
      //     url: url
      //   })
      // },
      makertap: function(e) {
        var id = e.markerId;
        var that = this;
        that.showMarkerInfo(markersData,id);
        that.changeMarkerColor(markersData,id);
      },
    }
   
  }
</script>

<style lang="less" scoped>
.section{
  height: 30px;
  width: 100%;
}
.section input{
  width:90%;
  margin:5px auto;
  border:1px solid #c3c3c3;
  height:30px;
  border-radius: 3px;
  padding: 0 5px;
}
.map_container{
  position: absolute;
  top: 42px;
  bottom: 80px;
  left: 0;
  right: 0;
}
.map{
  width: 100%;
  height: 100%;
}
.map_text{
  position: absolute;
  left: 0;
  right: 0;
  bottom: 0px;
  height: 80px;
  background: #fff;
  padding: 0 15px;
}
text{
  margin: 5px 0;
  display: block;
  font-size:12px;
  text-overflow: ellipsis;
  white-space: nowrap;
  overflow: hidden;
}
.h1{
  margin: 15px 0;
  font-size:15px;
}
</style>

```

提供位置信息，比如经纬度，还要传目的地的经纬度，附近商铺和当前位置#

## 在mpvue中封装http发送请求

```js
// 返回promise对象
function request(url, method="GET", data={}, header={}){

    wx.showLoading({
        title: '加载中',
    })
      
    return new Promise((resolve, reject) => {
        wx.request({
            url,
            method,
            data,
            header,
            success: res => {
                resolve(res);
                wx.hideLoading();
            }
        })
    });
}

// 拓展get请求
request.get = function(url, data){
    // 返回promise
    return request(url, "GET", data);
}

// 拓展Post请求
request.post = function(url, data){
    // 返回promise
    return request(url, "POST", data);
}

// 需要授权访问的请求
request.auth = function(url, data){

    // 从本地获取token
    if(!wx.getStorageSync("token")){
        wx.navigateTo({
            url: "/pages/auth/main"
        });
        return new Promise(() => {});
    }

    // 返回promise
    // 注意，第四个参数是header头信息
    return request(url, "POST", data, {
        "Authorization" : wx.getStorageSync("token")
    });
}

export default request;

```

## 在mpvue使用封装好的请求，在使用async和await处理异步请求

```js
  methods: {
    // 负责请求页面全部的数据
    async getData(){
      // try catch捕获程序代码的错误，代码块错误不会影响到下面的代码执行,具有块级作用域
      try {
        const res = await request("https://xxxx"); //此网址为你的api请求
        const {data} = res.data;

        // 修改轮播图的连接
        data.forEach(v => {
          // 通过问号分解链接，给第一个元素后面加上/mian，再通过join拼接为字符串
          const arr = v.navigator_url.split("?");
          arr[0] = arr[0] + "/main";
          const str = arr.join("?")
          v.navigator_url = str;
        })

        this.imgUrls = data;
      } catch (error) { console.log(error) }
      
      try {
        const res = await request("https://xxx"); // 此网址为你的api请求
        const {data} = res.data;
        this.categorys = data;
      } catch (error) { console.log(error) }

      try {
        const res = await request("https://bbb"); // 此网址为你的api请求
        const {message} = res.data;
        this.floors = message;
      } catch (error) { console.log(error) }

      // 停止下拉刷新
      wx.stopPullDownRefresh();
    },

    // 回到顶部
    handleToTop(){
      wx.pageScrollTo({
        scrollTop: 0,
      })
    }
  }
```

## mpvue封装请求api地址

```js
var Fly =  require("flyio/dist/npm/wx");
var fly = new Fly();
fly.config.baseURL = 'https://h.yjtxmc.com/api';
// fly.config.baseURL = 'http://192.168.0.176:8060/api';
// fly.config.timeout = 5000; //超时设置为1s
/*请求之前拦截*/
fly.interceptors.request.use(function(request) {
  // fly.lock();
  //  定时器不用显示
  if(request.url != 'https://xxx.xxx.com/api/xxx/xxx.json'){
    wx.showLoading({ 
      title: '拼命加载中...' ,
      mask: true
    });

  }
});
/*响应数据拦截*/
fly.interceptors.response.use(
  (response, promise) => {
    wx.hideLoading();
    // if(登录过期){跳回login }
    //  没有生效,还要调试
    if(response.data.data.state == 401){
      wx.redirectTo({
        url: '/pages/login/main'
      })
    }
    return promise.resolve(response.data);
  },
  (err, promise) => {
    wx.hideLoading();
    wx.showToast({
      title: err.message,
      icon: 'none'
    })
    wx.navigateBack({
      delta: -1
    })
    return promise.resolve()
  }
)
export default fly

///////////////////////////我是华丽的分割线//////////////////////////////////
import fly from './index'
const host = fly.config.baseURL;
// 登录 selfLogin
export const selfLogin = params => { return fly.get(`${host}/xxx/xxx.json`, params) }
```

## mpvue自定义轮播图

```vue
<template>
  <div class="swiper-box pr">
    <swiper
      :indicator-dots="indicatorDots"
      :autoplay="autoplay"
      :interval="interval"
      :duration="duration"
      @change="swiperChange"
      :style="{height: h+'rpx'}"
      :circular="circular"
    >
      <swiper-item v-for="(item, index) in data" :key="index">
        <image :src="item.imgUrl" class="top-image"/>
      </swiper-item>
    </swiper>
    <div class="line-box display-flex space-around pa">
      <div class="line-item" v-for="(item,index) in data" :key="index" :class="{on: index == lineIndex}" v-if="lh!=1"></div>
      <!-- <div class="line-item"></div> -->
      <!-- <div class="line-item" :class="{on: lineIndex == 1}"></div>
      <div class="line-item" :class="{on: lineIndex == 2}"></div> -->
    </div>
  </div>
</template>

<script>
  export default {
    props:{
      data: {
        type: Array,
        default: []
      },
      h:{
        type: Number,
      },
      lh:{
        type: Number,
      },
    },
    name: "loop",
    data(){
      return {
        autoplay: true,
        interval: 2000,
        duration: 400,
        lineIndex: 0,
      }
    },
    methods:{
      swiperChange(e){
        // console.log(e.mp.detail.current);
        this.lineIndex = e.mp.detail.current;
      },
      
    },

    computed: {
    }
  };
</script>

<style lang="less" scoped>
  .swiper-box {
    .top-image {
      height: 100%!important;
      width: 100%!important;
    }
    .line-box {
      // width: 90%;
      left: 50%;
      transform: translateX(-50%);
      bottom: 40rpx;
      .line-item {
        height: 2rpx;
        // width: 120rpx;
        width: 180rpx;
        background-color: #7f7471;
        margin-right: 10rpx;
        &:last-child {
           margin-right: 0;
         }
        &.on {
           background-color: #ffffff;
         }
      }
    }
  }
</style>

```

可设置高度，动态图片个数长度（点），只有一张则不显示点

## mpvue框架引入公共自定义组件遮罩层

```vue
<template>
  <div v-if="flag == true" @click="clickHandle"></div>
</template>

<script>
  export default {
    name: "maskLayer",
    props:{
      flag:{
        type: Boolean,
        default: false
      }
    },
    methods:{
      clickHandle(){
        this.$emit('by-clicking');
      }
    }
  };
</script>

<style scoped>
div {
  position: fixed;
  left: 0;
  top: 0;
  width: 100vw;
  height: 100vh;
  transition: all .5s ease-in-out;
  z-index: 99;
  background-color: rgba(0,0,0, .5);
}
</style>

```

## 搜索组件 wxSearch

微信小程序没有搜索功能的组件，我们可以使用输入框和按钮组件，或者使用 wxSearch 第三方组件

github地址：https://github.com/icindy/wxSearch

wxSearch
经过使用后发现这个组件还是很不错滴，优雅的微信小程序搜索框

一、功能

支持自定义热门key
支持搜索历史
支持搜索建议
支持搜索历史(记录)缓存
二、使用

将 wxSearch 文件夹整个拷贝到 utils 目录下

导入 wxml
--------------------- 
```javascript
<!-- 导入 wxSearch 搜索组件 -->
<import src="../../utils/wxSearch/wxSearch.wxml"/>
<template is="wxSearch" data="{{wxSearchData}}"/>
```

创建 wxml 模板

```html
<!-- 搜索功能 -->
<view class="wxSearch-section">
  <view class="wxSearch-pancel">

    <input bindinput="wxSearchInput" bindfocus="wxSerchFocus" value="{{wxSearchData.value}}" class="wxSearch-input" placeholder="">

```

## 自定义模态弹窗（带动画）实例

![](C:\Users\Administrator\Desktop\7.png)

api如下：

![](C:\Users\Administrator\Desktop\8.png)

示例：

![](C:\Users\Administrator\Desktop\9.png)

这样的模态弹窗，充其量只能做个alert，提示一下信息。

但是并不能使用它来处理复杂性的弹窗业务，因此写了Michael从新自定义了一个，采用了仿原生的样式写法



wxml：

```html

<!--button-->
<view class="btn" bindtap="powerDrawer" data-statu="open">button</view>
 
<!--mask-->
<view class="drawer_screen" bindtap="powerDrawer" data-statu="close" wx:if="{{showModalStatus}}"></view>
<!--content-->
<!--使用animation属性指定需要执行的动画-->
<view animation="{{animationData}}" class="drawer_box" wx:if="{{showModalStatus}}">
 
  <!--drawer content-->
  <view class="drawer_title">弹窗标题</view>
  <view class="drawer_content">
    <view class="top grid">
      <label class="title col-0">标题</label>
      <input class="input_base input_h30 col-1" name="rName" value="可自行定义内容"></input>
    </view>
    <view class="top grid">
      <label class="title col-0">标题</label>
      <input class="input_base input_h30 col-1" name="mobile" value="110"></input>
    </view>
    <view class="top grid">
      <label class="title col-0">标题</label>
      <input class="input_base input_h30 col-1" name="phone" value="拒绝伸手党"></input>
    </view>
    <view class="top grid">
      <label class="title col-0">标题</label>
      <input class="input_base input_h30 col-1" name="Email" value="仅供学习使用"></input>
    </view>
    <view class="top bottom grid">
      <label class="title col-0">备注</label>
      <input class="input_base input_h30 col-1" name="bz"></input>
    </view>
  </view>
  <view class="btn_ok" bindtap="powerDrawer" data-statu="close">确定</view>
</view>
```

wxss：

```css

/*button*/
.btn {
  width: 80%;
  padding: 20rpx 0;
  border-radius: 10rpx;
  text-align: center;
  margin: 40rpx 10%;
  background: #000;
  color: #fff;
}
 
/*mask*/
.drawer_screen {
  width: 100%;
  height: 100%;
  position: fixed;
  top: 0;
  left: 0;
  z-index: 1000;
  background: #000;
  opacity: 0.5;
  overflow: hidden;
}
 
/*content*/
.drawer_box {
  width: 650rpx;
  overflow: hidden;
  position: fixed;
  top: 50%;
  left: 0;
  z-index: 1001;
  background: #FAFAFA;
  margin: -150px 50rpx 0 50rpx;
  border-radius: 3px;
}
 
.drawer_title{
  padding:15px;
  font: 20px "microsoft yahei";
  text-align: center;
}
.drawer_content {
  height: 210px;
  overflow-y: scroll; /*超出父盒子高度可滚动*/
}
 
.btn_ok{
  padding: 10px;
  font: 20px "microsoft yahei";
  text-align: center;
  border-top: 1px solid #E8E8EA;
  color: #3CC51F;
}
 
.top{
	padding-top:8px;
}
.bottom {
	padding-bottom:8px;
}
.title {
	height: 30px;
	line-height: 30px;
	width: 160rpx;
	text-align: center;
	display: inline-block;
	font: 300 28rpx/30px "microsoft yahei";
}
 
.input_base {
	border: 2rpx solid #ccc;
	padding-left: 10rpx;
	margin-right: 50rpx;
}
.input_h30{
	height: 30px;
	line-height: 30px;
}
.input_h60{
	height: 60px;
}
.input_view{
	font: 12px "microsoft yahei";
	background: #fff;
	color:#000;
	line-height: 30px;
}
 
input {
	font: 12px "microsoft yahei";
	background: #fff;
	color:#000 ;
}
radio{
	margin-right: 20px;
}
.grid { display: -webkit-box; display: box; }
.col-0 {-webkit-box-flex:0;box-flex:0;}
.col-1 {-webkit-box-flex:1;box-flex:1;}
.fl { float: left;}
.fr { float: right;}
```

js：

```js
Page({
  data: {
    showModalStatus: false
  },
  powerDrawer: function (e) {
    var currentStatu = e.currentTarget.dataset.statu;
    this.util(currentStatu)
  },
  util: function(currentStatu){
    /* 动画部分 */
    // 第1步：创建动画实例 
    var animation = wx.createAnimation({
      duration: 200,  //动画时长
      timingFunction: "linear", //线性
      delay: 0  //0则不延迟
    });
    
    // 第2步：这个动画实例赋给当前的动画实例
    this.animation = animation;
 
    // 第3步：执行第一组动画
    animation.opacity(0).rotateX(-100).step();
 
    // 第4步：导出动画对象赋给数据对象储存
    this.setData({
      animationData: animation.export()
    })
    
    // 第5步：设置定时器到指定时候后，执行第二组动画
    setTimeout(function () {
      // 执行第二组动画
      animation.opacity(1).rotateX(0).step();
      // 给数据对象储存的第一组动画，更替为执行完第二组动画的动画对象
      this.setData({
        animationData: animation
      })
      
      //关闭
      if (currentStatu == "close") {
        this.setData(
          {
            showModalStatus: false
          }
        );
      }
    }.bind(this), 200)
  
    // 显示
    if (currentStatu == "open") {
      this.setData(
        {
          showModalStatus: true
        }
      );
    }
  }
 
})

```

运行：

![](C:\Users\Administrator\Desktop\10.gif)

