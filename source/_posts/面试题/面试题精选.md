---
title: 面试题精选
date: 2019-10-23 21:37:36
type: 面试题
tags: 面试题
categories: 面试题
---

## 数组去重怎么实现？

1、可以使用for循环去重

```js
/*
* 新建一新数组，遍历传入数组，值不在新数组就push进该新数组中
* IE8以下不支持数组的indexOf方法
* */
function uniq(array){
    var temp = []; //一个新的临时数组
    for(var i = 0; i < array.length; i++){
        if(temp.indexOf(array[i]) == -1){
            temp.push(array[i]);
        }
    }
    return temp;
}

var aa = [1,2,2,4,9,6,7,5,2,3,5,6,5];
console.log(uniq(aa));

//优化遍历数组法
// 思路：获取没重复的最右一值放入新数组
/*
* 推荐的方法 *
* 方法的实现代码相当酷炫，
* 实现思路：获取没重复的最右一值放入新数组。
* （检测到有重复值时终止当前循环同时进入顶层循环的下一轮判断）*/
function uniq(array){
    var temp = [];
    var index = [];
    var l = array.length;
    for(var i = 0; i < l; i++) {
        for(var j = i + 1; j < l; j++){
            if (array[i] === array[j]){
                i++;
                j = i;
            }
        }
        temp.push(array[i]);
        index.push(i);
    }
    console.log(index);
    return temp;
}

var aa = [1,2,2,3,5,3,6,5];
console.log(uniq(aa));

//对象键值法去重
/*
* 速度最快， 占空间最多（空间换时间）
* 该方法执行的速度比其他任何方法都快， 就是占用的内存大一些。
* 现思路：新建一js对象以及新数组，遍历传入数组时，判断值是否为js对象的键，
* 不是的话给对象新增该键并放入新数组。
* 注意点：判断是否为js对象键时，会自动对传入的键执行“toString()”，
* 不同的键可能会被误认为一样，例如n[val]-- n[1]、n["1"]；
* 解决上述问题还是得调用“indexOf”。*/
function uniq(array){
    var temp = {}, r = [], len = array.length, val, type;
    for (var i = 0; i < len; i++) {
        val = array[i];
        type = typeof val;
        if (!temp[val]) {
            temp[val] = [type];
            r.push(val);
        } else if (temp[val].indexOf(type) < 0) {
            temp[val].push(type);
            r.push(val);
        }
    }
    return r;
}

var aa = [1,2,"2",4,9,"a","a",2,3,5,6,5];
console.log(uniq(aa));

//数组下标法
/*
* 还是得调用“indexOf”性能跟方法1差不多，
* 实现思路：如果当前数组的第i项在当前数组中第一次出现的位置不是i，
* 那么表示第i项是重复的，忽略掉。否则存入结果数组。
* */
function uniq(array){
    var temp = [];
    for(var i = 0; i < array.length; i++) {
        //如果当前数组的第i项在当前数组中第一次出现的位置是i，才存入数组；否则代表是重复的
        if(array.indexOf(array[i]) == i){
            temp.push(array[i])
        }
    }
    return temp;
}

var aa = [1,2,"2",4,9,"a","a",2,3,5,6,5];
console.log(uniq(aa));
```

2、利用hash表去重

3、先排序后去重

```js
//排序后相邻去除法
/*
* 给传入数组排序，排序后相同值相邻，
* 然后遍历时,新数组只加入不与前一值重复的值。
* 会打乱原来数组的顺序
* */
function uniq(array){
    array.sort();
    var temp=[array[0]];
    for(var i = 1; i < array.length; i++){
        if( array[i] !== temp[temp.length-1]){
            temp.push(array[i]);
        }
    }
    return temp;
}

var aa = [1,2,"2",4,9,"a","a",2,3,5,6,5];
console.log(uniq(aa));
```

4、Set方式去重1(es6)

```js
const removeDuplicateItems = arr
    => [...new Set(arr)]; 
 console.log(removeDuplicateItems([42, 'foo', 42, 'foo', true, true])); // => [42, "foo", true]
```

5、Set方式去重2
```js
  let array = [0,3,5,1,3,5,6,8,7,9,1,3,6,5,7,6,6];
  // [0, 3, 5, 1, 6, 8, 7, 9]
  [...new Set(array)]
```

6、Array filter()  =====> es5
```js
  [1,2,35,69,15,2,2,3,515,43,0.5,1.2,1.3,4.6,513,215,15]
  .filter(function(elem, index, Array ){
    return index === Array.indexOf(elem);
  })

  //[1, 2, 35, 69, 15, 3, 515, 43, 0.5, 1.2, 1.3, 4.6, 513, 215]
```

## Javascript 基础数据类型？

``` bash
number(数值)
string(字符串)
Boolean(布尔)
null(空)
undefined(未定义)
引用类型有：object
```


## 谈一谈Javascript作用域链？

当执行一段JS代码(全局代码或函数)时，JS引擎会创建一个作用域又称为执行上下文，在页面加载后会首先创建一个全局的作用域，然后每执行一个函数，会建立一个对应的作用域，从而形成了一条作用域链。每个作用域都有一条对应的作用域链，链头是全局作用域，链尾是当前函数作用域。

作用域链作用是用于解析标识符，当函数被创建时（不是执行），会将this.arguments、命名参数和该函数中的所有局部变量添加到该当前作用域中，当JS需要查找变量X的时候，这个过程称为变量解析，它首先会直到查找到链头，也就是全局作用域链，仍未找到该变量的话，就认为这段代码的作用域上不存在X变量，并抛出引用错误的异常。



## 如何理解JS原型链？

JS中的每一个prototype属性，我们称之为原型，而原型的值也是对象，因此它也有自己的原型，这样就串联起来了一条原型链，原型链的链头是object，它的prototype比较特殊，值为null。

原型链的作用是用于对象继承，函数A的原型属性是一个对象，当这个函数被用作构造函数来创建实例时，该函数的原型属性将被作为原型赋值给所有对象实例，比如我们新建一个数组，数组的方法便从数组的原型上继承而来。

当访问对象的一个属性时，首先查找对象本身，找到则返回；若未找到，则继续查找其原型对象的属性（如果还找不到实际上会沿着原型链向上查找，直到根），只要没有被覆盖的话，对象原型的属性就能在所有的实例中找到，若整个原型链未找到则返回undefined.

```
总结：

1、每个函数对象都有一个 prototype 属性， 这个属性就是函数的原型对象

2、原型链式 JavaScript 实现继承的重要方式，原型链的形成是真正是靠__proto__而非prototype
```

a: 在js里，继承机制是原型继承，继承的起点是对象的原型（Object prototype）

b: 一切皆为对象，只要是对象，就会有 proto 属性，该属性存储了指向其构造的指针。

c: Object.prototype 也是对象，其 proto 指向 null

d: 对象分为两种： 1、函数对象 2、普通对象；只有函数对象拥有【原型】对象（prototype）

e: prototype 的本质是普通对象

f: function prototype 比较特殊，是没有 prototype 的函数对象

g: new 操作得到的对象是普通对象

h: 当调取一个对象的属性时，会先在本身查找，若无，就根据 proto 找到构造原型，若无，继续往上找。最后会到达顶层 Object prototype ，它的 proto 指向 null，均无结果则返回 undefined，结束。

l: 由 proto 串起的路径就是 【原型链】

j: 通过 prototype 可以给所有子类共享属性。



## （重点）如何理解和应用JS闭包？

简单的理解是函数的嵌套形成闭包，闭包包括函数本身以及它的外部作用域，函数a内嵌套b，且返回b，当调用函数a时，用变量接收函数b，就形成了闭包。

优点：

① 减少全局变量。

② 减少传递函数的参数量

③ 封装

缺点：延长了作用域链，需要释放的变量不能及时释放，可能引发内存泄漏，其实说白了就是该内存空间使用完毕之后未回收，即所谓内存泄漏，最终，结果是程序运行时间越长，占用存储空间越来越多，最终用尽全部存储空间，整个系统崩溃。(**使用闭包会占有内存资源，过多的使用闭包会导致内存溢出等.**)

最简洁、直击要害的回答，我能想到的分别有这么三句

**1、闭包是一个有状态**（不消失的私有数据）**的函数。**

**2、闭包是一个有记忆的函数。**

**3、闭包相当于一个只有一个方法的紧凑对象**（a compact object）。 

**通俗的讲：就是函数a的内部函数b，被函数a外部的一个变量引用的时候，就创建了一个闭包。**

```js
//这样在执行完var c=a()后，变量c实际上是指向了函数b，再执行c()后就会弹出一个窗口显示i的值(第一次为1)。这段代码其实就创建了一个闭包，为什么？因为函数a外的变量c引用了函数a内的函数b

   function a(){
           var i=0;
           function b(){
              alert(++i);
           }
              return b;
       }

 var c = a();
        c();

// 更容易理解的闭包
function f1() {
    var num = 0;
    // 定义内部函数
    function f2() {
        return num + 1;
    }
    // 返回 f2函数引用
    return f2;
}

// bar 变量也指向 f2 函数，在此也是一个闭包
var bar = f1();

// 执行
bar();  //1

// 我们知道，函数中的变量会随着函数的执行完毕后会被销毁。而如上的代码，f1() 函数执行完毕后，将 f2 函数赋值给一个全局变量，而 f2 函数的变量又依赖 f1 的 num 变量，因此，f1中的 num 变量并不会随着 f1 的函数执行完毕后而销毁
```

**概念**：内层函数能够访问外层函数作用域的变量

**缺点**：引起内存泄漏（释放内存）

**作用**：1、使用闭包修正打印值

​	   2、实现柯里化

​	   3、实现 `node commonJS` 模块化，实现私有变量

​	   4、保持变量与函数活性，可延迟回收和执行

## Javascript代理？

当我们需要对很多元素添加事件的时候，可以通过将事件添加到它们的父节点而将事件委托给父节点来触发处理函数。



## HTML5有哪些新特性？移除了哪些元素？如何处理HTML5新标签的浏览兼容问题？如何区别HTML和HTML5？

1、HTML5现在已经不是SGML的子集，主要是关于图像，位置，存储，多任务等功能的增加；

2、用于媒介回放的 *video* 和 *audio* 元素

3、本地离线存储localStorge长期存储数据，浏览器关闭后数据不会丢失。

4、语义化更好的内容元素，比如article、footer、header、nav、section

5、新的技术webworker、websockt、geolocation移除的元素

6、对可用性产生负面影响的元素：frame、frameset、noframes，支持HTML5标签

7、IE8/IE7/IE6支持通过docment.createElement 方法产生的标签

8、浏览器支持新标签后，还需要添加标签默认的样式



## CSS隐藏元素的几种方法？

1、opacity： 透明度

2、visibility： 可见的

3、display： 显示

4、position： 位置



## (重点) 性能优化的方法？

1、减小http请求：css Sprites，JS，css源码压缩，图片大小控制合适；网页Gzip，CDN托管，data缓存，图片服务器

2、用innerHTML代替DOM操作，减小DOM操作次数，优化Javascript性能

3、避免使用CSS Expression（CSS表达式）又称Dynamic properties（动态属性）

4、当需要设置的样式很多时设置 className 而不是直接操作style

5、图片预加载，将样式表放在顶部，将脚本放在底部加上时间戳



## 一个页面从输入URL到页面加载显示完成，这个过程中都发生了什么？

4个步骤：

1、当发送一个URL请求时，不管这个URL是web页面的URL还是web页面上每个资源的URL，浏览器都会开启一个线程来处理这个请求，同时在远程DNS服务器上启动一个DNS查询，这能使浏览器获取请求对应的IP地址

2、浏览器与远程web服务器通过TCP三次握手协商来建立一个TCP/IP 连接。该握手包括一个同步报文，一个同步-应答报文和一个应答报文，这三个报文在浏览器和服务器之间传递。该握手首先由服务端尝试建立起通信，而后服务器应答并接受客户端的请求，最后由客户端发出该请求已经被接受的报文。

3、一旦TCP/IP 连接建立，浏览器会通过该连接向远程服务器发送HTTP和GET请求。远程服务器找到资源并使用HTTP响应返回该资源，值为200 的 HTTP 响应状态表示一个正确的响应

4、此时，web服务器提供资源服务，客户端开始下载资源。

#### 简洁版

*浏览器根据请求的URL交给DNS域名解析，找到真实的IP，向服务器发起请求；*

*服务器交给后台处理完成后返回数据，浏览器接收文件(HTML，JS，CSS，图像等等)；*

*浏览器对加载到的资源进行语法解析，建立相应的内部数据结构；*

*载入解析到的资源文件，渲染页面，完成。*



## Javascript对象的几种创建方法？

1、工厂模式

2、构造函数模式

3、原型模式

4、混合构造函数和原型模式

5、动态原型模式

6、寄生构造函数模式

7、稳妥构造函数模式



## Javascript继承的6种方法？

1、原型链继承

2、借用构造函数继承

3、组合继承（原型 + 借用构造）

4、原型式继承

5、寄生式继承

6、寄生组合式继承



## AJAX过程？

1#   创建XMLHttpRequest 对象，也就是创建一个异步调用对象

2#  创建一个新的 HTTP 请求，并指定该 HTTP 请求的方法， URL 及验证信息

3#  设置响应 HTTP 请求状态变化的函数

4#  发送HTTP请求

5#  获取异步调用返回的数据

6#  使用 Javascript 和 DOM 实现局部刷新



另一个说法：

1、服务器获得请求参数

2、服务器处理请求参数（添加，查询等操作）

3、服务器响应数据给浏览器

AJAX 引擎获得服务端响应的数据，通过执行JS的回调函数将数据传递给浏览器页面

1、通过设置而给Ajax引擎的回调函数获得服务器响应的数据

2、使用JS在指定的位置，显示响应数据，从而局部修改页面的数据，达到局部刷新目的。


## AJAX的工作原理

Ajax的工作原理相当于在用户和服务器之间加了一个中间层（AJAX引擎），使用用户操作与服务器响应异步化。并不是所有的用户请求都提交给服务器，像一些数据验证和数据处理等都交给Ajax引擎自己来做，只有确定需要从服务器读取数据时再由Ajax引擎代为向服务器提交请求。

Ajax其核心有JavaScript、XMLHTTPRequest、DOM对象组成，通过XmlHttpRequest对象来向服务器发异步请求，从服务器获得数据，然后用JavaScript来操作DOM而更新页面。

## AJAX的优缺点

优点：
1、无刷新更新数据
> AJAX最大优点就是能在不刷新整个页面的前提下与服务器通信维护数据。这使得Web应用程序更为迅捷地响应用户交互，并避免了在网络上发送那些没有改变的信息，减少用户等待时间，带来非常好的用户体验。

2、异步与服务器通信
> AJAX使用异步方式与服务器通信，不需要打断用户的操作，具有更加迅速的响应能力。优化了Browser和Server之间的沟通，减少不必要的数据传输、时间及降低网络上数据流量。

3、前端和后端负载平衡
> AJAX可以把以前一些服务器负担的工作转嫁到客户端，利用客户端闲置的能力来处理，减轻服务器和带宽的负担，节约空间和宽带租用成本。并且减轻服务器的负担，AJAX的原则是“按需取数据”，可以最大程度的减少冗余请求和响应对服务器造成的负担，提升站点性能。

4、基于标准被广泛支持
> AJAX基于标准化的并被广泛支持的技术，不需要下载浏览器插件或者小程序，但需要客户允许JavaScript在浏览器上执行。随着Ajax的成熟，一些简化Ajax使用方法的程序库也相继问世。同样，也出现了另一种辅助程序设计的技术，为那些不支持JavaScript的用户提供替代功能。

5、界面与应用分离
> Ajax使WEB中的界面与应用分离（也可以说是数据与呈现分离），有利于分工合作、减少非技术人员对页面的修改造成的WEB应用程序错误、提高效率、也更加适用于现在的发布系统。

缺点：
1、AJAX干掉了Back和History功能，即对浏览器机制的破坏。
> 在动态更新页面的情况下，用户无法回到前一个页面状态，因为浏览器仅能记忆历史记录中的静态页面。一个被完整读入的页面与一个已经被动态修改过的页面之间的差别非常微妙；用户通常会希望单击后退按钮能够取消他们的前一次操作，但是在Ajax应用程序中，这将无法实现。

> 后退按钮是一个标准的web站点的重要功能，但是它没法和js进行很好的合作。这是Ajax所带来的一个比较严重的问题，因为用户往往是希望能够通过后退来取消前一次操作的。那么对于这个问题有没有办法？答案是肯定的，用过Gmail的知道，Gmail下面采用的Ajax技术解决了这个问题，在Gmail下面是可以后退的，但是，它也并不能改变Ajax的机制，它只是采用的一个比较笨但是有效的办法，即用户单击后退按钮访问历史记录时，通过创建或使用一个隐藏的IFRAME来重现页面上的变更。（例如，当用户在Google Maps中单击后退时，它在一个隐藏的IFRAME中进行搜索，然后将搜索结果反映到Ajax元素上，以便将应用程序状态恢复到当时的状态。）

> 但是，虽然说这个问题是可以解决的，但是它所带来的开发成本是非常高的，并与Ajax框架所要求的快速开发是相背离的。这是Ajax所带来的一个非常严重的问题。

>一个相关的观点认为，使用动态页面更新使得用户难于将某个特定的状态保存到收藏夹中。该问题的解决方案也已出现，大部分都使用URL片断标识符（通常被称为锚点，即URL中#后面的部分）来保持跟踪，允许用户回到指定的某个应用程序状态。（许多浏览器允许JavaScript动态更新锚点，这使得Ajax应用程序能够在更新显示内容的同时更新锚点。）这些解决方案也同时解决了许多关于不支持后退按钮的争论。

2、AJAX的安全问题
> AJAX技术给用户带来很好的用户体验的同时也对IT企业带来了新的安全威胁，Ajax技术就如同对企业数据建立了一个直接通道。这使得开发者在不经意间会暴露比以前更多的数据和服务器逻辑。Ajax的逻辑可以对客户端的安全扫描技术隐藏起来，允许黑客从远端服务器上建立新的攻击。还有Ajax也难以避免一些已知的安全弱点，诸如跨站点脚步攻击、SQL注入攻击和基于Credentials的安全漏洞等等。

3、对搜索引擎支持较弱
> 对搜索引擎的支持比较弱。如果使用不当，AJAX会增大网络数据的流量，从而降低整个系统的性能。

4、破坏程序的异常处理机制
> 至少从目前看来，像Ajax.dll，Ajaxpro.dll这些Ajax框架是会破坏程序的异常机制的。关于这个问题，曾在开发过程中遇到过，但是查了一下网上几乎没有相关的介绍。后来做了一次试验，分别采用Ajax和传统的form提交的模式来删除一条数据……给我们的调试带来了很大的困难

5、违背URL和资源定位的初衷
> 例如，我给你一个URL地址，如果采用了Ajax技术，也许你在该URL地址下面看到的和我在这个URL地址下看到的内容是不同的。这个和资源定位的初衷是相背离的。

6、AJAX不能很好支持移动设备
> 一些手持设备（如手机、PDA等）现在还不能很好的支持Ajax，比如说我们在手机的浏览器上打开采用Ajax技术的网站时，它目前是不支持的。

7、客户端过肥，太多客户端代码造成开发上的成本
> 编写复杂、容易出错 ；冗余代码比较多（层层包含js文件是AJAX的通病，再加上以往的很多服务端代码现在放到了客户端）；破坏了Web的原有标准


## JSONP原理是什么？

首先客户端注册一个callback，然后callback的名字传给服务器。此时，服务器生成 json 数据，然后以 JS 方法的方式，生成 function，function 名字就是传递上来带参数jsonp。最后将 json 数据直接以入参的方式，放置 function 中，这样就生成JS语法的文档，返回给客户端，客户端浏览器，解析script 变迁，并执行返回JS文档，此时数据作为参数，传入了客户端预先定义好的 callback 函数里。简单地说，就是利用script 标签没有跨域限制的 “漏洞” 来达到与第三方通讯的目的。

json是一种数据格式，jsonp是一种数据调用的方式，带 callback 的 json 就是 jsonp



## JSONP的缺点？

jsonp有个缺陷就是只能get

而且会把请求的内容发送到url中导致安全性极低



## 移动端性能优化？

尽量使用CSS动画，开启硬件加速。适应使用 touch 事件代替 click 事件。避免使用 CSS3 渐变阴影效果。

尽可能少的使用 box-shadow（阴影） 与 gradients（渐变）。box-shadow 与 gradients 往往都是页面的性能杀手。



## 说说你this的理解？

在JS中，this通常指向的是我们正在执行的函数本身，或者是指向该函数所属的对象。

1、普通函数中 this 是window

2、构造函数中 this 是当前的实例对象

3、对象中的 this 是指其本身

4、原型对象的方法中 this 是当前的实例对象

5、计时器中 this 是 window

6、事件处理函数，this 是触发该事件的对象



## 如何编写高性能的JS？

1、使用 DocumentFragment 优化多次 append

2、通过模板元素clone，替代 createElement

3、使用一次innerHTML 赋值代构建 DOM 元素

4、使用 firstChild 和 nextSibling 代替 childNods 遍历 DOM 元素

5、使用 Array 作为 StringBuffter ，代替字符串拼接的操作

6、将循环控制量保存到局部变量

7、顺序无关的遍历时，用 while 代替 for

8、将条件分支，按可能性顺序从到低排列

9、在同一条件子的多（> 2）条件分支时，使用 switch 优于 if

10、在使用三目运算符替代条件分支

11、需要不断执行的时间后，优先考虑使用 setInterval



## 哪些操作会造成内存泄漏？

所谓的内存泄漏，就是在您不再拥有或需要它的时候，仍然存在

垃圾回收机制会定期扫描对象，并计算引用了每个对象的其他对象的数量，如果一个对象的没有被其他对象引用过，或该对象的唯一引用是循环的，那么该对象内存即可回收。

1、setTimeout 的第一个参数使用字符串而非函数的话， 会引发内泄漏

2、闭包

3、控制台日志

4、循环（在两个对象彼此引用且彼此保留时，就会产生一个循环）



## ES6更新了哪些新特性？

1. **默认参数**

   ```javascript
   //ES5我们这样定义默认参数
   var link = function (height, color, url) {
       var height = height || 50;
       var color = color || 'red';
       var url = url || 'http://azat.co';
       ...
   }
   ```

   这样做是有一点小问题的，当默认参数为0时就暴露问题了，因为在JavaScript中，0表示false。

   ```javascript
   // ES6可以默认值写在函数声明里
   var link = function(height = 50, color = 'red', url = 'http://azat.co') {
     ...
   }
   ```

   

2. **模板文本**

   ```javascript
   // ES5的字符串拼接
   var name = 'Your name is ' + first + ' ' + last + '.';
   var url = 'http://localhost:3000/api/messages/' + id;
   ```

   ES6的字符串远不用如此麻烦，我们可以在反引号（~符的unshift键）中使用新语法 **${变量名称}** 表示。

   ```javascript
   // ES6
   var name = `Your name is ${first} ${last}. `;
   var url = `http://localhost:3000/api/messages/${id}`;
   ```

3. **多行字符串**

   ```javascript
   // ES5 多行字符串需要 + 号连接
   var roadPoem = 'Then took the other, as just as fair,nt'
       + 'And having perhaps the better claimnt'
       + 'Because it was grassy and wanted wear,nt'
       + 'Though as for that the passing therent'
       + 'Had worn them really about the same,nt';
   var fourAgreements = 'You have the right to be you.n
       You can only be you when you do your best.';
   ```

   然而在ES6中，仅仅用反引号就可以解决了：

   ```javascript
   var roadPoem = `Then took the other, as just as fair,
       And having perhaps the better claim
       Because it was grassy and wanted wear,
       Though as for that the passing there
       Had worn them really about the same,`;
   var fourAgreements = `You have the right to be you.
       You can only be you when you do your best.`;
   ```

   

4. **解构赋值**

   这是一个比较难掌握的知识点，我们先用比较简单的例子切入。

   下面这些情况都是很常见的：

   ```javascript
   //ES5中获取data对象中的属性
   var data = response.data,    // data has properties info and imageLink 
       info = data.info,
       imageLink = data.imageLink 
   //ES5获取一个模块中的方法
   var stringHandle = require('toolModule').stringHandle ;
   ```

   ES6中，我们可以使用解构处理以上两种情况：

   ```javascript
   var {info, imageLink} = response.data;
   var {stringHandle} = require('toolModule')
   ```

   右侧的response.data和require('toolModule')都是对象，与左侧的 { } 格式相同，首先要保证这一点。个人理解{info, imageLink} = response.data像是**{info, imageLink} = {response.data.info, response.data.imageLink}这样一个对应关系**，然后我们就可以直接使用 info 和 imageLink 这两个变量了。

   

5. **增强的对象文本**

   下面是一个典型ES5对象文本，里面有一些方法和属性：

   ```javascript
   var serviceBase = {port: 3000, url: 'azat.co'},
       getAccounts = function(){return [1,2,3]};
   var accountServiceES5 = {
     port: serviceBase.port,
     url: serviceBase.url,
     getAccounts: getAccounts,
      toString: function() {
         return JSON.stringify(this.valueOf());
     },
     getUrl: function() {return "http://" + this.url + ':' + this.port},
     valueOf_1_2_3: getAccounts()
   }
   ```

   如果我们想让它更有意思，我们可以用Object.create从serviceBase继承原型的方法：

   ```javascript
   var accountServiceES5ObjectCreate = Object.create(serviceBase)
   var accountServiceES5ObjectCreate = {
     getAccounts: getAccounts,
     toString: function() {
       return JSON.stringify(this.valueOf());
     },
     getUrl: function() {return "http://" + this.url + ':' + this.port},
     valueOf_1_2_3: getAccounts()
   }
   ```

   

6. **箭头函数**

   这是我迫不及待想讲的一个特征，CoffeeScript 就是因为它丰富的箭头函数让很多开发者喜爱。在ES6中，也有了丰富的箭头函数。这些丰富的箭头是令人惊讶的因为它们将使许多操作变成现实，比如，

   以前我们使用闭包，this总是预期之外地产生改变，而箭头函数的迷人之处在于，现在你的this可以按照你的预期使用了，身处箭头函数里面，this还是原来的this。

   有了箭头函数在ES6中， 我们就不必用that = this或 self =  this  或 _this = this  或.bind(this)。例如，下面的代码用ES5就不是很优雅：

   ```javascript
   var _this = this;
   $('.btn').click(function(event){
     _this.sendData();
   })
   ```

   在ES6中就不需要用 _this = this：

   ```javascript
   $('.btn').click((event) =>{
     this.sendData();
   })
   ```

7. **Promises**

   Promises 是一个有争议的话题。因此有许多略微不同的promise 实现语法。Q，bluebird，deferred.js，vow, avow, jquery 一些可以列出名字的。也有人说我们不需要promises，仅仅使用异步，生成器，回调等就够了。但令人高兴的是，在ES6中有标准的Promise实现。

   下面是一个简单的用setTimeout()实现的异步延迟加载函数:

   ```javascript
   setTimeout(function(){
     console.log('Yay!');
   }, 1000);
   ```

   或者用ES6的箭头函数：

   ```javascript
   var wait1000 =  new Promise((resolve, reject)=> {
     setTimeout(resolve, 1000);
   }).then(()=> {
     console.log('Yay!');
   });
   ```

8. **块作用域和构造 let 和 const**

   在ES6代码中，你可能已经看到那熟悉的身影let。在ES6里let并不是一个花俏的特性，它是更复杂的。Let是一种新的变量申明方式，它允许你把变量作用域控制在块级里面。

     

   在ES5中，大括号的块级作用域起不了任何作用：

   ```javascript
   function calculateTotalAmount (vip) {
     var amount = 0;
     if (vip) {
       var amount = 1;
     }
     { 
       var amount = 100;
       {
         var amount = 1000;
       }
     }  
     return amount;
   }
   console.log(calculateTotalAmount(true));　　　　// 1000，最后定义的生效，块级作用域无作用
   ```

   块级作用域中let定义的变量，只在此块级作用域中生效，外层无法访问。

   ```javascript
   function calculateTotalAmount (vip) {
     var amount = 0; 
     if (vip) {
       let amount = 1; 
     } 
     { 
       let amount = 100; 
       {
         let amount = 1000; 
       }
     }  
     return amount;
   }
    
   console.log(calculateTotalAmount(true));　　// 0，用let定义的变量都不可被最外层访问
   ```

   这里简单提一下，假如if句改为 **if( vip ){ amount = 1 } ，那么结果是1，因为这样相当于定义了一个全局变量。**

    

   我们知道，const用于声明常量，同一常量只可声明一次，声明后不可修改，而下面的代码中对于同一常量声明了多次，却没有报错，原因就是每个常量都只属于它所在的块级作用域，互不影响。

   

9. **类（Classes）**

   现在就来看看如何用ES6写一个类吧。ES6没有用函数, 而是使用原型实现类。我们创建一个类baseModel ，并且在这个类里定义了一个constructor 和一个 getName()方法：

   ```javascript
   class baseModel {
     constructor(options, data) {
       this.name = 'Base';
       this.url = 'http://azat.co/api';
       this.data = data;
       this.options = options;
      }
    
       getName() { // class method
           console.log(`Class name: ${this.name}`);
       }
   }
   ```

   AccountModel 从类baseModel 中继承而来:

   ```javascript
   class AccountModel extends baseModel {
       constructor(options, data) {
   　　　　//为了调用父级构造函数，可用super()参数传递：
   　　　　super({private: true}, ['32113123123', '524214691']); //call the parent method with super
          this.name = 'Account Model';
          this.url +='/accounts/';
       }
   // 可以把 accountData 设置成一个属性：
   　　get accountsData() { //calculated attribute getter
        return this.data;
      }
   }
   
   //----------------------
   
   
   let accounts = new AccountModel(5);
   accounts.getName();    //Class name: Account Model
   console.log('Data is %s', accounts.accountsData);    //Data is  32113123123,524214691
   ```

   

10. **模块（Modules）**

   众所周知，在ES6以前JavaScript并不支持本地的模块。人们想出了AMD，RequireJS，CommonJS以及其它解决方法。现在ES6中可以用模块import 和export 操作了。

   
   ```javascript
   // 在ES5中，你可以在 <script>中直接写可以运行的代码（简称IIFE），或者一些库像AMD。然而在ES6中，你可以用export导入你的类。下面举个例子，在ES5中,module.js有port变量和getAccounts 方法:
   // dev.js文件
   module.exports = {
     port: 3000,
     getAccounts: function() {
       ...
     }
   }
   ```

   在ES5中，需要依赖require(‘module’) 导入dev.js：

   ```javascript
   var service = require('dev.js');
   console.log(service.port); // 3000
   ```

   但在ES6中，我们将用export and import。例如，这是我们用ES6 写的dev.js文件库：

   ```javascript
   // dev.js文件
   export var port = 3000;
   export function getAccounts(url) {
     ...
   }
   ```

   如果用ES6来导入到文件中，我们需用import {name} from ‘my-module’语法，例如：

   ```javascript
   import {port, getAccounts} from 'dev';
   console.log(port); // 3000
   ```

   或者我们可以在文件中把整个模块导入, 并命名为 service：

   ```javascript
   import * as service from 'dev';
   console.log(service.port); // 3000
   ```

# Vue框架面试题

## V-show 指令，v-if 的区别？

条件渲染指令，与v-if 不同的是，无论 v-show 的值为 true 或 false，元素都会存在于HTML代码中，而只有当 v-if 的值为true元素才会存在于 THML 代码中，v-show 指令只是设置了元素 CSS 的 style 值。

使用MVVM模式有4个好处：

1. 低耦合。view 可以独立于model 变化和修改，一个viewModel 可以绑定到不同的view上，当view 变化的时候model可以不变，当 Model 变化的时候 View 也可以不变。
2. 可重用性。可以把一些视图的逻辑放在viewModel 里面，让很多View 重用这段视图逻辑
3. 独立开发。开发人员专注与业务逻辑和数据的开发。设计人员可以专注于界面（View）的设计
4. 可测试性。可以针对viewModel 来对界面进行测试



![MVVM模式工作原理](https://zhanglong292383147.gitee.io/picture_images/picture/Mianjingxuan/8.png)



Vue.js 特点：

简洁：页面由HTML模式板 + JSON数据 + Vue 案例组成

数据驱动：自动计算属性和追踪依赖的模板表达式

组件化：用于复用、解耦的组件来构造页面

轻量：代码量小，不依赖其他库

快速：精确有效批量 DOM 更新

模板友好：可通过npm，bower等多种方式安装，很容易融入



## 怎么定义 vue-router 的动态路由？怎么获取传过来的动态参数？

在 router 目录下的index.js文件中，对 path 属性上 /:id 的 params.id 使用 router 对象



## vue-router 有哪种导航钩子？

第一种：是全局导航钩子：router.beforeEach（to，from，next），作用：跳转前进进行判断拦截

第二种：组件内的钩子

第三种：单独路由独享组件



## v-model 是什么？怎么使用？vue 中标签怎么绑定事件？

```
可以实现双向绑定，指令 （v-class，v-for，v-if，v-show，v-on） vue 的 model 层的 data 属性。绑定事件<input @click=del() />

```

## vuex 是什么？怎么使用？哪种功能场景使用它？

Vuex 是一个专为 Vue.js 应用程序开发的**状态管理模式**，在main.js 引入ctore，注入。新建一个目录 store、...export 场景有：单页应用中，组件之间的状态音乐播放器，登录状态，加入购物车

------------------------------

每一个 Vuex 应用的核心就是 store（仓库）。“store”基本上就是一个容器，它包含着你的应用中大部分的**状态 (state)**。Vuex 和单纯的全局对象有以下两点不同：

1. Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。
2. 你不能直接改变 store 中的状态。改变 store 中的状态的唯一途径就是显式地**提交 (commit) mutation**。这样使得我们可以方便地跟踪每一个状态的变化，从而让我们能够实现一些工具帮助我们更好地了解我们的应用。

## 你是怎么认识 Vuex 的？

Vuex 可以理解为一种开发模式或框架。通过状态（数据源）集中管理驱动组件的变化。

应用级的状态集中放在 store（仓库） 中，改变状态的方式是提交 mutations，这是个同步的事物，异步逻辑应该封装在 action 中

![img](https://zhanglong292383147.gitee.io/picture_images/picture/Mianjingxuan/9.jpg)

- **state**，驱动应用的数据源；
- **view**，以声明方式将 **state** 映射到视图；
- **actions**，响应在 **view** 上的用户输入导致的状态变化。

## vue-router 是什么？它有哪些组件？

vue用来写路由一个插件 router-link，router-view



## Vue的双向数据绑定原理是什么？

![VUE双向绑定原理](https://zhanglong292383147.gitee.io/picture_images/picture/Mianjingxuan/10.png)

这里VM，就是 vue 框架它相当于中间枢纽的作用，连接着 `model` 和 `view`

当前台显示的 `view` 发生变化了，它会实时反应到 `viewModel`（上，如果有需要，`viewModel` 会通过 `Ajax` 等方法将改变的数据传递给后台 `model` ）

同时从后台 `model` 获取过来的数据，通过 VM 将值响应到前台 UI 上

![input事件数据绑定原理](https://zhanglong292383147.gitee.io/picture_images/picture/Mianjingxuan/11.png)

VM的核心是 `view` 和 `data`

当 data 有变化的时候它通过 **object.defineProperty()**  方法中的 **set** 方法进行监控，并调用在此之前已经定义好 **data** 和 **view** 的关系了的回调函数，来通知 view 进行数据的改变。

而 `view` 发生改变则是通过底层的 `input` 事件来进行 `data` 的响应更改

Vue 是通过 **object.defineProperty()** 来实现**数据劫持**的。（它可以来控制一个对象属性的一些特有操作，比如读写权、是否可以枚举）

实现方法：观察者模式

MVVM 框架类：

![观察者模式的MVVM框架的工作原理](https://zhanglong292383147.gitee.io/picture_images/picture/Mianjingxuan/12.png)

Observer（object.defineProperty 中的 set）**监听** data 的变化，当 data **有变化**的时候**通知**观察者列表 **Dep**（里面有与 Data 变化对应的Update 函数），watcher**（监听器）** 负责向**观察者列表**（Dep）**添加**（订阅）对应的**更新函数**，Dep 里的更新函数执行了之后将*最新的值* **更新** 到 **View（视图）**上



## 请详细说下你对 Vue 生命周期的理解？

总共分 为 8个阶段：创建前 / 后，载入前 / 载入后，更新前 / 后，销毁前 / 后

创建前 / 后：在 **beforeCreate (创建前)** 阶段，Vue实例的**挂载元素** el 和**数据对象** data 都为 **undefined**，还未初始化。在 **created (创建后)** 阶段，Vue 实例的**数据对象** data **有**了,  **el** 还**没有**。

载入前 / 后：在**beforeMount** 阶段，Vue实例的 **el** 和 **data** 都**初始化**了，但还是挂载之前为虚拟的 DOM 节点，data.message 还未替换。在 **mounted** 阶段，Vue实例**挂载完成**，data.message 成功 **渲染**

更新前 / 后：当 **data** 变化时，会**触发** beforeUpdate 和 updated 方法。

销毁前 / 后：在执行 destroy 方法后，对 data 的改变不会再触发函数，说明此时 Vue 实例已经**解除**了**事件监听**以及和 **DOM 的绑定**，但是 dom **结构**依然**存在**

```html
<body>
    <div id="app">
        <p>{{info}}</p>
        <button @click="info='hello1'">更新info</button>
        <button @click="destroy">销毁实例</button>
    </div>
    <script>
        var vm = new Vue({
            el: "#app",
            data: {
                info: "hello"
            },
            // 在实例初始化之后，数据观测 (data observer) 和 event/watcher 配置之前被调用。
            beforeCreate: function () {
                console.log("===============beforeCreate============================================")
                // $el表示Vue 实例使用的根 DOM 元素。
                console.log('$el', this.$el);
                // $data Vue 实例观察的数据对象
                console.log('$data', this.$data);
                console.log("info:", this.info)
            },
            // 在实例创建完成后被立即调用。
            // 在这一步，实例已完成以下的配置：
            // 数据观测 (data observer)，
            // 属性和方法的运算，
            // watch/event 事件回调。
            // 然而，挂载阶段还没开始，dom还未生成，$el 属性目前不可见。
            // 一般都在created中发送请求
            created: function () {
                console.log("===============created=======================================")
                console.log('$el', this.$el);
                console.log('$data', this.$data);
                console.log("info:", this.info)
            },
            //  模板编译挂载之前调用，首先会判断对象是否有el选项。
            //  如果有的话就继续向下编译，如果没有el选项，则停止编译,
            //  也就意味着停止了生命周期，直到在该vue实例上调用vm.$mount(el)。
            //  接着判断是否有template属性，
            //  有的话就以template属性中的值作为模板，如果没有的话，就以el属性指向的作为模板。
            //  这里会生成vm.$el，但指令尚未被解析
            beforeMount: function () {
                console.log("===============beforeMount=========================================")
                console.log('$el', this.$el);
                console.log('$data', this.$data);
                console.log("info:", this.info)
            },
            // 模板编译挂载之后调用，vm.$el替换掉el指向的dom
            mounted: function () {
                console.log("===============mounted===========================================")
                console.log('$el', this.$el);
                console.log('$data', this.$data);
                console.log("info:", this.info)
            },
            // 数据变更导致虚拟DOM重新渲染之前调用
            beforeUpdate: function () {
                console.log("===============beforeUpdate============================================");

            },
            // 数据变更导致虚拟DOM重新渲染之后调用
            updated: function () {
                console.log("===============updated======================================================");
            },
            // 实例销毁之前调用，在这一步，实例完全可用
            beforeDestroy: function () {
                console.log("===============beforeDestroy===============================================")
                console.log('$el', this.$el);
                console.log('$data', this.$data);
                console.log("info:", this.info)
            },
            // vue实例指向的所有东西解除绑定，包括watcher、事件、所以的子组件，后续就不再受vue实例控制了
            destroyed: function () {
                console.log("===============destroyed================================================")
                console.log('$el', this.$el);
                console.log('$data', this.$data);
                console.log("info:", this.info)
            },
            methods: {
                destroy() {
                    // 表示销毁组件
                    this.$destroy()
                },
                udpateinfo() {
                    this.info = 'hello2'
                }
            }
        })
    </script>
</body>
```

![生命周期创建过程1](https://zhanglong292383147.gitee.io/picture_images/picture/Mianjingxuan/13.png)



![生命周期创建过程2](https://zhanglong292383147.gitee.io/picture_images/picture/Mianjingxuan/14.png)



## Vue 组件封装过程？

首先，使用 Vue.extend() 创建一个组件

然后，使用 Vue.component() 方法注册组件

接着，如果子组件需要数据，可以在 props 中接受定义

最后，子组件修改好数据之后，想把数据传递给父组件，可以使用 emit() 方法



## 注册 vue 组件的几种方式？

### a、全局注册 ( 这种方式注册组件必须在 vue 实例化之前声明 )

Vue.component( 'tag-name', {} )

### b、局部注册

```js
var Child = {
  template: '<div>A custom component!</div>'
}
new Vue({
  // ...
  components: {
    // <my-component> 将只在父模板可用
    'my-component': Child
  }
})
```

### c、扩展实例

```js
// 定义一个混合对象
var myMixin = {
  created: function () {
    this.hello()
  },
  methods: {
    hello: function () {
      console.log('hello from mixin!')
    }
  }
}
// 定义一个使用混合对象的组件
var Component = Vue.extend({
  mixins: [myMixin]
})
var component = new Component() // -> "hello from mixin!"
```



## vue 有几种插槽？

**Vue中的 三种插槽分别为 匿名插槽，命名插槽，作用域插槽。**

## 匿名插槽

子组件：

```html
<div>
    <li>我是老大</li>
    <slot></slot>
</div>
```


父组件：子组件挂在在父组件上 生成标签

```html
<div>
    <son>
        <li>天天</li>
    </son>
</div>
```


父组件解译：

```html
<div>
    <li>我是老大</li>
    <li>天天</li>
</div>
```

## 命名插槽

子组件;

```html
<div>
    <slot name="dada"></slot>
    <li>我是老大</li>
    <slot name="didi"></slot>
</div>
```


父组件;子组件挂在父组件上 生成标签

```html
<div>
    <son>
        <li solt="dada"> 我是老太</li>
        <li solt="didi">我是老小子</li>
    </son>
</div>
```


父组件解译：

```html
<div>
    <li>我是老太</li>
    <li>我是老大</li>
    <li>我是老小子</li>
</div>
```

## 作用域插槽

子组件;

```html
<div>
    <slot name="dada" up="上"></slot>
    <li>我是老二</li>
    <solt name="didi" down="下"></solt>
</div>
```


父组件：子组件挂在父组件上 生成标签

```html
<div>
    <son>
        <li solt="dada" slot-scopt="st">{{st.up}}</li>
         <li solt="didi" slot-scopt="st">{{st.down}}</li>
    </son>
</div>
```


父组件编译：

```html
<div>
    <li>上</li>
    <li>我是老二</li>
    <li>下</li>
</div>
```

## computed 和 watch 的区别？

计算属性顾名思义就是通过其他变量计算得来的另一个属性， fullName 在它所依赖 firstName ， lastName 这两个变量变化时重新计算自己的值。
 另外，计算属性具有缓存。计算属性是基于它们的依赖进行缓存的。计算属性只有在它的相关依赖发生改变时才会重新求值。这就意味着只要 lastName 和 firstName都没有发生改变，多次访问 fullName 计算属性会立即返回之前的计算结果，而不必再次执行函数。
 而侦听器 `watch` 是侦听一个特定的值，当该值变化时执行特定的函数。例如分页组件中，我们可以监听当前页码，当页码变化时执行对应的获取数据的函数。

```html
<div id="myDiv">
    <input type="text" v-model="firstName">
    <input type="text" v-model="lastName">
    <input type="text" v-model="fullName">
</div>
```



```js
// watch
new Vue({
  el: '#myDiv',
  data: {
    firstName: 'Foo',
    lastName: 'Bar',
    fullName: 'Foo Bar'
  },
  watch: {
    firstName: function (val) {
      this.fullName = val + ' ' + this.lastName
    },
    lastName: function (val) {
      this.fullName = this.firstName + ' ' + val
    }
  }
})
// computed
new Vue({
       el:"#myDiv",
            data:{
                firstName:"Den",
                lastName:"wang",

            },
            computed:{
                fullName:function(){
                    return  this.firstName  + " " +this.lastName;
                }
            }
   })
```

也就是说，`computed` 对于其中变量的依赖是多个的，它的函数中使用了多个 `this.xxx` ,只要其中一个发生了变化，都会触发这个函数。而 `watch` 的依赖则是单个的，它每次只可以对一个变量进行监控。



## Vue-loader 是什么？

解析 Vue 文件的一个加载器，跟 template/js/style 转换成 JS 模块

提供了一些非常酷炫的特性：

ES5默认可用；

```
在每个 Vue 组件内支持其他的 webpack 加载器，如用于 <style> 的 SASS 和用于<template>的 Jade

把 <style>和<template>内引用的静态资源作为模块依赖项对待，并用 webpack 加载器处理。

对每个组件模拟有作用域的 css

开发阶段支持组件的热加载

简单的说，webpack 和 vue-loader 的组合为你创作 Vue 应用一个更先进、更灵巧极其强大的前端开发模式
```

## 使用它的用途有哪些？

JS 可以写 es6、style 样式可以 scss 或 less、template可以加 jade 等。



## 说出至少4种Vue当中的指令和它的用法

v-if：判断是否隐藏；

v-for：数据循环出来；

v-bind：class：绑定一个属性；

v-model：实现双向绑定



## 自定义指令（v-check、v-focus）的方法有哪些？它有哪些钩子函数？还有哪些钩子函数参数？

全局定义指令：在 Vue 对象的 driective 方法里面有两个参数，一个是指令名称，另一个是函数。组件内定义指令：directives；

钩子函数：bind（绑定事件触发），inserted（节点插入的时候触发）、update（组件内相关更新）

钩子函数参数：el ， binding



理解 Vue 自定义指令钩子函数：

一个指令定义对象可以提供如下几个钩子函数（均为可选）：

bind：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置

inserted：被绑定元素插入父节点时调用（仅保证父节点存在，但不一定已被插入文档中）

update：所在组件的 VNode 更新时调用，但是可能发生在其子 VNode 更新之前。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新

componentUpdated：指令所在组件的 VNode 及其子 VNode 全部更新后调用。

conbind：只调用一次，指令与元素解绑时调用。



指令钩子函数会被传入以下参数：

el：指令所绑定的元素，可以用来直接操作 DOM

binding：一个对象，包含以下属性：

name：指令名，不包含 v-前缀

value：指令的绑定值，例如：v-my-directive=“ 1 + 1” 中，绑定值为2

oldValue：指令绑定的前一个值，仅在 Update 和 compnentUpated 钩子中可用。无论值是否改变都可用

expression：字符串形式的指令表达式。例如 v-my-directive=“ 1 + 1 ” 中，表达式为“1+1”

avg：传给指令的参数，可选。例如：v-my-directive：foo 中，参数为 “foo”

modifiers：一个包含修饰符的对象。例如：v-my-directive.foo.bar 中，修饰符对象为 { foo：true，bar：true }

vnode：Vue 编译生成的虚拟节点。移步 VNode API 来了解更多详情

oldVnode：上一个虚拟节点，仅在 update 和 componentUpdated 钩子中可用。



## axios是什么？怎么使用？描述使用它实现登录功能的流程？

1. 请求后台资源的模块。 npm i axios -s 装好
2. 然后发送的是跨域，需在配置文件中 config/index.js 进行设置
3. 后台如果是TP5 则定义一个资源路由。JS 使用import 进来，
4. 然后 .get 或 .post 返回在 .this 函数中如果成功
5. 失则则是在 .catch 函数中



## axios + tp5 进价中，调用 axios.post(' api/user ') 是进行的什么操作？axios.put('api/8') 呢？

跨域，添加用户操作，更新操作。



## 请说下具体使用 Vue 的理解？

1. 使用 Vue 不必担心布局更改和类名重复导致的 JS 重写，因为它是靠数据驱动双向绑定，底层是通过 Object.defineProperty() 定义的数据，set、get 函数原理实现。
2. 组件化开发，让项目的可拓展性、移植性更好，代码重用性更高，就好像农民工建房子，拿起自己的工具包就可以开工。项目经理坐等收楼就好。
3. 单页应用的体验零距离接触安卓原生应用，局部组件更新界面，让用户体验更快速省时。
4. JS 的代码无形的规范，团队合作开发代码可阅读性更高。



## 你觉得哪些项目适合 Vue 框架？

1. 数据信息量比较多的，反之类似企业网站就无需此框架了
2. 手机 web 和 app 应用多端共用一套界面的项目，因为使用 Vue.cli + webpack 后的前端目录，非常有利于项目的跨平台部署。



## Vue 组件之间如何通信？

作为一个vue初学者不得不了解的就是组件间的数据通信(暂且不谈vuex)。通信方式根据组件之间的关系有不同之处。组件关系有下面三种：**父-->子**、**子-->父**、**非父子**

#### 父-->子

父向子传递数据通过props

```javascript
//父组件代码
<template>
    <header-box :title-txt="showTitleTxt"></header-box>
</template>
<script>
    import Header from './header'
    export default {
        name: 'index',
        components: {
            'header-box': Header
        },
        data () {
            return {
                showTitleTxt: '首页'
            }
        }
    }
</script>
```

```javascript
//子组件代码
<template>
    <header>
        {{thisTitleTxt}}
    </header>
</template>
<script>
    export default {
        name: 'header-box',
        props: {
            titleTxt: String
        },
        data () {
            return {
                thisTitleTxt: this.titleTxt
            }
        }
    }
</script>
```

#### 子-->父

> 子组件向父组件传递分为两种类型。
> 1、子组件改变父组件传递的props（你会发现通过props中的Object类型参数传输数据，可以通过子组件改变数据内容。这种方式是可行的，但是不推荐使用，因为官方定义prop是单向绑定）
> 2、通过$on和$emit

```javascript
//通过props实现传递
//父组件代码
<template>
    <header-box :title-txt="showTitleTxt"></header-box>
</template>
<script>
    import Header from './header'
    export default {
        name: 'index',
        components: {
            'header-box': Header
        },
        data () {
            return {
                showTitleTxt: {
                    name: '首页'
                }
            }
        }
    }
</script>
```

```javascript
//子组件代码
<template>
    <header @click="changeTitleTxt">
        {{thisTitleTxt.name}}
    </header>
</template>
<script>
    export default {
        name: 'header-box',
        props: {
            titleTxt: Object
        },
        data () {
            return {
                thisTitleTxt: this.titleTxt.name
            }
        },
        metheds: {
            changeTitleTxt () {
                this.titleTxt.name = '切换'
            }
        }
    }
</script>
```

```javascript
//通过$on,$emit
//父组件代码
<template>
    <div id="counter-event-example">
      <p>{{ total }}</p>
      <button-counter v-on:increment="incrementTotal"></button-counter>
</div>
</template>
<script>
    import ButtonCounter from './buttonCounter'
    export default {
        name: 'index',
        components: {
            'button-conuter': ButtonCounter
        },
        data () {
            return {
                total: 0
            }
        },
        methods: {
            incrementTotal () {
                this.total++
            }
        }
    }
</script>
```

```javascript
//子组件代码
<template>
    <button @click="incrementCounter">{{counter}}</button>
</template>
<script>
    export default {
        name: 'button-counter',
        data () {
            return {
                counter: 0
            }
        },
        metheds: {
            incrementCounter () {
                this.$emit('increment')
                this.counter++
            }
        }
    }
</script>
```

#### 非父子

> 简单情况下我们可以通过使用一个空的Vue实例作为中央事件总线，（这里也可以使用app实例，而不需要新建一个空Vue实例）

```javascript
//main.js
let bus = new Vue()
Vue.prototype.bus = bus
```

或者

```js
//main.js
new Vue({
  el: '#app',
  router,
  template: '<App/>',
  components: { App },
  beforeCreate () {
    Vue.prototype.bus = this
  }
})
```

```js
//header组件
<template>
    <header @click="changeTitle">{{title}}</header>
</template>
<script>
export default {
    name: 'header',
    data () {
        return {
            title: '头部'
        }
    },
    methods: {
        changeTitle () {
            this.bus.$emit('toChangeTitle','首页')
        }
    }
}
</script>
```

```html
//footer组件
<template>
    <footer>{{txt}}</footer>
</template>
<script>
export default {
    name: 'footer',
    mounted () {
        this.bus.$on('toChangeTitle', function (title) {
            console.log(title)
        })
    },
    data () {
        return {
            txt: '尾部'
        }
    }
}
```

## 【重点】sessionStorage、localStorage  和 cookie 的区别？

共同点：都是保存在浏览器端、且同源的 
区别： 
1、cookie 数据始终在同源的 http 请求中携带（即使不需要），即 cookie 在浏览器和服务器间来回传递，而sessionStorage 和 localStorage不会自动把数据发送给服务器，仅在本地保存。cookie 数据还有路径（path）的概念，可以限制 cookie 只属于某个路径下 
2、存储大小限制也不同，cookie 数据不能超过 4K，同时因为每次http请求都会携带 cookie、所以 cookie 只适合保存很小的数据，如会话标识。sessionStorage 和 localStorage 虽然也有存储大小的限制，但比 cookie 大得多，可以达到 5M 或更大 
3、数据有效期不同，
sessionStorage：仅在当前浏览器窗口关闭之前有效；
localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；
cookie：只在设置的 cookie 过期时间之前有效，即使窗口关闭或浏览器关闭 
4、作用域不同，sessionStorage 不在不同的浏览器窗口中共享，即使是同一个页面；localstorage 在所有同源窗口中都是共享的；cookie 也是在所有同源窗口中都是共享的 
5、web Storage 支持事件通知机制，可以将数据更新的通知发送给监听者 
6、web Storage 的 api 接口使用更方便



## 关于vue在app首次加载缓慢的解决办法？

*1.路由懒加载*

![](https://zhanglong292383147.gitee.io/picture_images/picture/vue/87.jpg)

​											路由懒加载

此方法会把原本打包到一个app.js文件分开成多个js文件打包，这样会减小单个文件的大小，但是不会减小整个js文件夹的大小。通过这种方式可以做到按需加载，只加载单个页面的js文件。

*2.组件异步加载*

![](https://zhanglong292383147.gitee.io/picture_images/picture/vue/88.jpg)

组件异步加载

加载首页的时候，可以先给首页的子组件设置v-if = “false”，在页面初始化的时候再给子组件设置为true，此方法利用了v-if的惰性，setTimeout会使子组件在所有的组件初始化完成并显示后再对其子组件进行初始化。

- [x] **注：在实际开发中还遇到了另一种情况也可以用此方法解决，在入口js中获取了app的token，但是在具体页面中发现不管是在created还是mounted中都是有时候能获取到token，有时候又不可以，是因为执行顺序的原因，可以通过 setTimeout 时间设置为0 这种方法把用到token的请求方法给排到最后，这样就能保证请求方法中有token了。**

*3.使用异步组件，按需加载*

```js
newVue({
// ...
  components: {
        'my-component':()=>import('./my-async-component')
  }
})
```

es6的写法，`import` 函数会返回一个 `Promise` 对象。这样就实现了组件的按需加载，有需要的时候才会加载这个组件，同样也是优化首屏加载速度的一种方法。

下面两张图片就可以清晰的了解 import xxx from "./xxx.vue" 与 import()方法 的不同，以及用import函数所带来的好处。





![](https://zhanglong292383147.gitee.io/picture_images/picture/vue/89.jpg)

  import xxx from "./xxx.vue"  

![](https://zhanglong292383147.gitee.io/picture_images/picture/vue/90.jpg)

   import()方法

上面是两种方法，打包后所生成的文件，import函数的方法很明显多了几个js，这就是从原本 app.js 中分离出来的0.js，1.js，2.js。第一张图，在运行的时候会把app.js整个加载完，而第二张图会加载0.js+app.js，虽然多了一个文件，但实际上，后者整体加载的文件大小要比原本小很多。这就是按需加载，在需要1.js的时候才会加载它，而且加载过一次后就会缓存在本地，下次加载，会取缓存的文件。

而且，因为import函数返回的是一个promise对象，因此可以用promise本身的then()和catch()方法去监听到组件的加载，如：

![](https://zhanglong292383147.gitee.io/picture_images/picture/vue/91.jpg)

*4.图片量多的时候可以进行分批的加载*

vue-lazyload插件，图片懒加载

*5.外部引入一些插件，不要在vue中引入*

列入，我在次项目中有用到moment.js这个插件，在vue内部引入后打包的项目大小要比在外部用src的方式引入打包的项目大个300k左右。

首先，下载好 moment.min.js 包，然后在 vue 项目的 webpack.base.conf.js 中添加下图箭头所指向的那段代码

![](https://zhanglong292383147.gitee.io/picture_images/picture/vue/92.jpg)

加上上图的代码后是不会将moment.js给打包到js中的。

## get和post区别
1、Get产生一个TCP数据包；Post产生两个TCP数据包。
对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；
对于POST，浏览器先发送header，服务器响应100（continue），然后再发送data，服务器响应200（返回数据）；

2、get用于获取数据，post用于提交数据。
3、get参数有长度限制（受限于url长度，具体的数值取决于浏览器和服务器的限制），而post无限制

## zepto和jquery的区别?
1、Zepto更轻量级 
2、Zepto是jQuery的精简，针对移动端去除了大量jQuery的兼容代码 
3、部分API的实现方式不同


 `#1`针对移动端程序，Zepto有一些基本的触摸事件可以用来做触摸屏交互（tap事件、swipe事件），Zepto是不支持IE浏览器的。

 `#2`DOM操作的区别：添加id时jQuery不会生效而Zepto会生效

 `#3`事件触发的区别：使用jquery时load事件的处理函数不会执行；使用zepto时load事件的处理函数会执行

 `#4`事件委托的区别：zepto中，选择器上所有的委托事件都依次放入到一个队列中，而在jquery中则委托成独立的多个事件

 `#5`width() 与 height()的区别：zepto由盒模型（box-sizing）决定，用.width()返回赋值的width，用.css(‘width’)返回border等的结果；jquery会忽略盒模型，始终返回内容区域的宽/高（不包含padding、border）.

 `#6`offset()的区别：zepto返回{top,left,width,height}; jquery返回{width,height}。zepto无法获取隐藏元素宽高，jquery可以

 `#7`zepto中没有为原型定义extend方法而jquery有

 `#8`zepto的each方法只能遍历数组，不能遍历JSON对象。

jQuery 和 Zepto.js 表面看起来差不多，其实一些细节上差异很大，同时支持 jQuery 和 Zepto.js 是一件吃力不讨好的事情，这应该也是 Foundation 5 放弃支持 Zepto 的一个原因。


## CSS盒子居中的几种方法

**利用margin，div1的宽减去div2的宽就是div2margin-left的数值：（100-40）/2=30**
div1的高减去div2的高就是div2margin-top的数值：（100-40）/2=30


```html
<!DOCTYPE html>
<html>
    <head>
        <meta charset="UTF-8">
        <title>demo</title>
    </head>
    <body>
        <style type="text/css">
            .div1{  width: 100px; height: 100px; border: 1px solid #000000;} 
            .div2{ width:40px ; height: 40px; background-color: green;}
            .div22{
                margin-left: 30px;margin-top: 30px;
            }
        </style>
        <div class="div1">
            <div class="div2 div22">
            </div>
        </div>
    </body>
</html>
```

**二、利用css的 position属性，把div2相对于div1的top、left都设置为50%，然后再用margin-top设置为div2的高度的负一半拉回来，用marg-left设置为宽度的负一半拉回来，css如下设置**

```html
<!DOCTYPE html>
<html>
    <head>
        <meta charset="UTF-8">
        <title>demo</title>
    </head>
    <body>
        <style type="text/css">
            .div1{  width: 100px; height: 100px; border: 1px solid #000000;} 
            .div2{ width:40px ; height: 40px; background-color: green;}
 
            .div11{
                position: relative;
            }
            .div22{
                position: absolute;top:50%;left: 50%;margin-top: -20px;margin-left: -20px;
            }
        </style>
 
        <div class="div1 div11">
            <div class="div2 div22">
 
            </div>
        </div>
 
    </body>
</html>
```

**三、用css的position属性，如下的html**

```html
<!DOCTYPE html>
<html>
    <head>
        <meta charset="UTF-8">
        <title>demo</title>
    </head>
    <body>
        <style type="text/css">
            .div1{  width: 100px; height: 100px; border: 1px solid #000000;} 
            .div2{ width:40px ; height: 40px; background-color: green;}
 
            .div11{
                position: relative;
            }
            .div22{
                position: absolute;margin:auto; top: 0;left: 0;right: 0;bottom: 0;
            }
        </style>
 
        <div class="div1 div11">
            <div class="div2 div22">
 
            </div>
        </div>
 
    </body>
</html>
```

**四、利用css3的新增属性table-cell, vertical-align:middle;**

```html

<!DOCTYPE html>
<html>
    <head>
        <meta charset="UTF-8">
        <title>demo</title>
    </head>
    <body>
        <style type="text/css">
            .div1{  width: 100px; height: 100px; border: 1px solid #000000;} 
            .div2{ width:40px ; height: 40px; background-color: green;}
 
            .div11{
                display: table-cell;vertical-align: middle;
            }
            .div22{
                margin: auto;
            }
        </style>
 
        <div class="div1 div11">
            <div class="div2 div22">
            </div>
        </div>
 
    </body>
</html>
```

**五**

```html
<!DOCTYPE html>
<html>
    <head>
        <meta charset="UTF-8">
        <title>demo</title>
    </head>
    <body>
        <style type="text/css">
            .div1{  width: 100px; height: 100px; border: 1px solid #000000;} 
            .div2{ width:40px ; background-color: green;}
 
            .div11{
                display: table-cell;vertical-align: middle;
            }
            .div22{
                margin: auto;
            }
        </style>
 
        <div class="div1 div11">
            <div class="div2 div22">
               div居中方法
            </div>
        </div>
 
    </body>
</html>
```

**六、利用flexbox布局 直接在父元素上使用flexbox的布局**

```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>demo</title>
    <style type="text/css">
        .div1 {
            width: 100px;
            height: 100px;
            border: 1px solid #000000;
        }
 
        .div2 {
            height: 40px;
            width: 40px;
            background-color: green;
        }
 
        .div11 {
            display: flex;
            /*!*flex-direction: column;*!可写可不写*/
            justify-content: center;
            align-items: center;
        }
 
    </style>
</head>
<body>
 
 
<div class="div1 div11">
    <div class="div2 div22">
 
    </div>
</div>
 
</body>
</html>
```

**七、利用transform的属性,注意子绝父相定位**

缺点：需要支持Html5

```html

<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>demo</title>
    <style type="text/css">
        body {
            margin: 100px auto;
            position: relative;
        }
 
        .div1 {
            width: 100px;
            height: 100px;
            border: 1px solid #000000;
            background-color: red;
        }
 
        .div2 {
            height: 40px;
            width: 40px;
            background-color: green;
        }
 
        .center {
            position: absolute;
            top: 50%;
            left: 50%;
            -ms-transform: translate(-50%, -50%);
            -moz-transform: translate(-50%, -50%);
            -o-transform: translate(-50%, -50%);
            transform: translate(-50%, -50%);
        }
 
    </style>
</head>
<body>
 
 
<div class="div1 center">
    我是外部盒子
    <div class="div2 center">
        我要居中
    </div>
</div>
</body>
</html>
```

**八、两者都要固定定位,不常用**

缺点：需要设置 position 属性，网页复杂时容易扰乱页面布局,而且只是元素的起始位置居中

```html
<html>
<head>
    <meta charset="UTF-8">
    <title>demo</title>
    <style type="text/css">
 
 
        .div1 {
            width: 100px;
            height: 100px;
            border: 1px solid #000000;
            background-color: red;
            position: relative;
        }
 
        .div2 {
            height: 40px;
            width: 40px;
            background-color: green;
            margin:30px 30px;
 
        }
 
        .center{
            position: fixed;
            left: 50%;
        }
 
    </style>
</head>
<body>
 
 
<div class="div1 center">
   
    <div class="div2 center">
        我要居中
    </div>
</div>
</body>
</html>
```

## JavaScript 和 TypeScript 的对比

### 概要介绍

#### <font color="#ffe090">JavaScript</font>

JavaScript是一种基于客户端浏览器的，基于对象、事件驱动式的脚本语言。稍提一下，`JavaScript`和`Java`没有任何关系，两者相当于雷峰塔和雷锋的关系。

><font color="#1E90FF">1. JavaScript 是一种脚本编写语言，无需编译，只要嵌入 HTML 代码中，就能在浏览器中加载执行。</font>
><font color="#1E90FF">2. JavaScript 是一种基于对象的语言，可以创建对象同时使用现有对象。但是JavaScript并不支持面向对象语言所承载的继承和重载功能。</font>
><font color="#1E90FF">3. JavaScript 使用的变量是弱类型。</font>
><font color="#1E90FF">4. JavaScript 语言较为安全，仅在浏览器端执行，不会访问本地硬盘数据。</font>
><font color="#1E90FF">5. JavaScript 语言具有动态性。JavaScript 是事件驱动的，只根据用户的操作做出相应的反应处理。</font>
><font color="#1E90FF">6. JavaScript 只依赖于浏览器，与操作系统的因素无关。因此 JavaScript 是一种跨平台的语言。</font>
><font color="#1E90FF">7. JavaScript 兼容性极好，能够与其他技术（如XML、REST API等）一起使用</font>

#### <font color="#ffe090">TypeScript</font>

<br/>`TypeScript`是`JavaScript`类型的超类，它可以编译成纯JavaScript。`TypeScript`可以在任何浏览器、任何计算机和任何操作系统上运行，并且是开源的。

><font color="#1E90FF">1. TypeScript 是 Microsoft 推出的开源语言，使用 Apache 授权协议</font>
><font color="#1E90FF">2. TypeScript 增加了静态类型、类、模块、接口和类型注解</font>
><font color="#1E90FF">3. TypeScript 可用于开发大型的应用</font>
><font color="#1E90FF">4. TypeScript 易学易于理解</font>

#### <font color="#ffe090">JavaScript 和 TypeScript 的主要差异</font>

TypeScript 可以使用 JavaScript 中的所有代码和编程概念，`TypeScript`是为了使`JavaScript`的开发变得更加容易而创建的。

><font color="#1E90FF">1. TypeScript 从核心语言方面和类概念方面的模塑方面对 JavaScript 对象模型进行扩展。</font>
><font color="#1E90FF">2. JavaScript 代码可以在无需任何修改的情况下与 TypeScript 一同工作，同时可以使用编译器将TypeScript代码转换为JavaScript。</font>
><font color="#1E90FF">3. TypeScript 通过类型注解提供编译时的静态类型检查。</font>
><font color="#1E90FF">4. TypeScript 中的数据要求带有明确的类型，JavaScript不要求。</font>
><font color="#1E90FF">5. TypeScript 提供了缺省参数值。</font>
><font color="#1E90FF">6. TypeScript 引入了 JavaScript 中没有的“类”概念。</font>
><font color="#1E90FF">7. TypeScript 中引入模块的概念，可以把声明、数据、函数和类封装在模块中。</font>

#### <font color="#ffe090">TypeScript 的优势</font>

><font color="#1E90FF">1. 静态类型化，允许开发人员编写更健壮的代码并对其进行维护。</font>
><font color="#1E90FF">2. 大型的开发项目，使用 TypeScript 工具来进行重构更容易、便捷。</font>
><font color="#1E90FF">3. 类型安全，在编码期间检测错误的功能，而不是在编译项目时检测错误。</font>
><font color="#1E90FF">4. 干净的 ECMAScript6 代码，自动完成和动态输入等因素有助于提高开发人员的工作效率。</font>

#### <font color="#ffe090">JavaScript 的优势</font>

><font color="#1E90FF">1. JavaScript 的开发者社区仍然巨大而活跃，在社区可以很容易找到大量成熟的开发项目和可用资源。</font>
><font color="#1E90FF">2. JavaScript 语言发展较早，也较为成熟。</font>
><font color="#1E90FF">3. TypeScript 代码需要被编译（成 JavaScript）</font>
><font color="#1E90FF">4. 不需要注释</font>
><font color="#1E90FF">5. JavaScript 的灵活性更高</font>

## js实现图片懒加载原理

有时候一个网页会包含很多的图片，例如淘宝京东这些购物网站，商品图片多只之又多，页面图片多，加载的图片就多。服务器压力就会很大。不仅影响渲染速度还会浪费带宽。比如一个1M大小的图片，并发情况下，达到1000并发，即同时有1000个人访问，就会产生1个G的带宽。

为了解决以上问题，提高用户体验，就出现了懒加载方式来减轻服务器的压力，优先加载可视区域的内容，其他部分等进入了可视区域再加载，从而提高性能。

vue项目中的打包，是把html、css、js进行打包，还有图片压缩。但是打包时把css和js都分成了几部分，这样就不至于一个css和就是文件非常大。也是优化性能的一种方式。
效果动图如下：

![懒加载1](https://zhanglong292383147.gitee.io/picture_images/picture/Mianjingxuan/懒加载1.gif)

进入正题       懒加载

1.懒加载原理
一张图片就是一个`<img>`标签，浏览器是否发起请求图片是根据`<img>`的 src 属性，所以实现懒加载的关键就是，在图片没有进入可视区域时，先不给`<img>`的 src 赋值，这样浏览器就不会发送请求了，等到图片进入可视区域再给src赋值。

2.懒加载思路及实现
实现懒加载有四个步骤，如下：
1.加载loading图片
2.判断哪些图片要加载【重点】
3.隐形加载图片
4.替换真图片

1.加载 loading 图片是在 html 部分就实现的，代码如下：

![懒加载2](https://zhanglong292383147.gitee.io/picture_images/picture/Mianjingxuan/懒加载2.png)

2.如何判断图片进入可视区域是关键。
引用网友的一张图，可以很清楚的看出可视区域。

![懒加载3](https://zhanglong292383147.gitee.io/picture_images/picture/Mianjingxuan/懒加载3.png)

如上图所示，让在浏览器可视区域的图片显示，可视区域外的不显示，所以当图片距离顶部的距离top-height等于可视区域h和滚动区域高度s之和时说明图片马上就要进入可视区了，就是说当top-height<=s+h时，图片在可视区。
这里介绍下几个API函数：
页可见区域宽： `document`.body.clientWidth;
网页可见区域高： `document`.body.clientHeight;
网页可见区域宽： `document`.body.offsetWidth (包括边线的宽);
网页可见区域高： `document`.body.offsetHeight (包括边线的宽);
网页正文全文宽： `document`.body.scrollWidth;
网页正文全文高： `document`.body.scrollHeight;
网页被卷去的高： `document`.body.scrollTop;
网页被卷去的左： `document`.body.scrollLeft;
网页正文部分上： `window`.screenTop;
网页正文部分左： `window`.screenLeft;
屏幕分辨率的高： `window`.screen.height;
屏幕分辨率的宽： `window`.screen.width;
屏幕可用工作区高度： `window`.screen.availHeight;

HTMLElement.offsetTop 为只读属性，它返回当前元素相对于其 offsetParent 元素的顶部的距离。
`window`.innerHeight：浏览器窗口的视口（viewport）高度（以像素为单位）；如果有水平滚动条，也包括滚动条高度。

具体实现的js代码为：

```js
// onload是等所有的资源文件加载完毕以后再绑定事件
window.onload = function(){
	// 获取图片列表，即img标签列表
	var imgs = document.querySelectorAll('img');

	// 获取到浏览器顶部的距离
	function getTop(e){
		return e.offsetTop;
	}

	// 懒加载实现
	function lazyload(imgs){
		// 可视区域高度
		var h = window.innerHeight;
		//滚动区域高度
		var s = document.documentElement.scrollTop || document.body.scrollTop;
		for(var i=0;i<imgs.length;i++){
			//图片距离顶部的距离大于可视区域和滚动区域之和时懒加载
			if ((h+s)>getTop(imgs[i])) {
				// 真实情况是页面开始有2秒空白，所以使用setTimeout定时2s
				(function(i){
					setTimeout(function(){
						// 不加立即执行函数i会等于9
						// 隐形加载图片或其他资源，
						//创建一个临时图片，这个图片在内存中不会到页面上去。实现隐形加载
						var temp = new Image();
						temp.src = imgs[i].getAttribute('data-src');//只会请求一次
						// onload判断图片加载完毕，真是图片加载完毕，再赋值给dom节点
						temp.onload = function(){
							// 获取自定义属性data-src，用真图片替换假图片
							imgs[i].src = imgs[i].getAttribute('data-src')
						}
					},2000)
				})(i)
			}
		}
	}
	lazyload(imgs);

	// 滚屏函数
	window.onscroll =function(){
		lazyload(imgs);
	}
}
```

效果如下：

![懒加载4](https://zhanglong292383147.gitee.io/picture_images/picture/Mianjingxuan/懒加载4.png)

随着鼠标向下滚动，其余图片也逐渐显示并发起请求。

![懒加载5](https://zhanglong292383147.gitee.io/picture_images/picture/Mianjingxuan/懒加载5.png)

效果动图如下：

![懒加载6](https://zhanglong292383147.gitee.io/picture_images/picture/Mianjingxuan/懒加载6.gif)

## window.onload 和 $(document).ready() 的区别

`window`.onload是在页面中包含图片在内的所有元素全部加载完成再执行；
是树加载完成之后执行，不包含图片，其他媒体文件；

因此(document).ready()快于 window.onload 执行；

##  async 与 defer 区别

异步(async) 脚本将在其加载完成后立即执行，而 延迟(defer) 脚本将等待 HTML 解析完成后，并按加载顺序执行。

## 谈谈你对对vuex的理解

当面试官问我们对 vuex 的理解的时候，我们不能只说 “vuex 是一个专为 vue.js 应用程序开发的状态管理模式”，尽量不要让面试官连续追问（总会问到自己不会的然后说你实力还差那么点来可以得降薪），应该从三个方面一次性去说清楚：

1.vuex 是什么？

Vuex 是一个专为 Vue.js 应用程序开发的**状态管理模式**。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。Vuex 也集成到 Vue 的官方调试工具 [devtools extension](https://github.com/vuejs/vue-devtools)，提供了诸如零配置的 time-travel 调试、状态快照导入导出等高级调试功能。

2.vuex 的核心概念；

- vuex 的属性；
- vuex 的数据传递流程；

3.为什么要用 vuex？

　　对于问题一，我们按官网的描述即可。vuex 是一个专为 vue.js 应用程序开发的状态管理模式（它采用集中式存贮管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化）。

　　对于问题二，vuex五大核心属性：state，getter，mutation，action，module

- state：存储数据，存储状态；在根实例中注册了store 后，用 `this.$store.state` 来访问；对应vue里面的data；存放数据方式为响应式，vue组件从store中读取数据，如数据发生变化，组件也会对应的更新。
- getter：可以认为是 store 的计算属性，它的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。
- mutation：更改 Vuex 的 store 中的状态的唯一方法是提交 mutation。
- action：包含任意异步操作，通过提交 mutation 间接更变状态。
- module：将 store 分割成模块，每个模块都具有state、mutation、action、getter、甚至是嵌套子模块。

对于 vuex 的数据传递流程，如下图所示：

![Vuex工作原理(多共享组件)](https://zhanglong292383147.gitee.io/picture_images/picture/Mianjingxuan/Vuex工作原理-多共享组件.jpg)

当组件进行数据修改的时候我们需要调用 `dispatch` 来触发 `actions` 里面的方法。`actions` 里面的每个方法中都会有一个 `commit` 方法，当方法执行的时候会通过 `commit` 来触发 `mutations` 里面的方法进行数据的修改。`mutations` 里面的每个函数都会有一个 `state` 参数，这样就可以在 `mutations` 里面进行 `state` 的数据修改，当数据修改完毕后，会传导给页面。页面的数据也会发生改变。

　　对于问题三，由于传参的方法对于多层嵌套的组件将会非常繁琐，并且对于兄弟组件间的状态传递无能为力。我们经常会采用父子组件直接引用或者通过事件来变更和同步状态的多份拷贝。以上的这些模式非常脆弱，通常会导致代码无法维护。所以我们需要把组件的共享状态抽取出来，以一个全局单例模式管理。在这种模式下，我们的组件树构成了一个巨大的“视图”，不管在树的哪个位置，任何组件都能获取状态或者触发行为！另外，通过定义和隔离状态管理中的各种概念并强制遵守一定的规则，我们的代码将会变得更结构化且易维护。



## vuex的 state、getter、mutation、action、module 特性分别是什么？



**vuex 的几个核心概念Store：Vuex 使用一个 Store 对象管理应用的状态，一个 Store 包括 State, Getter, Mutation, Action 四个属性。**
**State：State 意为“状态”，是 vuex 状态管理的数据源。相当于存放变量的容器**
**Getter：Getter 的作用与 filters 有一些相似，可以将 State 进行过滤后输出。**
**Mutation：Mutaion 是 vuex 中改变 State 的唯一途径（严格模式下），并且只能是同步操作。Mutaion 使得状态变得可追踪，配合一些 devtools 可以实现 time-travel 的调试体验。**
**Action：一些对 State 的异步操作可以放在 Action 中，并通过在 Action 提交 Mutaion 变更状态。**
**Module：当 Store 对象过于庞大时，可根据具体的业务需求分为多个 Module。**

## vuex中 actions 和 mutations 有什么区别？

**action 提交的是 mutation，而不是直接变更状态。mutation可以直接变更状态。**

**action 可以包含任意异步操作。mutation只能是同步操作。**



```
提交方式不同，action 是用this.$store.dispatch('ACTION_NAME',data)来提交。

mutation是用this.$store.commit('SET_NUMBER',10)来提交。

```



**接收参数不同，mutation第一个参数是state，而action第一个参数是context，**

## vuex 使用 actions 时不支持多参数传递怎么办？

  **在使用vue components dispatch Vuex actions的时候需要传递参数给多个参数actions** 
  **但是在actions 只是可以接收到两个参数的问题**

  **调用的时候 第二个参数传递成多个元素的对象这样在actions 中第二个参数就可以搞定了** 

```js
  this.$store.dispatch('delTask', {task, index}); 
```



## 请求数据是写在组件的methods中还是在vuex的action中？

**如果项目中使用vuex的话，建议存入vuex中，**

**因为actions可以执行异步操作。**

**简单的页面放在methods里面即可。比较复杂，或者重要建议放在vuex中，容易维护，代码清晰,并且调用简单，这个在项目后期很重要。**

## 怎么监听 vuex 数据的变化？

```js
//利用计算属性
computed: {listData() {
	return this.$store.state.listData;
	}
},
//监听执行
watch: {
	listData(val) {
        /* 写上你需要的东西 */
}},

```

## 页面刷新后 vuex 的 state 数据丢失怎么解决？

**一种是  state 里的数据全部是通过请求来触发 action 或 mutation 来改变(基本不可行，除非项目很小或者vuex存储的数据很少)**

**另一种是将 state 里的数据保存一份到本地存储( localStorage、sessionStorage、cookie）中**

**而第二种可以保证刷新页面数据不丢失且易于读取。**

 **//在页面加载时读取 sessionStorage 里的状态信息**

**//在页面刷新时将 vuex 里的信息保存到 sessionStorage 里**

## 你有使用过 vuex 的 module 吗？主要是在什么场景下使用？

**我们使用vuex 需要实例化一个 Vuex 的 Store 构造函数。  modules 中则是我们自定义注册的 module. 每个 module 中都有自己独立的 state, action, mutation, getter...。通过它来区分更新/调用 对应的 vuex 方法来隔离未知数据更新等数据相关问题。**



## Promise内部实现的原理？

# 第一明确Promise是干什么用的

promise用来实现一步操作，解决了回调地狱的问题
 所谓的promise简单来说就是一个容器，里面保存着某些未来才结束的事件（通常是一个异步操作）的结果。
 从语法上来讲，Promise是一个对象，从它可以获取一步操作的消息。Promise对象的状态不受外部影响。
 promise上面的方法

```js
Promise.all()
Promise.race()
Promise.resolve()
Promise.reject()
Promise.prototype.catch()
Promise.prototype.finally()
Promise.prototype.then()
```

Promise.prototype.catch()方法是.then(null,rejection)的别名。用于指定发生错误时的回调函数

# 第二解析一下Promise的实现原理（源码）

```php
const PENDING = 'pending'; //初始状态
const FULFILLED = 'fulfilled'; // 成功状态
const REJECTED = 'rejected'; // 成功
function Promise(extutor){
  let self = this;
  self.status = PENDING; // 设置状态
  // 存放成功回调的数组
  self.onResolveCallbacks = [];
  // 存放失败回调的数组
  self.onRejectedCallbacks = [];
  function resolve(value){
    if(self.status === PENDING){
      self.status = FULFILLED;
      self.value = value;
      self.onResolveCallbacks.forEach(cb => cd(self.value))
    }
  } 
  function reject(reason){
    if(self.status === PENDING){
      self.status = REJECTED;
      self.value = reason;
      self.onRejectCallbacks.forEach(cb => cd(self.value))
    }
  } 
  try{
    excutor(resolve, reject)
  } catch(e) {
    reject(e)
  }
}
```

`then`方法在调用then方法中传进去的时候是两个函数，分别对应的是`promise`中的一步方法成功和失败的回调

```jsx
Promise.prototype.then = function(onFulfilled, onRejected){
  // 如果成功和失败的回调没有传，表示这个then没有任何逻辑，只负责把值往后抛
  onFulfilled = typeof onFulfilled == 'function' ? onFulfilled : value => value
  onRejected = typeof onRejected == 'function' ? onRejected : reason => { throw reason }
  let self = this;
  let promise2;
  // 实现链式调用，每一种状态都要返回的是一个promise实例
  if(self.status == FULFILLED){ // 如果promise状态已经是成功态，onFulfilled直接取值
    return  promise2 = new Promise(function(resolve, reject){
      setTimeout(function(){  // 保证返回的promise是异步
        try{
          onFulfilled(self.value)
        } catch (e){
          //  如果执行成功的回调过程中出错，用错误原因把promise2 reject
          reject(e)
        }
      })
    })
  }
  if( self.status == REJECTED){
    return promise2 = new Promise(function(){
      setTimeout(function(){
        try{
          onFulfilled(self.value)
        } catch (e){
          reject(e)
        }
      })
    })
  }
  if(self.status === PENDING){
    return promise2 = new Promise(function(resolve, reject){
      // pending 状态时就会把所有的回调函数都添加到实例中的两个堆栈中暂存，等状态改变后依次执行，其实这个过程就是观察者模式
      self.onResolveCallbacks.push(function(){
        setTimeOut(function(){
          try{
            onFulfilled(self.value)
          } catch(e){
            reject(e)
          }
        })
      })
    })
    self.onRejectCallbacks.push(){
      setTimeOut(function(){
        try{
          onRejected(self.value)
        } catch(e){
          reject(e)
        }
      })
    }
  }
}
```

**// 写到这，我也知识理解的一部分**

以上只是支持一次 `then` 的调用，现实中我们会有这种需求

```jsx
const p = new Promise(function(resolve, reject){
  if(/*异步操作的成功*/){
    resolve(value)
  } else {
    reject(error)
  }
});
p.then(function(){
}).then(function(){
}).then(function(){
}).catch(function(e){
  // failure
})
```

这种连续的调用返回 `promise` 实例的情况，而且我们要兼容 `then` 方法里返回的不是 `promise` 对象，这要求对 `then` 优化，加入一个解析`promise` 的方法 `resolvePromise`
 三种情况：

- 返回值是 `promise` 实例
- 返回值是一个 `thenable` 对象或者函数
- 没有返回值或者只返回一个普通值

```js
const thenable = {
  // 具有then属性，而且属性值是如下格式的函数的对象  
  then
}
```



## H5  页面窗口如何自动调整到设备宽度，并禁止用户缩放页面？

```html
<!--- 在页面头部加入meta标签 -->
<meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no" />
```

## vue-router 有哪几种导航钩子？

### 第一种：全局导航钩子

前置守卫

```js
//单独设置每个路由的属性：
meta: { may: true }
router.beforeEach((to, from, next) => {
    if (to.matched.some(item => item.meta.may)) {
        let id = window.localStorage.getItem("id")
        if (id) {
            next()
        } else {
            next({ name: "login" })
        }
    } else {
        next()
    }
})
```



**注意：next 方法必须要调用，否则钩子函数无法 resolved**

后置钩子

```js
router.afterEach((to,from) => {
	if(to.meta && to.meta.title){
		document.title = to.meta.title
	}else{
		document.title = "666"
	}
})
```



### 第二种：单独路由独享钩子

```js
{
    path: '/home',
    name: 'home',
    component: Home,
    beforeEnter(to, from, next) {
        if (window.localStorage.getItem("id")) {
            next()
        } else {
            next({ name: "login" })
        }
    }
}
```



### 第三种：组件内的钩子

```js
beforeRouteEnter(to, from, next) {
    // do someting
    // 在渲染该组件的对应路由被 confirm 前调用
},
beforeRouteUpdate(to, from, next) {
    // do someting
    // 在当前路由改变，但是依然渲染该组件是调用
},
beforeRouteLeave(to, from ,next) {
    // do someting
    // 导航离开该组件的对应路由时被调用
}
```



### 全局解析守卫

`router.beforeResolve` 注册一个全局守卫，和 `router.beforeEach` 类似

