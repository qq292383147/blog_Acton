{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/alpha-dust/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"themes/alpha-dust/source/img/bg-pattern.png","path":"img/bg-pattern.png","modified":0,"renderable":1},{"_id":"themes/alpha-dust/source/js/main.js","path":"js/main.js","modified":0,"renderable":1}],"Cache":[{"_id":"themes/alpha-dust/.gitignore","hash":"a5a49e4d5dfb97857856eb6b0cdb2c93a387718f","modified":1548574202281},{"_id":"themes/alpha-dust/LICENSE","hash":"9603ca6555bd5f0710038003b8a503bd29ca67a1","modified":1548574202282},{"_id":"themes/alpha-dust/README.md","hash":"6ede5d6a0d7bdd4491b33a1df61f29fc8c813613","modified":1548574202284},{"_id":"themes/alpha-dust/_config.yml","hash":"d8e6300a10c02624d8d2a3e9fdf7b3b390b7b2e5","modified":1551195597862},{"_id":"source/_posts/2019年面试题(主要Vue).md","hash":"896e1ff606b53d73b8b296a9ef2d3ffed3794500","modified":1552140383916},{"_id":"source/_posts/My-Gallery.md","hash":"4edd2d79e6de95e117b83153c9e4811775b76d59","modified":1552148785305},{"_id":"source/_posts/hello-world.md","hash":"07ece7af02aafe17cf9c28c0a171f35c527d26c9","modified":1552149307048},{"_id":"source/tags/index.md","hash":"12506cc1c82c45b3fee1ef1ab07f42d8e44ccbdd","modified":1552148957048},{"_id":"source/categories/index.md","hash":"b63f2c775a585a4688513e6d456cb4a26ccd1cdd","modified":1552149044411},{"_id":"themes/alpha-dust/languages/de.yml","hash":"02a98ba2b93e30a00ae7979fbe90b767a27290f0","modified":1548574202287},{"_id":"themes/alpha-dust/languages/default.yml","hash":"f0e62ce15272b2c59c9ae7f7615a286c69bf7113","modified":1548574202288},{"_id":"themes/alpha-dust/languages/en.yml","hash":"fd9d378ba28e9f0cb18418ed3134c003693cf689","modified":1548574202289},{"_id":"themes/alpha-dust/languages/es.yml","hash":"fb089145368422ac47da9eb00fed05b15c904aa2","modified":1548574202290},{"_id":"themes/alpha-dust/languages/fr.yml","hash":"10e3529b8492d7a7601d5b35b44d8fc9e8ea8d1b","modified":1548574202291},{"_id":"themes/alpha-dust/languages/no.yml","hash":"5ce3a1043ff85cecf83f3b5b0cdad2df44fa0192","modified":1548574202292},{"_id":"themes/alpha-dust/languages/pl.yml","hash":"6dc5d1b2aa75ae4c527089a770f43bafb91d80f4","modified":1548574202294},{"_id":"themes/alpha-dust/languages/pt.yml","hash":"6a31d548092af8af9f25d859063b0589c23ce13a","modified":1548574202297},{"_id":"themes/alpha-dust/languages/ru.yml","hash":"2cfaf93704ea4ac3f374c69bab89ca31916faa33","modified":1548574202298},{"_id":"themes/alpha-dust/languages/zh-CN.yml","hash":"b6519558255c0210ba5282bf14e455060f8f1bc5","modified":1548597988130},{"_id":"themes/alpha-dust/languages/zh-TW.yml","hash":"45c84384a05fdb7e32a3e2d498ea180be7dccfa9","modified":1548574202301},{"_id":"themes/alpha-dust/layout/archive.ejs","hash":"30620dd5e4f24e9d624c235dd16396c5e130deef","modified":1548574202323},{"_id":"themes/alpha-dust/layout/index.ejs","hash":"0dcf6f1b66722ddadb7479f4edf20281d30a7879","modified":1548574202325},{"_id":"themes/alpha-dust/layout/layout.ejs","hash":"9d1ba5fb467ab4269cbc925b3f2122a29b821b8d","modified":1548574202328},{"_id":"themes/alpha-dust/layout/page.ejs","hash":"e165246bdc5c3731a559e982918dc40abacc1493","modified":1548574202330},{"_id":"themes/alpha-dust/layout/post.ejs","hash":"526ad08601b479e88805a9ffbbfbdcccd38e7ef7","modified":1548574202331},{"_id":"themes/alpha-dust/template/archive.html","hash":"6152dc2e093c1431cbe2fa6bc9cb54751c2a7f86","modified":1548574202360},{"_id":"themes/alpha-dust/template/index.html","hash":"674b2011f068af9bf464ac77aafccf6867fcd7c0","modified":1548669218068},{"_id":"themes/alpha-dust/template/post.html","hash":"daed2747ec15affef2fe1d5cc05432361a2ed6f9","modified":1548574202437},{"_id":"source/_posts/mianshi/面试题精选.md","hash":"5620d79b7543791c35fa7324e01071bb16ab0a69","modified":1552147881979},{"_id":"themes/alpha-dust/layout/_partial/after-footer.ejs","hash":"43ad85ba781c3c98354e9873fe8a49fe50f08bb4","modified":1548574202304},{"_id":"themes/alpha-dust/layout/_partial/article-archive.ejs","hash":"f9608407a583bff104acb07c03fd8108056798c7","modified":1548574202305},{"_id":"themes/alpha-dust/layout/_partial/article-long.ejs","hash":"9e489edaacdc6bc7c8e60a85365510d135b9aaa5","modified":1548574202307},{"_id":"themes/alpha-dust/layout/_partial/article-short.ejs","hash":"68d4a8f97e20221a67d0e6700707e2f74cb1574b","modified":1548574202309},{"_id":"themes/alpha-dust/layout/_partial/comments.ejs","hash":"b0bb9c59f517302348aafcb2b832513d53d59055","modified":1548574202311},{"_id":"themes/alpha-dust/layout/_partial/footer.ejs","hash":"01c5a3246614b9c145c370dc8de60e54f10ae19e","modified":1551193173662},{"_id":"themes/alpha-dust/layout/_partial/footer_categories.ejs","hash":"f85cb280ae965fdd1d92af8bc0ece6c4d826a449","modified":1548574202313},{"_id":"themes/alpha-dust/layout/_partial/footer_recent_posts.ejs","hash":"21dc348c9548e6be5fdfa17fbb2233b2f817d4d9","modified":1551196421075},{"_id":"themes/alpha-dust/layout/_partial/gallery.ejs","hash":"63c93ed2dc9c5d9eefeaa8130e9728848731fa64","modified":1548574202315},{"_id":"themes/alpha-dust/layout/_partial/google-analytics.ejs","hash":"b287b7f66a53b51c7cd872ad1b15dfd20fb3e35d","modified":1548574202316},{"_id":"themes/alpha-dust/layout/_partial/head.ejs","hash":"48c24d90856988495fc77a2ed4a7851730a1540c","modified":1548579418035},{"_id":"themes/alpha-dust/layout/_partial/header.ejs","hash":"eaa4ea0a4ed4236bd07e4fff8a630d694a9e9506","modified":1548611144032},{"_id":"themes/alpha-dust/layout/_partial/menu.ejs","hash":"760cdaf07f808c9e8637f58e412aea43c4021ec2","modified":1548574202320},{"_id":"themes/alpha-dust/layout/_partial/pagination.ejs","hash":"58982acc8dc2b83c6c2cdf64a2c4156e947254d0","modified":1548574202321},{"_id":"themes/alpha-dust/layout/_partial/tag-cat-item.ejs","hash":"9e0ba720e7170b50ed74be55e56333524b009698","modified":1548574202322},{"_id":"themes/alpha-dust/source/css/style.styl","hash":"872f8eb9bd682a5bea66dc119ce2b366b0bba667","modified":1548574202351},{"_id":"themes/alpha-dust/source/img/bg-pattern.png","hash":"932374ff0b431bf83d092948e1714d90254dd92e","modified":1548574202353},{"_id":"themes/alpha-dust/source/js/main.js","hash":"e644dd5c0742f209072c48499c1beba20bc1e496","modified":1548574202357},{"_id":"themes/alpha-dust/template/css/font-awesome.min.css","hash":"3c1d63dd1176c77f9f4cdb1616fbb08c31b9822f","modified":1548574202365},{"_id":"themes/alpha-dust/template/css/style.css","hash":"08eaf9a51bb69ca580bebf8c610ea606631e9e07","modified":1551103524257},{"_id":"themes/alpha-dust/template/css/style.styl","hash":"524e67404a6d4b771255f703c0de6e148cd12163","modified":1551105613261},{"_id":"themes/alpha-dust/template/img/bg-pattern copy.png","hash":"932374ff0b431bf83d092948e1714d90254dd92e","modified":1548574202413},{"_id":"themes/alpha-dust/template/img/bg-pattern-blue.png","hash":"07016986a35c5bfc04c1599829d6a4798c966731","modified":1548574202415},{"_id":"themes/alpha-dust/template/img/bg-pattern.png","hash":"932374ff0b431bf83d092948e1714d90254dd92e","modified":1548574202421},{"_id":"themes/alpha-dust/template/img/hex-bg.png","hash":"a8444a553dd0fd7db09eda830bd3346cc87fc60e","modified":1548574202424},{"_id":"themes/alpha-dust/template/js/main.js","hash":"ed46e32f0bf6f4502a6558f9ad03843031dc318d","modified":1548574202434},{"_id":"themes/alpha-dust/template/css/font-awesome.css","hash":"a02674d823c7b577d38c3cdb91953993b6e4b3a0","modified":1548574202363},{"_id":"themes/alpha-dust/template/fonts/FontAwesome.otf","hash":"1b22f17fdc38070de50e6d1ab3a32da71aa2d819","modified":1548574202375},{"_id":"themes/alpha-dust/template/fonts/fontawesome-webfont.eot","hash":"965ce8f688fedbeed504efd498bc9c1622d12362","modified":1548574202380},{"_id":"themes/alpha-dust/template/fonts/fontawesome-webfont.woff","hash":"6d7e6a5fc802b13694d8820fc0138037c0977d2e","modified":1548574202399},{"_id":"themes/alpha-dust/template/fonts/fontawesome-webfont.woff2","hash":"97e438cc545714309882fbceadbf344fcaddcec5","modified":1548574202406},{"_id":"themes/alpha-dust/template/img/session_image.jpeg","hash":"5a3669c0564044f56cb7cea464119a8e388fb18f","modified":1548574202428},{"_id":"themes/alpha-dust/source/css/_partial/archive.styl","hash":"e51d15046b9e10d4342b67bb83fd3a0c42f5d60e","modified":1548574202334},{"_id":"themes/alpha-dust/source/css/_partial/base.styl","hash":"00300febf434b78ad93087e83481d2bf9d2c54a5","modified":1548574202335},{"_id":"themes/alpha-dust/source/css/_partial/code.styl","hash":"6c0788e0616a366234157abd18cb6a11b4dc8bfc","modified":1548684364639},{"_id":"themes/alpha-dust/source/css/_partial/footer.styl","hash":"a741adad7f208787c5d863a443da9a3438a01331","modified":1548574202338},{"_id":"themes/alpha-dust/source/css/_partial/header.styl","hash":"fe67b07e0325e98e8f6e904d365d7ef2963599f3","modified":1551105903795},{"_id":"themes/alpha-dust/source/css/_partial/menu.styl","hash":"7419c10bf98d059fa0263427c68e009cc0d4c4fa","modified":1548574202343},{"_id":"themes/alpha-dust/source/css/_partial/pagination.styl","hash":"7dfcf43dd05063115f7ebf9e63219a102b35a3ba","modified":1548574202345},{"_id":"themes/alpha-dust/source/css/_partial/post-content.styl","hash":"c3f0ae13c8a953e957da23db6ef7dab2b8217352","modified":1548574202347},{"_id":"themes/alpha-dust/source/css/_partial/post-layout.styl","hash":"bc8376e97266f047457117a965321efdd58e68a3","modified":1548574202348},{"_id":"themes/alpha-dust/source/css/_partial/variables.styl","hash":"f1dbc90648d67e03ba3b311c967977aa50888b38","modified":1548574202349},{"_id":"themes/alpha-dust/template/fonts/fontawesome-webfont.ttf","hash":"61d8d967807ef12598d81582fa95b9f600c3ee01","modified":1548574202397},{"_id":"themes/alpha-dust/template/fonts/fontawesome-webfont.svg","hash":"964e8dac2cee79c4b49b5bc300675773f6518812","modified":1548574202388},{"_id":"public/tags/index.html","hash":"f9a894ba54bfdaa977f22feba4bd246326b45802","modified":1552156944624},{"_id":"public/categories/index.html","hash":"ac9e3f282c2016a0e9100514e9310f2ae5ec2c09","modified":1552156944624},{"_id":"public/2019/03/10/My-Gallery/index.html","hash":"460638a199c5a5d896a67f852eefdaa88a3e70cf","modified":1552149209482},{"_id":"public/2019/01/27/hello-world/index.html","hash":"97f7170db06833ae22710320d36b96f98ec16cf1","modified":1552156944639},{"_id":"public/archives/index.html","hash":"1d86ebfd7b62b49b7f4fe2354c75a327f71472c2","modified":1552156944639},{"_id":"public/archives/2019/index.html","hash":"7b07f4b9682351cfcd226fb21b8532c34f0422c1","modified":1552156944639},{"_id":"public/archives/2019/01/index.html","hash":"b7ae60ad960cde75f9872c27a8f2cf306590113a","modified":1552156944639},{"_id":"public/archives/2019/02/index.html","hash":"1d77c8e855576e29443919c2f6bda243f8db8fe0","modified":1552156944640},{"_id":"public/archives/2019/03/index.html","hash":"6dda845d26b881f6e9a76253157ccd0e5bcedd5f","modified":1552156944640},{"_id":"public/tags/tags/index.html","hash":"a9588a1e7bee02263128fb7b20899629f8e0d174","modified":1552149209483},{"_id":"public/2019/02/25/2019年面试题(主要Vue)/index.html","hash":"5304fdaac8920f6411b7aa441b4c4f47c7bca5ce","modified":1552156944641},{"_id":"public/2019/02/25/mianshi/面试题精选/index.html","hash":"e2b4d885eed57d279236ca39de7744f618c48cb3","modified":1552156944641},{"_id":"public/index.html","hash":"6353e167838e6b9620b3a27ce7288cf372f5d16f","modified":1552156944641},{"_id":"public/img/bg-pattern.png","hash":"932374ff0b431bf83d092948e1714d90254dd92e","modified":1552149209487},{"_id":"public/js/main.js","hash":"7ee829ab42cf4d81280d20b5d664759436b19075","modified":1552149209827},{"_id":"public/css/style.css","hash":"2f2911c51fe7ee902185daccec8fd5ed82ec9cbe","modified":1552149209827},{"_id":"source/flex布局教程/index.md","hash":"9246bfab5308a12de9edbb64865c1e994667d6ee","modified":1552156569679},{"_id":"source/flex/index.md","hash":"2886d9b7fda07cbc210c2b4893166c5a14bb8c32","modified":1552156928724},{"_id":"source/_posts/flex布局教程.md","hash":"e49dd3128aa930ffe77bdd9ecd0732e18470213d","modified":1552156933070},{"_id":"public/flex/index.html","hash":"6b52aa57edf7248ef40ab55b86005967a6409a8f","modified":1552156944638},{"_id":"public/2019/03/10/flex布局教程/index.html","hash":"e60e0a9952bb24d55aa318af0999d537b3123732","modified":1552156944640},{"_id":"public/tags/flex/index.html","hash":"408931e92ee3912a826af37429e465f3a248e925","modified":1552156944643}],"Category":[],"Data":[],"Page":[{"title":"标签","date":"2019-03-09T13:51:55.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: 标签\ndate: 2019-03-09 21:51:55\ntype: \"tags\"\n---","updated":"2019-03-09T16:29:17.048Z","path":"tags/index.html","comments":1,"layout":"page","_id":"cjt1pka6g00019gnpdhfzhf3p","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"分类","date":"2019-03-09T13:33:12.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: 分类\ndate: 2019-03-09 21:33:12\ntype: \"categories\"\n---","updated":"2019-03-09T16:30:44.411Z","path":"categories/index.html","comments":1,"layout":"page","_id":"cjt1pka6l00039gnpj8ahjgs0","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"flex布局教程","date":"2019-03-09T18:00:33.000Z","type":"flex","_content":"","source":"flex/index.md","raw":"---\ntitle: flex布局教程\ndate: 2019-03-10 02:00:33\ntype: flex\n---","updated":"2019-03-09T18:42:08.724Z","path":"flex/index.html","_id":"cjt1u52230000u0npb5g6ffrx","comments":1,"layout":"page","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"您好，博客","_content":"欢迎来到Acton的个人技术博客！\n[博客地址:  ](https://zhanglong292383147.gitee.io/)https://zhanglong292383147.gitee.io/\n这是你的第一篇文章。查看文档以获得更多信息。","source":"_posts/hello-world.md","raw":"---\ntitle: 您好，博客\n---\n欢迎来到Acton的个人技术博客！\n[博客地址:  ](https://zhanglong292383147.gitee.io/)https://zhanglong292383147.gitee.io/\n这是你的第一篇文章。查看文档以获得更多信息。","slug":"hello-world","published":1,"date":"2019-01-27T07:19:59.956Z","updated":"2019-03-09T16:35:07.048Z","_id":"cjt1pka6j00029gnpbzdi5vyp","comments":1,"layout":"post","photos":[],"link":"","content":"<p>欢迎来到Acton的个人技术博客！<br><a href=\"https://zhanglong292383147.gitee.io/\" target=\"_blank\" rel=\"noopener\">博客地址:  </a><a href=\"https://zhanglong292383147.gitee.io/\" target=\"_blank\" rel=\"noopener\">https://zhanglong292383147.gitee.io/</a><br>这是你的第一篇文章。查看文档以获得更多信息。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>欢迎来到Acton的个人技术博客！<br><a href=\"https://zhanglong292383147.gitee.io/\" target=\"_blank\" rel=\"noopener\">博客地址:  </a><a href=\"https://zhanglong292383147.gitee.io/\" target=\"_blank\" rel=\"noopener\">https://zhanglong292383147.gitee.io/</a><br>这是你的第一篇文章。查看文档以获得更多信息。</p>\n"},{"title":"2019年面试题（主要Vue）","type":"categories","_content":"\n### 1. 谈谈你对MVVM开发模式的理解\n\nMVVM分为Model、View、ViewModel三者。\n**Model** 代表数据模型，数据和业务逻辑都在Model层中定义；\n**View** 代表UI视图，负责数据的展示；\n**ViewModel** 负责监听 **Model** 中数据的改变并且控制视图的更新，处理用户交互操作；\n**Model** 和 **View** 并无直接关联，而是通过 **ViewModel** 来进行联系的，**Model** 和 **ViewModel** 之间有着双向数据绑定的联系。因此当 **Model** 中的数据改变时会触发 **View** 层的刷新，**View** 中由于用户交互操作而改变的数据也会在 **Model** 中同步。\n这种模式实现了 **Model** 和 **View** 的数据自动同步，因此开发者只需要专注对数据的维护操作即可，而不需要自己操作 **dom**。\n\n### 2. Vue 有哪些指令？\n\nv-html、v-show、v-if、v-for等等\n\n### 3. v-if 和 v-show 有什么区别？\n\nv-show 仅仅控制元素的显示方式，将 display 属性在 block 和 none 来回切换；而v-if会控制这个 DOM 节点的存在与否。当我们需要经常切换某个元素的显示/隐藏时，使用v-show会更加节省性能上的开销；当只需要一次显示或隐藏时，使用v-if更加合理。\n\n### 4. 简述Vue的响应式原理\n\n当一个Vue实例创建时，vue会遍历data选项的属性，用 **Object.defineProperty** 将它们转为 getter/setter并且在内部追踪相关依赖，在属性被访问和修改时通知变化。\n每个组件实例都有相应的 watcher 程序实例，它会在组件渲染的过程中把属性记录为依赖，之后当依赖项的 setter 被调用时，会通知 watcher 重新计算，从而致使它关联的组件得以更新。\n\n![](https://zhanglong292383147.gitee.io/picture_images/picture/Vue_2019/1.png)\n\n### 5. Vue中如何在组件内部实现一个双向数据绑定？\n\n假设有一个输入框组件，用户输入时，同步父组件页面中的数据\n具体思路：父组件通过 props 传值给子组件，子组件通过 $emit 来通知父组件修改相应的props值，具体实现如下：\n\n```vue\nimport Vue from 'vue'\n\nconst component = {\n  props: ['value'],\n  template: `\n    <div>\n      <input type=\"text\" @input=\"handleInput\" :value=\"value\">\n    </div>\n  `,\n  data () {\n    return {\n    }\n  },\n  methods: {\n    handleInput (e) {\n      this.$emit('input', e.target.value)\n    }\n  }\n}\n\nnew Vue({\n  components: {\n    CompOne: component\n  },\n  el: '#root',\n  template: `\n    <div>\n      <comp-one :value1=\"value\" @input=\"value = arguments[0]\"></comp-one>\n    </div>\n  `,\n  data () {\n    return {\n      value: '123'\n    }\n  }\n})\n```\n\n可以看到，当输入数据时，父子组件中的数据是同步改变的：\n\n![](https://zhanglong292383147.gitee.io/picture_images/picture/Vue_2019/2.png)\n\n![](https://zhanglong292383147.gitee.io/picture_images/picture/Vue_2019/3.png)\n\n我们在父组件中做了两件事，一是给子组件传入props，二是监听input事件并同步自己的value属性。那么这两步操作能否再精简一下呢？答案是可以的，你只需要修改父组件：\n\n```vue\ntemplate: `\n    <div>\n      <!--<comp-one :value1=\"value\" @input=\"value = arguments[0]\"></comp-one>-->\n      <comp-one v-model=\"value\"></comp-one>\n    </div>\n  `\n```\n\nv-model 实际上会帮我们完成上面的两步操作。\n\n### 6. Vue中如何监控某个属性值的变化？\n\n比如现在需要监控data中，**obj.a** 的变化。Vue中监控对象属性的变化你可以这样：\n\n```vue\nwatch: {\n      obj: {\n      handler (newValue, oldValue) {\n        console.log('obj changed')\n      },\n      deep: true\n    }\n  }\n```\n\ndeep属性表示深层遍历，但是这么写会监控obj的所有属性变化，并不是我们想要的效果，所以做点修改：\n\n```vue\nwatch: {\n   'obj.a': {\n      handler (newName, oldName) {\n        console.log('obj.a changed')\n      }\n   }\n  }\n```\n\n还有一种方法，可以通过computed 来实现，只需要：\n\n```\ncomputed: {\n    a1 () {\n      return this.obj.a\n    }\n}\n```\n\n利用计算属性的特性来实现，当依赖改变时，便会重新计算一个新值。\n\n### 7. Vue中给data中的对象属性添加一个新的属性时会发生什么，如何解决？\n\n示例：\n\n```vue\n<template>\n  <div>\n    <ul>\n      <li v-for=\"value in obj\" :key=\"value\">\n        {{value}}\n      </li>\n    </ul>\n    <button @click=\"addObjB\">添加obj.b</button>\n  </div>\n</template>\n<script>\nexport default {\n  data () {\n    return {\n      obj: {\n        a: 'obj.a'\n      }\n    }\n  },\n  methods: {\n    addObjB () {\n      this.obj.b = 'obj.b'\n      console.log(this.obj)\n    }\n  }\n}\n</script>\n<style></style>\n```\n\n点击button会发现，obj.b 已经成功添加，但是视图并**未刷新**：\n\n![](https://zhanglong292383147.gitee.io/picture_images/picture/Vue_2019/4.png)\n\n![](https://zhanglong292383147.gitee.io/picture_images/picture/Vue_2019/5.png)\n\n原因在于在Vue实例创建时，obj.b并未声明，因此就没有被Vue转换为响应式的属性，自然就不会触发视图的更新，这时就需要使用Vue的全局api $set()：\n\n```vue\naddObjB () {\n      // this.obj.b = 'obj.b'\n      this.$set(this.obj, 'b', 'obj.b')\n      console.log(this.obj)\n    }\n```\n\n**$set()方法**相当于手动的去把obj.b处理成一个响应式的属性，此时视图也会跟着改变了：\n\n![](https://zhanglong292383147.gitee.io/picture_images/picture/Vue_2019/6.png)\n\n### 8. delete和Vue.delete删除数组的区别\n\ndelete只是被删除的元素变成了 empty/undefined 其他的元素的键值还是不变。\nVue.delete直接删除了数组 改变了数组的键值。\n\n\n\n```vue\n    var a=[1,2,3,4]\n    var b=[1,2,3,4]\n    delete a[1]\n    console.log(a)\n    this.$delete(b,1)\n    console.log(b)\n```\n\n![](https://zhanglong292383147.gitee.io/picture_images/picture/Vue_2019/7.png)\n\n![](https://zhanglong292383147.gitee.io/picture_images/picture/Vue_2019/8.png)\n\n### 9.如何优化SPA应用的首屏加载速度慢的问题？\n\n- 将公用的JS库通过script标签外部引入，减小app.bundel的大小，让浏览器并行下载资源文件，提高下载速度；\n- 在配置 路由时，页面和组件使用懒加载的方式引入，进一步缩小 app.bundel 的体积，在调用某个组件时再加载对应的js文件；\n- 加一个首屏 loading 图，提升用户体验；\n\n### 10. 前端如何优化网站性能？\n\n1. 减少 HTTP 请求数量\n\n在浏览器与服务器进行通信时，主要是通过 HTTP 进行通信。浏览器与服务器需要经过三次握手，每次握手需要花费大量时间。而且不同浏览器对资源文件并发请求数量有限（[不同浏览器允许并发数](http://www.stevesouders.com/blog/2008/03/20/roundup-on-parallel-connections/)），一旦 HTTP 请求数量达到一定数量，资源请求就存在**等待状态**，这是很致命的，因此减少 HTTP 的请求数量可以很大程度上对网站性能进行优化。\n\n- CSS Sprites：国内俗称 CSS 精灵**（精灵图）**，这是将多张图片合并成一张图片达到减少 HTTP 请求的一种解决方案，可以通过 CSS background 属性来访问图片内容。这种方案同时还可以减少图片总字节数。\n\n- 合并 CSS 和 JS 文件：现在前端有很多工程化打包工具，如：grunt、gulp、webpack等。为了减少 HTTP 请求数量，可以通过这些工具再发布前将多个 CSS 或者 多个 JS 合并成一个文件。\n- 采用 lazyLoad：俗称**懒加载**，**可以控制网页上的内容在一开始无需加载，不需要发请求，等到用户操作真正需要的时候立即加载出内容。这样就控制了网页资源一次性请求数量**。\n\n1. 控制资源文件加载优先级\n\n浏览器在加载 HTML 内容时，是将 HTML 内容从上至下依次解析，解析到 link 或者 script 标签就会加载 href 或者 src 对应链接内容，为了第一时间展示页面给用户，就需要将 CSS 提前加载，不要受 JS 加载影响。\n一般情况下都是 CSS 在头部，JS 在底部。\n\n1. 利用浏览器缓存\n   浏览器缓存是将网络资源存储在本地，等待下次请求该资源时，如果资源已经存在就不需要到服务器重新请求该资源，直接在本地读取该资源。\n2. 减少重排（Reflow）\n   基本原理：重排是 DOM 的变化影响到了元素的几何属性（宽和高），浏览器会重新计算元素的几何属性，会使渲染树中受到影响的部分失效，浏览器会验证 DOM 树上的所有其它节点的 visibility 属性，这也是 Reflow 低效的原因。如果 Reflow 的过于频繁，CPU 使用率就会急剧上升。\n\n减少 Reflow，如果需要在 DOM 操作时添加样式，尽量使用 增加 class 属性，而不是通过 style 操作样式。\n\n1. 减少 DOM 操作\n2. 图标使用 IconFont 替换\n\n### 11. 网页从输入网址到渲染完成经历了哪些过程？\n\n大致可以分为如下7步：\n\n1. 输入网址；\n2. 发送到DNS服务器，并获取域名对应的web服务器对应的ip地址；\n3. 与web服务器建立TCP连接；\n4. 浏览器向web服务器发送http请求；\n5. web服务器响应请求，并返回指定url的数据（或错误信息，或重定向的新的url地址）；\n6. 浏览器下载web服务器返回的数据及解析html源文件；\n7. 生成DOM树，解析css和js，渲染页面，直至显示完成；\n\n### 12. jQuery获取的dom对象和原生的dom对象有何区别？\n\njs原生获取的dom是一个对象，jQuery对象就是一个数组对象，其实就是选择出来的元素的数组集合，所以说他们两者是不同的对象类型不等价。\n\n- 原生DOM对象转jQuery对象：\n\n```vue\nvar box = document.getElementById('box');\nvar $box = $(box);\n```\n\n- jQuery对象转原生DOM对象：\n\n```vue\nvar $box = $('#box');\nvar box = $box[0];\n```\n\n### 13. jQuery如何扩展自定义方法\n\n```vue\n(jQuery.fn.myMethod=function () {\n       alert('myMethod');\n})\n// 或者：\n(function ($) {\n        $.fn.extend({\n             myMethod : function () {\n                  alert('myMethod');\n             }\n        })\n})(jQuery)\n```\n\n使用：\n\n```vue\n$(\"#div\").myMethod();\n```","source":"_posts/2019年面试题(主要Vue).md","raw":"---\ntitle: 2019年面试题（主要Vue）\ntype: categories\n---\n\n### 1. 谈谈你对MVVM开发模式的理解\n\nMVVM分为Model、View、ViewModel三者。\n**Model** 代表数据模型，数据和业务逻辑都在Model层中定义；\n**View** 代表UI视图，负责数据的展示；\n**ViewModel** 负责监听 **Model** 中数据的改变并且控制视图的更新，处理用户交互操作；\n**Model** 和 **View** 并无直接关联，而是通过 **ViewModel** 来进行联系的，**Model** 和 **ViewModel** 之间有着双向数据绑定的联系。因此当 **Model** 中的数据改变时会触发 **View** 层的刷新，**View** 中由于用户交互操作而改变的数据也会在 **Model** 中同步。\n这种模式实现了 **Model** 和 **View** 的数据自动同步，因此开发者只需要专注对数据的维护操作即可，而不需要自己操作 **dom**。\n\n### 2. Vue 有哪些指令？\n\nv-html、v-show、v-if、v-for等等\n\n### 3. v-if 和 v-show 有什么区别？\n\nv-show 仅仅控制元素的显示方式，将 display 属性在 block 和 none 来回切换；而v-if会控制这个 DOM 节点的存在与否。当我们需要经常切换某个元素的显示/隐藏时，使用v-show会更加节省性能上的开销；当只需要一次显示或隐藏时，使用v-if更加合理。\n\n### 4. 简述Vue的响应式原理\n\n当一个Vue实例创建时，vue会遍历data选项的属性，用 **Object.defineProperty** 将它们转为 getter/setter并且在内部追踪相关依赖，在属性被访问和修改时通知变化。\n每个组件实例都有相应的 watcher 程序实例，它会在组件渲染的过程中把属性记录为依赖，之后当依赖项的 setter 被调用时，会通知 watcher 重新计算，从而致使它关联的组件得以更新。\n\n![](https://zhanglong292383147.gitee.io/picture_images/picture/Vue_2019/1.png)\n\n### 5. Vue中如何在组件内部实现一个双向数据绑定？\n\n假设有一个输入框组件，用户输入时，同步父组件页面中的数据\n具体思路：父组件通过 props 传值给子组件，子组件通过 $emit 来通知父组件修改相应的props值，具体实现如下：\n\n```vue\nimport Vue from 'vue'\n\nconst component = {\n  props: ['value'],\n  template: `\n    <div>\n      <input type=\"text\" @input=\"handleInput\" :value=\"value\">\n    </div>\n  `,\n  data () {\n    return {\n    }\n  },\n  methods: {\n    handleInput (e) {\n      this.$emit('input', e.target.value)\n    }\n  }\n}\n\nnew Vue({\n  components: {\n    CompOne: component\n  },\n  el: '#root',\n  template: `\n    <div>\n      <comp-one :value1=\"value\" @input=\"value = arguments[0]\"></comp-one>\n    </div>\n  `,\n  data () {\n    return {\n      value: '123'\n    }\n  }\n})\n```\n\n可以看到，当输入数据时，父子组件中的数据是同步改变的：\n\n![](https://zhanglong292383147.gitee.io/picture_images/picture/Vue_2019/2.png)\n\n![](https://zhanglong292383147.gitee.io/picture_images/picture/Vue_2019/3.png)\n\n我们在父组件中做了两件事，一是给子组件传入props，二是监听input事件并同步自己的value属性。那么这两步操作能否再精简一下呢？答案是可以的，你只需要修改父组件：\n\n```vue\ntemplate: `\n    <div>\n      <!--<comp-one :value1=\"value\" @input=\"value = arguments[0]\"></comp-one>-->\n      <comp-one v-model=\"value\"></comp-one>\n    </div>\n  `\n```\n\nv-model 实际上会帮我们完成上面的两步操作。\n\n### 6. Vue中如何监控某个属性值的变化？\n\n比如现在需要监控data中，**obj.a** 的变化。Vue中监控对象属性的变化你可以这样：\n\n```vue\nwatch: {\n      obj: {\n      handler (newValue, oldValue) {\n        console.log('obj changed')\n      },\n      deep: true\n    }\n  }\n```\n\ndeep属性表示深层遍历，但是这么写会监控obj的所有属性变化，并不是我们想要的效果，所以做点修改：\n\n```vue\nwatch: {\n   'obj.a': {\n      handler (newName, oldName) {\n        console.log('obj.a changed')\n      }\n   }\n  }\n```\n\n还有一种方法，可以通过computed 来实现，只需要：\n\n```\ncomputed: {\n    a1 () {\n      return this.obj.a\n    }\n}\n```\n\n利用计算属性的特性来实现，当依赖改变时，便会重新计算一个新值。\n\n### 7. Vue中给data中的对象属性添加一个新的属性时会发生什么，如何解决？\n\n示例：\n\n```vue\n<template>\n  <div>\n    <ul>\n      <li v-for=\"value in obj\" :key=\"value\">\n        {{value}}\n      </li>\n    </ul>\n    <button @click=\"addObjB\">添加obj.b</button>\n  </div>\n</template>\n<script>\nexport default {\n  data () {\n    return {\n      obj: {\n        a: 'obj.a'\n      }\n    }\n  },\n  methods: {\n    addObjB () {\n      this.obj.b = 'obj.b'\n      console.log(this.obj)\n    }\n  }\n}\n</script>\n<style></style>\n```\n\n点击button会发现，obj.b 已经成功添加，但是视图并**未刷新**：\n\n![](https://zhanglong292383147.gitee.io/picture_images/picture/Vue_2019/4.png)\n\n![](https://zhanglong292383147.gitee.io/picture_images/picture/Vue_2019/5.png)\n\n原因在于在Vue实例创建时，obj.b并未声明，因此就没有被Vue转换为响应式的属性，自然就不会触发视图的更新，这时就需要使用Vue的全局api $set()：\n\n```vue\naddObjB () {\n      // this.obj.b = 'obj.b'\n      this.$set(this.obj, 'b', 'obj.b')\n      console.log(this.obj)\n    }\n```\n\n**$set()方法**相当于手动的去把obj.b处理成一个响应式的属性，此时视图也会跟着改变了：\n\n![](https://zhanglong292383147.gitee.io/picture_images/picture/Vue_2019/6.png)\n\n### 8. delete和Vue.delete删除数组的区别\n\ndelete只是被删除的元素变成了 empty/undefined 其他的元素的键值还是不变。\nVue.delete直接删除了数组 改变了数组的键值。\n\n\n\n```vue\n    var a=[1,2,3,4]\n    var b=[1,2,3,4]\n    delete a[1]\n    console.log(a)\n    this.$delete(b,1)\n    console.log(b)\n```\n\n![](https://zhanglong292383147.gitee.io/picture_images/picture/Vue_2019/7.png)\n\n![](https://zhanglong292383147.gitee.io/picture_images/picture/Vue_2019/8.png)\n\n### 9.如何优化SPA应用的首屏加载速度慢的问题？\n\n- 将公用的JS库通过script标签外部引入，减小app.bundel的大小，让浏览器并行下载资源文件，提高下载速度；\n- 在配置 路由时，页面和组件使用懒加载的方式引入，进一步缩小 app.bundel 的体积，在调用某个组件时再加载对应的js文件；\n- 加一个首屏 loading 图，提升用户体验；\n\n### 10. 前端如何优化网站性能？\n\n1. 减少 HTTP 请求数量\n\n在浏览器与服务器进行通信时，主要是通过 HTTP 进行通信。浏览器与服务器需要经过三次握手，每次握手需要花费大量时间。而且不同浏览器对资源文件并发请求数量有限（[不同浏览器允许并发数](http://www.stevesouders.com/blog/2008/03/20/roundup-on-parallel-connections/)），一旦 HTTP 请求数量达到一定数量，资源请求就存在**等待状态**，这是很致命的，因此减少 HTTP 的请求数量可以很大程度上对网站性能进行优化。\n\n- CSS Sprites：国内俗称 CSS 精灵**（精灵图）**，这是将多张图片合并成一张图片达到减少 HTTP 请求的一种解决方案，可以通过 CSS background 属性来访问图片内容。这种方案同时还可以减少图片总字节数。\n\n- 合并 CSS 和 JS 文件：现在前端有很多工程化打包工具，如：grunt、gulp、webpack等。为了减少 HTTP 请求数量，可以通过这些工具再发布前将多个 CSS 或者 多个 JS 合并成一个文件。\n- 采用 lazyLoad：俗称**懒加载**，**可以控制网页上的内容在一开始无需加载，不需要发请求，等到用户操作真正需要的时候立即加载出内容。这样就控制了网页资源一次性请求数量**。\n\n1. 控制资源文件加载优先级\n\n浏览器在加载 HTML 内容时，是将 HTML 内容从上至下依次解析，解析到 link 或者 script 标签就会加载 href 或者 src 对应链接内容，为了第一时间展示页面给用户，就需要将 CSS 提前加载，不要受 JS 加载影响。\n一般情况下都是 CSS 在头部，JS 在底部。\n\n1. 利用浏览器缓存\n   浏览器缓存是将网络资源存储在本地，等待下次请求该资源时，如果资源已经存在就不需要到服务器重新请求该资源，直接在本地读取该资源。\n2. 减少重排（Reflow）\n   基本原理：重排是 DOM 的变化影响到了元素的几何属性（宽和高），浏览器会重新计算元素的几何属性，会使渲染树中受到影响的部分失效，浏览器会验证 DOM 树上的所有其它节点的 visibility 属性，这也是 Reflow 低效的原因。如果 Reflow 的过于频繁，CPU 使用率就会急剧上升。\n\n减少 Reflow，如果需要在 DOM 操作时添加样式，尽量使用 增加 class 属性，而不是通过 style 操作样式。\n\n1. 减少 DOM 操作\n2. 图标使用 IconFont 替换\n\n### 11. 网页从输入网址到渲染完成经历了哪些过程？\n\n大致可以分为如下7步：\n\n1. 输入网址；\n2. 发送到DNS服务器，并获取域名对应的web服务器对应的ip地址；\n3. 与web服务器建立TCP连接；\n4. 浏览器向web服务器发送http请求；\n5. web服务器响应请求，并返回指定url的数据（或错误信息，或重定向的新的url地址）；\n6. 浏览器下载web服务器返回的数据及解析html源文件；\n7. 生成DOM树，解析css和js，渲染页面，直至显示完成；\n\n### 12. jQuery获取的dom对象和原生的dom对象有何区别？\n\njs原生获取的dom是一个对象，jQuery对象就是一个数组对象，其实就是选择出来的元素的数组集合，所以说他们两者是不同的对象类型不等价。\n\n- 原生DOM对象转jQuery对象：\n\n```vue\nvar box = document.getElementById('box');\nvar $box = $(box);\n```\n\n- jQuery对象转原生DOM对象：\n\n```vue\nvar $box = $('#box');\nvar box = $box[0];\n```\n\n### 13. jQuery如何扩展自定义方法\n\n```vue\n(jQuery.fn.myMethod=function () {\n       alert('myMethod');\n})\n// 或者：\n(function ($) {\n        $.fn.extend({\n             myMethod : function () {\n                  alert('myMethod');\n             }\n        })\n})(jQuery)\n```\n\n使用：\n\n```vue\n$(\"#div\").myMethod();\n```","slug":"2019年面试题(主要Vue)","published":1,"date":"2019-02-25T04:45:29.939Z","updated":"2019-03-09T14:06:23.916Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt1pka6x00069gnpclgu1qae","content":"<h3 id=\"1-谈谈你对MVVM开发模式的理解\"><a href=\"#1-谈谈你对MVVM开发模式的理解\" class=\"headerlink\" title=\"1. 谈谈你对MVVM开发模式的理解\"></a>1. 谈谈你对MVVM开发模式的理解</h3><p>MVVM分为Model、View、ViewModel三者。<br><strong>Model</strong> 代表数据模型，数据和业务逻辑都在Model层中定义；<br><strong>View</strong> 代表UI视图，负责数据的展示；<br><strong>ViewModel</strong> 负责监听 <strong>Model</strong> 中数据的改变并且控制视图的更新，处理用户交互操作；<br><strong>Model</strong> 和 <strong>View</strong> 并无直接关联，而是通过 <strong>ViewModel</strong> 来进行联系的，<strong>Model</strong> 和 <strong>ViewModel</strong> 之间有着双向数据绑定的联系。因此当 <strong>Model</strong> 中的数据改变时会触发 <strong>View</strong> 层的刷新，<strong>View</strong> 中由于用户交互操作而改变的数据也会在 <strong>Model</strong> 中同步。<br>这种模式实现了 <strong>Model</strong> 和 <strong>View</strong> 的数据自动同步，因此开发者只需要专注对数据的维护操作即可，而不需要自己操作 <strong>dom</strong>。</p>\n<h3 id=\"2-Vue-有哪些指令？\"><a href=\"#2-Vue-有哪些指令？\" class=\"headerlink\" title=\"2. Vue 有哪些指令？\"></a>2. Vue 有哪些指令？</h3><p>v-html、v-show、v-if、v-for等等</p>\n<h3 id=\"3-v-if-和-v-show-有什么区别？\"><a href=\"#3-v-if-和-v-show-有什么区别？\" class=\"headerlink\" title=\"3. v-if 和 v-show 有什么区别？\"></a>3. v-if 和 v-show 有什么区别？</h3><p>v-show 仅仅控制元素的显示方式，将 display 属性在 block 和 none 来回切换；而v-if会控制这个 DOM 节点的存在与否。当我们需要经常切换某个元素的显示/隐藏时，使用v-show会更加节省性能上的开销；当只需要一次显示或隐藏时，使用v-if更加合理。</p>\n<h3 id=\"4-简述Vue的响应式原理\"><a href=\"#4-简述Vue的响应式原理\" class=\"headerlink\" title=\"4. 简述Vue的响应式原理\"></a>4. 简述Vue的响应式原理</h3><p>当一个Vue实例创建时，vue会遍历data选项的属性，用 <strong>Object.defineProperty</strong> 将它们转为 getter/setter并且在内部追踪相关依赖，在属性被访问和修改时通知变化。<br>每个组件实例都有相应的 watcher 程序实例，它会在组件渲染的过程中把属性记录为依赖，之后当依赖项的 setter 被调用时，会通知 watcher 重新计算，从而致使它关联的组件得以更新。</p>\n<p><img src=\"https://zhanglong292383147.gitee.io/picture_images/picture/Vue_2019/1.png\" alt=\"\"></p>\n<h3 id=\"5-Vue中如何在组件内部实现一个双向数据绑定？\"><a href=\"#5-Vue中如何在组件内部实现一个双向数据绑定？\" class=\"headerlink\" title=\"5. Vue中如何在组件内部实现一个双向数据绑定？\"></a>5. Vue中如何在组件内部实现一个双向数据绑定？</h3><p>假设有一个输入框组件，用户输入时，同步父组件页面中的数据<br>具体思路：父组件通过 props 传值给子组件，子组件通过 $emit 来通知父组件修改相应的props值，具体实现如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import Vue from &apos;vue&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">const component = &#123;</span><br><span class=\"line\">  props: [&apos;value&apos;],</span><br><span class=\"line\">  template: `</span><br><span class=\"line\">    &lt;div&gt;</span><br><span class=\"line\">      &lt;input type=&quot;text&quot; @input=&quot;handleInput&quot; :value=&quot;value&quot;&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">  `,</span><br><span class=\"line\">  data () &#123;</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  methods: &#123;</span><br><span class=\"line\">    handleInput (e) &#123;</span><br><span class=\"line\">      this.$emit(&apos;input&apos;, e.target.value)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">new Vue(&#123;</span><br><span class=\"line\">  components: &#123;</span><br><span class=\"line\">    CompOne: component</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  el: &apos;#root&apos;,</span><br><span class=\"line\">  template: `</span><br><span class=\"line\">    &lt;div&gt;</span><br><span class=\"line\">      &lt;comp-one :value1=&quot;value&quot; @input=&quot;value = arguments[0]&quot;&gt;&lt;/comp-one&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">  `,</span><br><span class=\"line\">  data () &#123;</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">      value: &apos;123&apos;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>可以看到，当输入数据时，父子组件中的数据是同步改变的：</p>\n<p><img src=\"https://zhanglong292383147.gitee.io/picture_images/picture/Vue_2019/2.png\" alt=\"\"></p>\n<p><img src=\"https://zhanglong292383147.gitee.io/picture_images/picture/Vue_2019/3.png\" alt=\"\"></p>\n<p>我们在父组件中做了两件事，一是给子组件传入props，二是监听input事件并同步自己的value属性。那么这两步操作能否再精简一下呢？答案是可以的，你只需要修改父组件：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template: `</span><br><span class=\"line\">    &lt;div&gt;</span><br><span class=\"line\">      &lt;!--&lt;comp-one :value1=&quot;value&quot; @input=&quot;value = arguments[0]&quot;&gt;&lt;/comp-one&gt;--&gt;</span><br><span class=\"line\">      &lt;comp-one v-model=&quot;value&quot;&gt;&lt;/comp-one&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">  `</span><br></pre></td></tr></table></figure>\n<p>v-model 实际上会帮我们完成上面的两步操作。</p>\n<h3 id=\"6-Vue中如何监控某个属性值的变化？\"><a href=\"#6-Vue中如何监控某个属性值的变化？\" class=\"headerlink\" title=\"6. Vue中如何监控某个属性值的变化？\"></a>6. Vue中如何监控某个属性值的变化？</h3><p>比如现在需要监控data中，<strong>obj.a</strong> 的变化。Vue中监控对象属性的变化你可以这样：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">watch: &#123;</span><br><span class=\"line\">      obj: &#123;</span><br><span class=\"line\">      handler (newValue, oldValue) &#123;</span><br><span class=\"line\">        console.log(&apos;obj changed&apos;)</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      deep: true</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>deep属性表示深层遍历，但是这么写会监控obj的所有属性变化，并不是我们想要的效果，所以做点修改：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">watch: &#123;</span><br><span class=\"line\">   &apos;obj.a&apos;: &#123;</span><br><span class=\"line\">      handler (newName, oldName) &#123;</span><br><span class=\"line\">        console.log(&apos;obj.a changed&apos;)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>还有一种方法，可以通过computed 来实现，只需要：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">computed: &#123;</span><br><span class=\"line\">    a1 () &#123;</span><br><span class=\"line\">      return this.obj.a</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>利用计算属性的特性来实现，当依赖改变时，便会重新计算一个新值。</p>\n<h3 id=\"7-Vue中给data中的对象属性添加一个新的属性时会发生什么，如何解决？\"><a href=\"#7-Vue中给data中的对象属性添加一个新的属性时会发生什么，如何解决？\" class=\"headerlink\" title=\"7. Vue中给data中的对象属性添加一个新的属性时会发生什么，如何解决？\"></a>7. Vue中给data中的对象属性添加一个新的属性时会发生什么，如何解决？</h3><p>示例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">  &lt;div&gt;</span><br><span class=\"line\">    &lt;ul&gt;</span><br><span class=\"line\">      &lt;li v-for=&quot;value in obj&quot; :key=&quot;value&quot;&gt;</span><br><span class=\"line\">        &#123;&#123;value&#125;&#125;</span><br><span class=\"line\">      &lt;/li&gt;</span><br><span class=\"line\">    &lt;/ul&gt;</span><br><span class=\"line\">    &lt;button @click=&quot;addObjB&quot;&gt;添加obj.b&lt;/button&gt;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">  data () &#123;</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">      obj: &#123;</span><br><span class=\"line\">        a: &apos;obj.a&apos;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  methods: &#123;</span><br><span class=\"line\">    addObjB () &#123;</span><br><span class=\"line\">      this.obj.b = &apos;obj.b&apos;</span><br><span class=\"line\">      console.log(this.obj)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br><span class=\"line\">&lt;style&gt;&lt;/style&gt;</span><br></pre></td></tr></table></figure>\n<p>点击button会发现，obj.b 已经成功添加，但是视图并<strong>未刷新</strong>：</p>\n<p><img src=\"https://zhanglong292383147.gitee.io/picture_images/picture/Vue_2019/4.png\" alt=\"\"></p>\n<p><img src=\"https://zhanglong292383147.gitee.io/picture_images/picture/Vue_2019/5.png\" alt=\"\"></p>\n<p>原因在于在Vue实例创建时，obj.b并未声明，因此就没有被Vue转换为响应式的属性，自然就不会触发视图的更新，这时就需要使用Vue的全局api $set()：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">addObjB () &#123;</span><br><span class=\"line\">      // this.obj.b = &apos;obj.b&apos;</span><br><span class=\"line\">      this.$set(this.obj, &apos;b&apos;, &apos;obj.b&apos;)</span><br><span class=\"line\">      console.log(this.obj)</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p><strong>$set()方法</strong>相当于手动的去把obj.b处理成一个响应式的属性，此时视图也会跟着改变了：</p>\n<p><img src=\"https://zhanglong292383147.gitee.io/picture_images/picture/Vue_2019/6.png\" alt=\"\"></p>\n<h3 id=\"8-delete和Vue-delete删除数组的区别\"><a href=\"#8-delete和Vue-delete删除数组的区别\" class=\"headerlink\" title=\"8. delete和Vue.delete删除数组的区别\"></a>8. delete和Vue.delete删除数组的区别</h3><p>delete只是被删除的元素变成了 empty/undefined 其他的元素的键值还是不变。<br>Vue.delete直接删除了数组 改变了数组的键值。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a=[1,2,3,4]</span><br><span class=\"line\">var b=[1,2,3,4]</span><br><span class=\"line\">delete a[1]</span><br><span class=\"line\">console.log(a)</span><br><span class=\"line\">this.$delete(b,1)</span><br><span class=\"line\">console.log(b)</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://zhanglong292383147.gitee.io/picture_images/picture/Vue_2019/7.png\" alt=\"\"></p>\n<p><img src=\"https://zhanglong292383147.gitee.io/picture_images/picture/Vue_2019/8.png\" alt=\"\"></p>\n<h3 id=\"9-如何优化SPA应用的首屏加载速度慢的问题？\"><a href=\"#9-如何优化SPA应用的首屏加载速度慢的问题？\" class=\"headerlink\" title=\"9.如何优化SPA应用的首屏加载速度慢的问题？\"></a>9.如何优化SPA应用的首屏加载速度慢的问题？</h3><ul>\n<li>将公用的JS库通过script标签外部引入，减小app.bundel的大小，让浏览器并行下载资源文件，提高下载速度；</li>\n<li>在配置 路由时，页面和组件使用懒加载的方式引入，进一步缩小 app.bundel 的体积，在调用某个组件时再加载对应的js文件；</li>\n<li>加一个首屏 loading 图，提升用户体验；</li>\n</ul>\n<h3 id=\"10-前端如何优化网站性能？\"><a href=\"#10-前端如何优化网站性能？\" class=\"headerlink\" title=\"10. 前端如何优化网站性能？\"></a>10. 前端如何优化网站性能？</h3><ol>\n<li>减少 HTTP 请求数量</li>\n</ol>\n<p>在浏览器与服务器进行通信时，主要是通过 HTTP 进行通信。浏览器与服务器需要经过三次握手，每次握手需要花费大量时间。而且不同浏览器对资源文件并发请求数量有限（<a href=\"http://www.stevesouders.com/blog/2008/03/20/roundup-on-parallel-connections/\" target=\"_blank\" rel=\"noopener\">不同浏览器允许并发数</a>），一旦 HTTP 请求数量达到一定数量，资源请求就存在<strong>等待状态</strong>，这是很致命的，因此减少 HTTP 的请求数量可以很大程度上对网站性能进行优化。</p>\n<ul>\n<li><p>CSS Sprites：国内俗称 CSS 精灵<strong>（精灵图）</strong>，这是将多张图片合并成一张图片达到减少 HTTP 请求的一种解决方案，可以通过 CSS background 属性来访问图片内容。这种方案同时还可以减少图片总字节数。</p>\n</li>\n<li><p>合并 CSS 和 JS 文件：现在前端有很多工程化打包工具，如：grunt、gulp、webpack等。为了减少 HTTP 请求数量，可以通过这些工具再发布前将多个 CSS 或者 多个 JS 合并成一个文件。</p>\n</li>\n<li>采用 lazyLoad：俗称<strong>懒加载</strong>，<strong>可以控制网页上的内容在一开始无需加载，不需要发请求，等到用户操作真正需要的时候立即加载出内容。这样就控制了网页资源一次性请求数量</strong>。</li>\n</ul>\n<ol>\n<li>控制资源文件加载优先级</li>\n</ol>\n<p>浏览器在加载 HTML 内容时，是将 HTML 内容从上至下依次解析，解析到 link 或者 script 标签就会加载 href 或者 src 对应链接内容，为了第一时间展示页面给用户，就需要将 CSS 提前加载，不要受 JS 加载影响。<br>一般情况下都是 CSS 在头部，JS 在底部。</p>\n<ol>\n<li>利用浏览器缓存<br>浏览器缓存是将网络资源存储在本地，等待下次请求该资源时，如果资源已经存在就不需要到服务器重新请求该资源，直接在本地读取该资源。</li>\n<li>减少重排（Reflow）<br>基本原理：重排是 DOM 的变化影响到了元素的几何属性（宽和高），浏览器会重新计算元素的几何属性，会使渲染树中受到影响的部分失效，浏览器会验证 DOM 树上的所有其它节点的 visibility 属性，这也是 Reflow 低效的原因。如果 Reflow 的过于频繁，CPU 使用率就会急剧上升。</li>\n</ol>\n<p>减少 Reflow，如果需要在 DOM 操作时添加样式，尽量使用 增加 class 属性，而不是通过 style 操作样式。</p>\n<ol>\n<li>减少 DOM 操作</li>\n<li>图标使用 IconFont 替换</li>\n</ol>\n<h3 id=\"11-网页从输入网址到渲染完成经历了哪些过程？\"><a href=\"#11-网页从输入网址到渲染完成经历了哪些过程？\" class=\"headerlink\" title=\"11. 网页从输入网址到渲染完成经历了哪些过程？\"></a>11. 网页从输入网址到渲染完成经历了哪些过程？</h3><p>大致可以分为如下7步：</p>\n<ol>\n<li>输入网址；</li>\n<li>发送到DNS服务器，并获取域名对应的web服务器对应的ip地址；</li>\n<li>与web服务器建立TCP连接；</li>\n<li>浏览器向web服务器发送http请求；</li>\n<li>web服务器响应请求，并返回指定url的数据（或错误信息，或重定向的新的url地址）；</li>\n<li>浏览器下载web服务器返回的数据及解析html源文件；</li>\n<li>生成DOM树，解析css和js，渲染页面，直至显示完成；</li>\n</ol>\n<h3 id=\"12-jQuery获取的dom对象和原生的dom对象有何区别？\"><a href=\"#12-jQuery获取的dom对象和原生的dom对象有何区别？\" class=\"headerlink\" title=\"12. jQuery获取的dom对象和原生的dom对象有何区别？\"></a>12. jQuery获取的dom对象和原生的dom对象有何区别？</h3><p>js原生获取的dom是一个对象，jQuery对象就是一个数组对象，其实就是选择出来的元素的数组集合，所以说他们两者是不同的对象类型不等价。</p>\n<ul>\n<li>原生DOM对象转jQuery对象：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var box = document.getElementById(&apos;box&apos;);</span><br><span class=\"line\">var $box = $(box);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>jQuery对象转原生DOM对象：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var $box = $(&apos;#box&apos;);</span><br><span class=\"line\">var box = $box[0];</span><br></pre></td></tr></table></figure>\n<h3 id=\"13-jQuery如何扩展自定义方法\"><a href=\"#13-jQuery如何扩展自定义方法\" class=\"headerlink\" title=\"13. jQuery如何扩展自定义方法\"></a>13. jQuery如何扩展自定义方法</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(jQuery.fn.myMethod=function () &#123;</span><br><span class=\"line\">       alert(&apos;myMethod&apos;);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">// 或者：</span><br><span class=\"line\">(function ($) &#123;</span><br><span class=\"line\">        $.fn.extend(&#123;</span><br><span class=\"line\">             myMethod : function () &#123;</span><br><span class=\"line\">                  alert(&apos;myMethod&apos;);</span><br><span class=\"line\">             &#125;</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">&#125;)(jQuery)</span><br></pre></td></tr></table></figure>\n<p>使用：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$(&quot;#div&quot;).myMethod();</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"1-谈谈你对MVVM开发模式的理解\"><a href=\"#1-谈谈你对MVVM开发模式的理解\" class=\"headerlink\" title=\"1. 谈谈你对MVVM开发模式的理解\"></a>1. 谈谈你对MVVM开发模式的理解</h3><p>MVVM分为Model、View、ViewModel三者。<br><strong>Model</strong> 代表数据模型，数据和业务逻辑都在Model层中定义；<br><strong>View</strong> 代表UI视图，负责数据的展示；<br><strong>ViewModel</strong> 负责监听 <strong>Model</strong> 中数据的改变并且控制视图的更新，处理用户交互操作；<br><strong>Model</strong> 和 <strong>View</strong> 并无直接关联，而是通过 <strong>ViewModel</strong> 来进行联系的，<strong>Model</strong> 和 <strong>ViewModel</strong> 之间有着双向数据绑定的联系。因此当 <strong>Model</strong> 中的数据改变时会触发 <strong>View</strong> 层的刷新，<strong>View</strong> 中由于用户交互操作而改变的数据也会在 <strong>Model</strong> 中同步。<br>这种模式实现了 <strong>Model</strong> 和 <strong>View</strong> 的数据自动同步，因此开发者只需要专注对数据的维护操作即可，而不需要自己操作 <strong>dom</strong>。</p>\n<h3 id=\"2-Vue-有哪些指令？\"><a href=\"#2-Vue-有哪些指令？\" class=\"headerlink\" title=\"2. Vue 有哪些指令？\"></a>2. Vue 有哪些指令？</h3><p>v-html、v-show、v-if、v-for等等</p>\n<h3 id=\"3-v-if-和-v-show-有什么区别？\"><a href=\"#3-v-if-和-v-show-有什么区别？\" class=\"headerlink\" title=\"3. v-if 和 v-show 有什么区别？\"></a>3. v-if 和 v-show 有什么区别？</h3><p>v-show 仅仅控制元素的显示方式，将 display 属性在 block 和 none 来回切换；而v-if会控制这个 DOM 节点的存在与否。当我们需要经常切换某个元素的显示/隐藏时，使用v-show会更加节省性能上的开销；当只需要一次显示或隐藏时，使用v-if更加合理。</p>\n<h3 id=\"4-简述Vue的响应式原理\"><a href=\"#4-简述Vue的响应式原理\" class=\"headerlink\" title=\"4. 简述Vue的响应式原理\"></a>4. 简述Vue的响应式原理</h3><p>当一个Vue实例创建时，vue会遍历data选项的属性，用 <strong>Object.defineProperty</strong> 将它们转为 getter/setter并且在内部追踪相关依赖，在属性被访问和修改时通知变化。<br>每个组件实例都有相应的 watcher 程序实例，它会在组件渲染的过程中把属性记录为依赖，之后当依赖项的 setter 被调用时，会通知 watcher 重新计算，从而致使它关联的组件得以更新。</p>\n<p><img src=\"https://zhanglong292383147.gitee.io/picture_images/picture/Vue_2019/1.png\" alt=\"\"></p>\n<h3 id=\"5-Vue中如何在组件内部实现一个双向数据绑定？\"><a href=\"#5-Vue中如何在组件内部实现一个双向数据绑定？\" class=\"headerlink\" title=\"5. Vue中如何在组件内部实现一个双向数据绑定？\"></a>5. Vue中如何在组件内部实现一个双向数据绑定？</h3><p>假设有一个输入框组件，用户输入时，同步父组件页面中的数据<br>具体思路：父组件通过 props 传值给子组件，子组件通过 $emit 来通知父组件修改相应的props值，具体实现如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import Vue from &apos;vue&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">const component = &#123;</span><br><span class=\"line\">  props: [&apos;value&apos;],</span><br><span class=\"line\">  template: `</span><br><span class=\"line\">    &lt;div&gt;</span><br><span class=\"line\">      &lt;input type=&quot;text&quot; @input=&quot;handleInput&quot; :value=&quot;value&quot;&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">  `,</span><br><span class=\"line\">  data () &#123;</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  methods: &#123;</span><br><span class=\"line\">    handleInput (e) &#123;</span><br><span class=\"line\">      this.$emit(&apos;input&apos;, e.target.value)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">new Vue(&#123;</span><br><span class=\"line\">  components: &#123;</span><br><span class=\"line\">    CompOne: component</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  el: &apos;#root&apos;,</span><br><span class=\"line\">  template: `</span><br><span class=\"line\">    &lt;div&gt;</span><br><span class=\"line\">      &lt;comp-one :value1=&quot;value&quot; @input=&quot;value = arguments[0]&quot;&gt;&lt;/comp-one&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">  `,</span><br><span class=\"line\">  data () &#123;</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">      value: &apos;123&apos;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>可以看到，当输入数据时，父子组件中的数据是同步改变的：</p>\n<p><img src=\"https://zhanglong292383147.gitee.io/picture_images/picture/Vue_2019/2.png\" alt=\"\"></p>\n<p><img src=\"https://zhanglong292383147.gitee.io/picture_images/picture/Vue_2019/3.png\" alt=\"\"></p>\n<p>我们在父组件中做了两件事，一是给子组件传入props，二是监听input事件并同步自己的value属性。那么这两步操作能否再精简一下呢？答案是可以的，你只需要修改父组件：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template: `</span><br><span class=\"line\">    &lt;div&gt;</span><br><span class=\"line\">      &lt;!--&lt;comp-one :value1=&quot;value&quot; @input=&quot;value = arguments[0]&quot;&gt;&lt;/comp-one&gt;--&gt;</span><br><span class=\"line\">      &lt;comp-one v-model=&quot;value&quot;&gt;&lt;/comp-one&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">  `</span><br></pre></td></tr></table></figure>\n<p>v-model 实际上会帮我们完成上面的两步操作。</p>\n<h3 id=\"6-Vue中如何监控某个属性值的变化？\"><a href=\"#6-Vue中如何监控某个属性值的变化？\" class=\"headerlink\" title=\"6. Vue中如何监控某个属性值的变化？\"></a>6. Vue中如何监控某个属性值的变化？</h3><p>比如现在需要监控data中，<strong>obj.a</strong> 的变化。Vue中监控对象属性的变化你可以这样：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">watch: &#123;</span><br><span class=\"line\">      obj: &#123;</span><br><span class=\"line\">      handler (newValue, oldValue) &#123;</span><br><span class=\"line\">        console.log(&apos;obj changed&apos;)</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      deep: true</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>deep属性表示深层遍历，但是这么写会监控obj的所有属性变化，并不是我们想要的效果，所以做点修改：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">watch: &#123;</span><br><span class=\"line\">   &apos;obj.a&apos;: &#123;</span><br><span class=\"line\">      handler (newName, oldName) &#123;</span><br><span class=\"line\">        console.log(&apos;obj.a changed&apos;)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>还有一种方法，可以通过computed 来实现，只需要：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">computed: &#123;</span><br><span class=\"line\">    a1 () &#123;</span><br><span class=\"line\">      return this.obj.a</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>利用计算属性的特性来实现，当依赖改变时，便会重新计算一个新值。</p>\n<h3 id=\"7-Vue中给data中的对象属性添加一个新的属性时会发生什么，如何解决？\"><a href=\"#7-Vue中给data中的对象属性添加一个新的属性时会发生什么，如何解决？\" class=\"headerlink\" title=\"7. Vue中给data中的对象属性添加一个新的属性时会发生什么，如何解决？\"></a>7. Vue中给data中的对象属性添加一个新的属性时会发生什么，如何解决？</h3><p>示例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">  &lt;div&gt;</span><br><span class=\"line\">    &lt;ul&gt;</span><br><span class=\"line\">      &lt;li v-for=&quot;value in obj&quot; :key=&quot;value&quot;&gt;</span><br><span class=\"line\">        &#123;&#123;value&#125;&#125;</span><br><span class=\"line\">      &lt;/li&gt;</span><br><span class=\"line\">    &lt;/ul&gt;</span><br><span class=\"line\">    &lt;button @click=&quot;addObjB&quot;&gt;添加obj.b&lt;/button&gt;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">  data () &#123;</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">      obj: &#123;</span><br><span class=\"line\">        a: &apos;obj.a&apos;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  methods: &#123;</span><br><span class=\"line\">    addObjB () &#123;</span><br><span class=\"line\">      this.obj.b = &apos;obj.b&apos;</span><br><span class=\"line\">      console.log(this.obj)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br><span class=\"line\">&lt;style&gt;&lt;/style&gt;</span><br></pre></td></tr></table></figure>\n<p>点击button会发现，obj.b 已经成功添加，但是视图并<strong>未刷新</strong>：</p>\n<p><img src=\"https://zhanglong292383147.gitee.io/picture_images/picture/Vue_2019/4.png\" alt=\"\"></p>\n<p><img src=\"https://zhanglong292383147.gitee.io/picture_images/picture/Vue_2019/5.png\" alt=\"\"></p>\n<p>原因在于在Vue实例创建时，obj.b并未声明，因此就没有被Vue转换为响应式的属性，自然就不会触发视图的更新，这时就需要使用Vue的全局api $set()：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">addObjB () &#123;</span><br><span class=\"line\">      // this.obj.b = &apos;obj.b&apos;</span><br><span class=\"line\">      this.$set(this.obj, &apos;b&apos;, &apos;obj.b&apos;)</span><br><span class=\"line\">      console.log(this.obj)</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p><strong>$set()方法</strong>相当于手动的去把obj.b处理成一个响应式的属性，此时视图也会跟着改变了：</p>\n<p><img src=\"https://zhanglong292383147.gitee.io/picture_images/picture/Vue_2019/6.png\" alt=\"\"></p>\n<h3 id=\"8-delete和Vue-delete删除数组的区别\"><a href=\"#8-delete和Vue-delete删除数组的区别\" class=\"headerlink\" title=\"8. delete和Vue.delete删除数组的区别\"></a>8. delete和Vue.delete删除数组的区别</h3><p>delete只是被删除的元素变成了 empty/undefined 其他的元素的键值还是不变。<br>Vue.delete直接删除了数组 改变了数组的键值。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a=[1,2,3,4]</span><br><span class=\"line\">var b=[1,2,3,4]</span><br><span class=\"line\">delete a[1]</span><br><span class=\"line\">console.log(a)</span><br><span class=\"line\">this.$delete(b,1)</span><br><span class=\"line\">console.log(b)</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://zhanglong292383147.gitee.io/picture_images/picture/Vue_2019/7.png\" alt=\"\"></p>\n<p><img src=\"https://zhanglong292383147.gitee.io/picture_images/picture/Vue_2019/8.png\" alt=\"\"></p>\n<h3 id=\"9-如何优化SPA应用的首屏加载速度慢的问题？\"><a href=\"#9-如何优化SPA应用的首屏加载速度慢的问题？\" class=\"headerlink\" title=\"9.如何优化SPA应用的首屏加载速度慢的问题？\"></a>9.如何优化SPA应用的首屏加载速度慢的问题？</h3><ul>\n<li>将公用的JS库通过script标签外部引入，减小app.bundel的大小，让浏览器并行下载资源文件，提高下载速度；</li>\n<li>在配置 路由时，页面和组件使用懒加载的方式引入，进一步缩小 app.bundel 的体积，在调用某个组件时再加载对应的js文件；</li>\n<li>加一个首屏 loading 图，提升用户体验；</li>\n</ul>\n<h3 id=\"10-前端如何优化网站性能？\"><a href=\"#10-前端如何优化网站性能？\" class=\"headerlink\" title=\"10. 前端如何优化网站性能？\"></a>10. 前端如何优化网站性能？</h3><ol>\n<li>减少 HTTP 请求数量</li>\n</ol>\n<p>在浏览器与服务器进行通信时，主要是通过 HTTP 进行通信。浏览器与服务器需要经过三次握手，每次握手需要花费大量时间。而且不同浏览器对资源文件并发请求数量有限（<a href=\"http://www.stevesouders.com/blog/2008/03/20/roundup-on-parallel-connections/\" target=\"_blank\" rel=\"noopener\">不同浏览器允许并发数</a>），一旦 HTTP 请求数量达到一定数量，资源请求就存在<strong>等待状态</strong>，这是很致命的，因此减少 HTTP 的请求数量可以很大程度上对网站性能进行优化。</p>\n<ul>\n<li><p>CSS Sprites：国内俗称 CSS 精灵<strong>（精灵图）</strong>，这是将多张图片合并成一张图片达到减少 HTTP 请求的一种解决方案，可以通过 CSS background 属性来访问图片内容。这种方案同时还可以减少图片总字节数。</p>\n</li>\n<li><p>合并 CSS 和 JS 文件：现在前端有很多工程化打包工具，如：grunt、gulp、webpack等。为了减少 HTTP 请求数量，可以通过这些工具再发布前将多个 CSS 或者 多个 JS 合并成一个文件。</p>\n</li>\n<li>采用 lazyLoad：俗称<strong>懒加载</strong>，<strong>可以控制网页上的内容在一开始无需加载，不需要发请求，等到用户操作真正需要的时候立即加载出内容。这样就控制了网页资源一次性请求数量</strong>。</li>\n</ul>\n<ol>\n<li>控制资源文件加载优先级</li>\n</ol>\n<p>浏览器在加载 HTML 内容时，是将 HTML 内容从上至下依次解析，解析到 link 或者 script 标签就会加载 href 或者 src 对应链接内容，为了第一时间展示页面给用户，就需要将 CSS 提前加载，不要受 JS 加载影响。<br>一般情况下都是 CSS 在头部，JS 在底部。</p>\n<ol>\n<li>利用浏览器缓存<br>浏览器缓存是将网络资源存储在本地，等待下次请求该资源时，如果资源已经存在就不需要到服务器重新请求该资源，直接在本地读取该资源。</li>\n<li>减少重排（Reflow）<br>基本原理：重排是 DOM 的变化影响到了元素的几何属性（宽和高），浏览器会重新计算元素的几何属性，会使渲染树中受到影响的部分失效，浏览器会验证 DOM 树上的所有其它节点的 visibility 属性，这也是 Reflow 低效的原因。如果 Reflow 的过于频繁，CPU 使用率就会急剧上升。</li>\n</ol>\n<p>减少 Reflow，如果需要在 DOM 操作时添加样式，尽量使用 增加 class 属性，而不是通过 style 操作样式。</p>\n<ol>\n<li>减少 DOM 操作</li>\n<li>图标使用 IconFont 替换</li>\n</ol>\n<h3 id=\"11-网页从输入网址到渲染完成经历了哪些过程？\"><a href=\"#11-网页从输入网址到渲染完成经历了哪些过程？\" class=\"headerlink\" title=\"11. 网页从输入网址到渲染完成经历了哪些过程？\"></a>11. 网页从输入网址到渲染完成经历了哪些过程？</h3><p>大致可以分为如下7步：</p>\n<ol>\n<li>输入网址；</li>\n<li>发送到DNS服务器，并获取域名对应的web服务器对应的ip地址；</li>\n<li>与web服务器建立TCP连接；</li>\n<li>浏览器向web服务器发送http请求；</li>\n<li>web服务器响应请求，并返回指定url的数据（或错误信息，或重定向的新的url地址）；</li>\n<li>浏览器下载web服务器返回的数据及解析html源文件；</li>\n<li>生成DOM树，解析css和js，渲染页面，直至显示完成；</li>\n</ol>\n<h3 id=\"12-jQuery获取的dom对象和原生的dom对象有何区别？\"><a href=\"#12-jQuery获取的dom对象和原生的dom对象有何区别？\" class=\"headerlink\" title=\"12. jQuery获取的dom对象和原生的dom对象有何区别？\"></a>12. jQuery获取的dom对象和原生的dom对象有何区别？</h3><p>js原生获取的dom是一个对象，jQuery对象就是一个数组对象，其实就是选择出来的元素的数组集合，所以说他们两者是不同的对象类型不等价。</p>\n<ul>\n<li>原生DOM对象转jQuery对象：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var box = document.getElementById(&apos;box&apos;);</span><br><span class=\"line\">var $box = $(box);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>jQuery对象转原生DOM对象：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var $box = $(&apos;#box&apos;);</span><br><span class=\"line\">var box = $box[0];</span><br></pre></td></tr></table></figure>\n<h3 id=\"13-jQuery如何扩展自定义方法\"><a href=\"#13-jQuery如何扩展自定义方法\" class=\"headerlink\" title=\"13. jQuery如何扩展自定义方法\"></a>13. jQuery如何扩展自定义方法</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(jQuery.fn.myMethod=function () &#123;</span><br><span class=\"line\">       alert(&apos;myMethod&apos;);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">// 或者：</span><br><span class=\"line\">(function ($) &#123;</span><br><span class=\"line\">        $.fn.extend(&#123;</span><br><span class=\"line\">             myMethod : function () &#123;</span><br><span class=\"line\">                  alert(&apos;myMethod&apos;);</span><br><span class=\"line\">             &#125;</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">&#125;)(jQuery)</span><br></pre></td></tr></table></figure>\n<p>使用：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$(&quot;#div&quot;).myMethod();</span><br></pre></td></tr></table></figure>"},{"title":"面试题精选","type":"categories","layout":"post","_content":"\n#面试题精选\n\n## 数组去重怎么实现？\n\n1、可以使用for循环去重\n\n```js\n/*\n* 新建一新数组，遍历传入数组，值不在新数组就push进该新数组中\n* IE8以下不支持数组的indexOf方法\n* */\nfunction uniq(array){\n    var temp = []; //一个新的临时数组\n    for(var i = 0; i < array.length; i++){\n        if(temp.indexOf(array[i]) == -1){\n            temp.push(array[i]);\n        }\n    }\n    return temp;\n}\n\nvar aa = [1,2,2,4,9,6,7,5,2,3,5,6,5];\nconsole.log(uniq(aa));\n\n//优化遍历数组法\n// 思路：获取没重复的最右一值放入新数组\n/*\n* 推荐的方法 *\n* 方法的实现代码相当酷炫，\n* 实现思路：获取没重复的最右一值放入新数组。\n* （检测到有重复值时终止当前循环同时进入顶层循环的下一轮判断）*/\nfunction uniq(array){\n    var temp = [];\n    var index = [];\n    var l = array.length;\n    for(var i = 0; i < l; i++) {\n        for(var j = i + 1; j < l; j++){\n            if (array[i] === array[j]){\n                i++;\n                j = i;\n            }\n        }\n        temp.push(array[i]);\n        index.push(i);\n    }\n    console.log(index);\n    return temp;\n}\n\nvar aa = [1,2,2,3,5,3,6,5];\nconsole.log(uniq(aa));\n\n//对象键值法去重\n/*\n* 速度最快， 占空间最多（空间换时间）\n* 该方法执行的速度比其他任何方法都快， 就是占用的内存大一些。\n* 现思路：新建一js对象以及新数组，遍历传入数组时，判断值是否为js对象的键，\n* 不是的话给对象新增该键并放入新数组。\n* 注意点：判断是否为js对象键时，会自动对传入的键执行“toString()”，\n* 不同的键可能会被误认为一样，例如n[val]-- n[1]、n[\"1\"]；\n* 解决上述问题还是得调用“indexOf”。*/\nfunction uniq(array){\n    var temp = {}, r = [], len = array.length, val, type;\n    for (var i = 0; i < len; i++) {\n        val = array[i];\n        type = typeof val;\n        if (!temp[val]) {\n            temp[val] = [type];\n            r.push(val);\n        } else if (temp[val].indexOf(type) < 0) {\n            temp[val].push(type);\n            r.push(val);\n        }\n    }\n    return r;\n}\n\nvar aa = [1,2,\"2\",4,9,\"a\",\"a\",2,3,5,6,5];\nconsole.log(uniq(aa));\n\n//数组下标法\n/*\n* 还是得调用“indexOf”性能跟方法1差不多，\n* 实现思路：如果当前数组的第i项在当前数组中第一次出现的位置不是i，\n* 那么表示第i项是重复的，忽略掉。否则存入结果数组。\n* */\nfunction uniq(array){\n    var temp = [];\n    for(var i = 0; i < array.length; i++) {\n        //如果当前数组的第i项在当前数组中第一次出现的位置是i，才存入数组；否则代表是重复的\n        if(array.indexOf(array[i]) == i){\n            temp.push(array[i])\n        }\n    }\n    return temp;\n}\n\nvar aa = [1,2,\"2\",4,9,\"a\",\"a\",2,3,5,6,5];\nconsole.log(uniq(aa));\n```\n\n2、利用hash表去重\n\n3、先排序后去重\n\n```js\n//排序后相邻去除法\n/*\n* 给传入数组排序，排序后相同值相邻，\n* 然后遍历时,新数组只加入不与前一值重复的值。\n* 会打乱原来数组的顺序\n* */\nfunction uniq(array){\n    array.sort();\n    var temp=[array[0]];\n    for(var i = 1; i < array.length; i++){\n        if( array[i] !== temp[temp.length-1]){\n            temp.push(array[i]);\n        }\n    }\n    return temp;\n}\n\nvar aa = [1,2,\"2\",4,9,\"a\",\"a\",2,3,5,6,5];\nconsole.log(uniq(aa));\n```\n\n4、Set方式去重\n\n```js\nconst removeDuplicateItems = arr => [...new Set(arr)]; console.log(removeDuplicateItems([42, 'foo', 42, 'foo', true, true])); // => [42, \"foo\", true]\n```\n\n\n\n## Javascript 基础数据类型？\n``` bash\nnumber(数值)\nstring(字符串)\nBoolean(布尔)\nnull(空)\nundefined(未定义)\n引用类型有：object\n```\n\n\n## 谈一谈Javascript作用域链？\n\n当执行一段JS代码(全局代码或函数)时，JS引擎会创建一个作用域又称为执行上下文，在页面加载后会首先创建一个全局的作用域，然后每执行一个函数，会建立一个对应的作用域，从而形成了一条作用域链。每个作用域都有一条对应的作用域链，链头是全局作用域，链尾是当前函数作用域。\n\n作用域链作用是用于解析标识符，当函数被创建时（不是执行），会将this.arguments、命名参数和该函数中的所有局部变量添加到该当前作用域中，当JS需要查找变量X的时候，这个过程称为变量解析，它首先会直到查找到链头，也就是全局作用域链，仍未找到该变量的话，就认为这段代码的作用域上不存在X变量，并抛出引用错误的异常。\n\n\n\n## 如何理解JS原型链？\n\nJS中的每一个prototype属性，我们称之为原型，而原型的值也是对象，因此它也有自己的原型，这样就串联起来了一条原型链，原型链的链头是object，它的prototype比较特殊，值为null。\n\n原型链的作用是用于对象继承，函数A的原型属性是一个对象，当这个函数被用作构造函数来创建实例时，该函数的原型属性将被作为原型赋值给所有对象实例，比如我们新建一个数组，数组的方法便从数组的原型上继承而来。\n\n当访问对象的一个属性时，首先查找对象本身，找到则返回；若未找到，则继续查找其原型对象的属性（如果还找不到实际上会沿着原型链向上查找，直到根），只要没有被覆盖的话，对象原型的属性就能在所有的实例中找到，若整个原型链未找到则返回undefined.\n\n```\n总结：\n\n1、每个函数对象都有一个 prototype 属性， 这个属性就是函数的原型对象\n\n2、原型链式 JavaScript 实现继承的重要方式，原型链的形成是真正是靠__proto__而非prototype\n```\n\n\n\n## （重点）如何理解和应用JS闭包？\n\n简单的理解是函数的嵌套形成闭包，闭包包括函数本身以及它的外部作用域，函数a内嵌套b，且返回b，当调用函数a时，用变量接收函数b，就形成了闭包。\n\n优点：\n\n① 减少全局变量。\n\n② 减少传递函数的参数量\n\n③ 封装\n\n缺点：延长了作用域链，需要释放的变量不能及时释放，可能引发内存泄漏，其实说白了就是该内存空间使用完毕之后未回收，即所谓内存泄漏，最终，结果是程序运行时间越长，占用存储空间越来越多，最终用尽全部存储空间，整个系统崩溃。(**使用闭包会占有内存资源，过多的使用闭包会导致内存溢出等.**)\n\n最简洁、直击要害的回答，我能想到的分别有这么三句\n\n**1、闭包是一个有状态**（不消失的私有数据）**的函数。**\n\n**2、闭包是一个有记忆的函数。**\n\n**3、闭包相当于一个只有一个方法的紧凑对象**（a compact object）。 \n\n**通俗的讲：就是函数a的内部函数b，被函数a外部的一个变量引用的时候，就创建了一个闭包。**\n\n```js\n//这样在执行完var c=a()后，变量c实际上是指向了函数b，再执行c()后就会弹出一个窗口显示i的值(第一次为1)。这段代码其实就创建了一个闭包，为什么？因为函数a外的变量c引用了函数a内的函数b\n\n   function a(){\n           var i=0;\n           function b(){\n              alert(++i);\n           }\n              return b;\n       }\n\n var c = a();\n        c();\n\n// 更容易理解的闭包\nfunction f1() {\n    var num = 0;\n    // 定义内部函数\n    function f2() {\n        return num + 1;\n    }\n    // 返回 f2函数引用\n    return f2;\n}\n\n// bar 变量也指向 f2 函数，在此也是一个闭包\nvar bar = f1();\n\n// 执行\nbar();  //1\n\n// 我们知道，函数中的变量会随着函数的执行完毕后会被销毁。而如上的代码，f1() 函数执行完毕后，将 f2 函数赋值给一个全局变量，而 f2 函数的变量又依赖 f1 的 num 变量，因此，f1中的 num 变量并不会随着 f1 的函数执行完毕后而销毁\n```\n\n\n\n## Javascript代理？\n\n当我们需要对很多元素添加事件的时候，可以通过将事件添加到它们的父节点而将事件委托给父节点来触发处理函数。\n\n\n\n## HTML5有哪些新特性？移除了哪些元素？如何处理HTML5新标签的浏览兼容问题？如何区别HTML和HTML5？\n\n1、HTML5现在已经不是SGML的子集，主要是关于图像，位置，存储，多任务等功能的增加；\n\n2、用于媒介回放的 *video* 和 *audio* 元素\n\n3、本地离线存储localStorge长期存储数据，浏览器关闭后数据不会丢失。\n\n4、语义化更好的内容元素，比如article、footer、header、nav、section\n\n5、新的技术webworker、websockt、geolocation移除的元素\n\n6、对可用性产生负面影响的元素：frame、frameset、noframes，支持HTML5标签\n\n7、IE8/IE7/IE6支持通过docment.createElement 方法产生的标签\n\n8、浏览器支持新标签后，还需要添加标签默认的样式\n\n\n\n## CSS隐藏元素的几种方法？\n\n1、opacity： 透明度\n\n2、visibility： 可见的\n\n3、display： 显示\n\n4、position： 位置\n\n\n\n## (重点) 性能优化的方法？\n\n1、减小http请求：css Sprites，JS，css源码压缩，图片大小控制合适；网页Gzip，CDN托管，data缓存，图片服务器\n\n2、用innerHTML代替DOM操作，减小DOM操作次数，优化Javascript性能\n\n3、避免使用CSS Expression（CSS表达式）又称Dynamic properties（动态属性）\n\n4、当需要设置的样式很多时设置 className 而不是直接操作style\n\n5、图片预加载，将样式表放在顶部，将脚本放在底部加上时间戳\n\n\n\n## 一个页面从输入URL到页面加载显示完成，这个过程中都发生了什么？\n\n4个步骤：\n\n1、当发送一个URL请求时，不管这个URL是web页面的URL还是web页面上每个资源的URL，浏览器都会开启一个线程来处理这个请求，同时在远程DNS服务器上启动一个DNS查询，这能使浏览器获取请求对应的IP地址\n\n2、浏览器与远程web服务器通过TCP三次握手协商来建立一个TCP/IP 连接。该握手包括一个同步报文，一个同步-应答报文和一个应答报文，这三个报文在浏览器和服务器之间传递。该握手首先由服务端尝试建立起通信，而后服务器应答并接受客户端的请求，最后由客户端发出该请求已经被接受的报文。\n\n3、一旦TCP/IP 连接建立，浏览器会通过该连接向远程服务器发送HTTP和GET请求。远程服务器找到资源并使用HTTP响应返回该资源，值为200 的 HTTP 响应状态表示一个正确的响应\n\n4、此时，web服务器提供资源服务，客户端开始下载资源。\n\n#### 简洁版\n\n*浏览器根据请求的URL交给DNS域名解析，找到真实的IP，向服务器发起请求；*\n\n*服务器交给后台处理完成后返回数据，浏览器接收文件(HTML，JS，CSS，图像等等)；*\n\n*浏览器对加载到的资源进行语法解析，建立相应的内部数据结构；*\n\n*载入解析到的资源文件，渲染页面，完成。*\n\n\n\n## Javascript对象的几种创建方法？\n\n1、工厂模式\n\n2、构造函数模式\n\n3、原型模式\n\n4、混合构造函数和原型模式\n\n5、动态原型模式\n\n6、寄生构造函数模式\n\n7、稳妥构造函数模式\n\n\n\n## Javascript继承的6种方法？\n\n1、原型链继承\n\n2、借用构造函数继承\n\n3、组合继承（原型 + 借用构造）\n\n4、原型式继承\n\n5、寄生式继承\n\n6、寄生组合式继承\n\n\n\n## AJAX过程？\n\n1#   创建XMLHttpRequest 对象，也就是创建一个异步调用对象\n\n2#  创建一个新的 HTTP 请求，并指定该 HTTP 请求的方法， URL 及验证信息\n\n3#  设置响应 HTTP 请求状态变化的函数\n\n4#  发送HTTP请求\n\n5#  获取异步调用返回的数据\n\n6#  使用 Javascript 和 DOM 实现局部刷新\n\n\n\n另一个说法：\n\n1、服务器获得请求参数\n\n2、服务器处理请求参数（添加，查询等操作）\n\n3、服务器响应数据给浏览器\n\nAJAX 引擎获得服务端响应的数据，通过执行JS的回调函数将数据传递给浏览器页面\n\n1、通过设置而给Ajax引擎的回调函数获得服务器响应的数据\n\n2、使用JS在指定的位置，显示响应数据，从而局部修改页面的数据，达到局部刷新目的。\n\n\n\n## JSONP原理是什么？\n\n首先客户端注册一个callback，然后callback的名字传给服务器。此时，服务器生成 json 数据，然后以 JS 方法的方式，生成 function，function 名字就是传递上来带参数jsonp。最后将 json 数据直接以入参的方式，放置 function 中，这样就生成JS语法的文档，返回给客户端，客户端浏览器，解析script 变迁，并执行返回JS文档，此时数据作为参数，传入了客户端预先定义好的 callback 函数里。简单地说，就是利用script 标签没有跨域限制的 “漏洞” 来达到与第三方通讯的目的。\n\njson是一种数据格式，jsonp是一种数据调用的方式，带 callback 的 json 就是 jsonp\n\n\n\n## JSONP的缺点？\n\njsonp有个缺陷就是只能get\n\n而且会把请求的内容发送到url中导致安全性极低\n\n\n\n## 移动端性能优化？\n\n尽量使用CSS动画，开启硬件加速。适应使用 touch 事件代替 click 事件。避免使用 CSS3 渐变阴影效果。\n\n尽可能少的使用 box-shadow（阴影） 与 gradients（渐变）。box-shadow 与 gradients 往往都是页面的性能杀手。\n\n\n\n## 说说你this的理解？\n\n在JS中，this通常指向的是我们正在执行的函数本身，或者是指向该函数所属的对象。\n\n1、普通函数中 this 是window\n\n2、构造函数中 this 是当前的实例对象\n\n3、对象中的 this 是指其本身\n\n4、原型对象的方法中 this 是当前的实例对象\n\n5、计时器中 this 是 window\n\n6、事件处理函数，this 是触发该事件的对象\n\n\n\n## 如何编写高性能的JS？\n\n1、使用 DocumentFragment 优化多次 append\n\n2、通过模板元素clone，替代 createElement\n\n3、使用一次innerHTML 赋值代构建 DOM 元素\n\n4、使用 firstChild 和 nextSibling 代替 childNods 遍历 DOM 元素\n\n5、使用 Array 作为 StringBuffter ，代替字符串拼接的操作\n\n6、将循环控制量保存到局部变量\n\n7、顺序无关的遍历时，用 while 代替 for\n\n8、将条件分支，按可能性顺序从到低排列\n\n9、在同一条件子的多（> 2）条件分支时，使用 switch 优于 if\n\n10、在使用三目运算符替代条件分支\n\n11、需要不断执行的时间后，优先考虑使用 setInterval\n\n\n\n## 哪些操作会造成内存泄漏？\n\n所谓的内存泄漏，就是在您不再拥有或需要它的时候，仍然存在\n\n垃圾回收机制会定期扫描对象，并计算引用了每个对象的其他对象的数量，如果一个对象的没有被其他对象引用过，或该对象的唯一引用是循环的，那么该对象内存即可回收。\n\n1、setTimeout 的第一个参数使用字符串而非函数的话， 会引发内泄漏\n\n2、闭包\n\n3、控制台日志\n\n4、循环（在两个对象彼此引用且彼此保留时，就会产生一个循环）\n\n\n\n## ES6更新了哪些新特性？\n\n1. **默认参数**\n\n   ```javascript\n   //ES5我们这样定义默认参数\n   var link = function (height, color, url) {\n       var height = height || 50;\n       var color = color || 'red';\n       var url = url || 'http://azat.co';\n       ...\n   }\n   ```\n\n   这样做是有一点小问题的，当默认参数为0时就暴露问题了，因为在JavaScript中，0表示false。\n\n   ```javascript\n   // ES6可以默认值写在函数声明里\n   var link = function(height = 50, color = 'red', url = 'http://azat.co') {\n     ...\n   }\n   ```\n\n   \n\n2. **模板文本**\n\n   ```javascript\n   // ES5的字符串拼接\n   var name = 'Your name is ' + first + ' ' + last + '.';\n   var url = 'http://localhost:3000/api/messages/' + id;\n   ```\n\n   ES6的字符串远不用如此麻烦，我们可以在反引号（~符的unshift键）中使用新语法 **${变量名称}** 表示。\n\n   ```javascript\n   // ES6\n   var name = `Your name is ${first} ${last}. `;\n   var url = `http://localhost:3000/api/messages/${id}`;\n   ```\n\n3. **多行字符串**\n\n   ```javascript\n   // ES5 多行字符串需要 + 号连接\n   var roadPoem = 'Then took the other, as just as fair,nt'\n       + 'And having perhaps the better claimnt'\n       + 'Because it was grassy and wanted wear,nt'\n       + 'Though as for that the passing therent'\n       + 'Had worn them really about the same,nt';\n   var fourAgreements = 'You have the right to be you.n\n       You can only be you when you do your best.';\n   ```\n\n   然而在ES6中，仅仅用反引号就可以解决了：\n\n   ```javascript\n   var roadPoem = `Then took the other, as just as fair,\n       And having perhaps the better claim\n       Because it was grassy and wanted wear,\n       Though as for that the passing there\n       Had worn them really about the same,`;\n   var fourAgreements = `You have the right to be you.\n       You can only be you when you do your best.`;\n   ```\n\n   \n\n4. **解构赋值**\n\n   这是一个比较难掌握的知识点，我们先用比较简单的例子切入。\n\n   下面这些情况都是很常见的：\n\n   ```javascript\n   //ES5中获取data对象中的属性\n   var data = response.data,    // data has properties info and imageLink \n       info = data.info,\n       imageLink = data.imageLink \n   //ES5获取一个模块中的方法\n   var stringHandle = require('toolModule').stringHandle ;\n   ```\n\n   ES6中，我们可以使用解构处理以上两种情况：\n\n   ```javascript\n   var {info, imageLink} = response.data;\n   var {stringHandle} = require('toolModule')\n   ```\n\n   右侧的response.data和require('toolModule')都是对象，与左侧的 { } 格式相同，首先要保证这一点。个人理解{info, imageLink} = response.data像是**{info, imageLink} = {response.data.info, response.data.imageLink}这样一个对应关系**，然后我们就可以直接使用 info 和 imageLink 这两个变量了。\n\n   \n\n5. **增强的对象文本**\n\n   下面是一个典型ES5对象文本，里面有一些方法和属性：\n\n   ```javascript\n   var serviceBase = {port: 3000, url: 'azat.co'},\n       getAccounts = function(){return [1,2,3]};\n   var accountServiceES5 = {\n     port: serviceBase.port,\n     url: serviceBase.url,\n     getAccounts: getAccounts,\n      toString: function() {\n         return JSON.stringify(this.valueOf());\n     },\n     getUrl: function() {return \"http://\" + this.url + ':' + this.port},\n     valueOf_1_2_3: getAccounts()\n   }\n   ```\n\n   如果我们想让它更有意思，我们可以用Object.create从serviceBase继承原型的方法：\n\n   ```javascript\n   var accountServiceES5ObjectCreate = Object.create(serviceBase)\n   var accountServiceES5ObjectCreate = {\n     getAccounts: getAccounts,\n     toString: function() {\n       return JSON.stringify(this.valueOf());\n     },\n     getUrl: function() {return \"http://\" + this.url + ':' + this.port},\n     valueOf_1_2_3: getAccounts()\n   }\n   ```\n\n   \n\n6. **箭头函数**\n\n   这是我迫不及待想讲的一个特征，CoffeeScript 就是因为它丰富的箭头函数让很多开发者喜爱。在ES6中，也有了丰富的箭头函数。这些丰富的箭头是令人惊讶的因为它们将使许多操作变成现实，比如，\n\n   以前我们使用闭包，this总是预期之外地产生改变，而箭头函数的迷人之处在于，现在你的this可以按照你的预期使用了，身处箭头函数里面，this还是原来的this。\n\n   有了箭头函数在ES6中， 我们就不必用that = this或 self =  this  或 _this = this  或.bind(this)。例如，下面的代码用ES5就不是很优雅：\n\n   ```javascript\n   var _this = this;\n   $('.btn').click(function(event){\n     _this.sendData();\n   })\n   ```\n\n   在ES6中就不需要用 _this = this：\n\n   ```javascript\n   $('.btn').click((event) =>{\n     this.sendData();\n   })\n   ```\n\n7. **Promises**\n\n   Promises 是一个有争议的话题。因此有许多略微不同的promise 实现语法。Q，bluebird，deferred.js，vow, avow, jquery 一些可以列出名字的。也有人说我们不需要promises，仅仅使用异步，生成器，回调等就够了。但令人高兴的是，在ES6中有标准的Promise实现。\n\n   下面是一个简单的用setTimeout()实现的异步延迟加载函数:\n\n   ```javascript\n   setTimeout(function(){\n     console.log('Yay!');\n   }, 1000);\n   ```\n\n   或者用ES6的箭头函数：\n\n   ```javascript\n   var wait1000 =  new Promise((resolve, reject)=> {\n     setTimeout(resolve, 1000);\n   }).then(()=> {\n     console.log('Yay!');\n   });\n   ```\n\n8. **块作用域和构造 let 和 const**\n\n   在ES6代码中，你可能已经看到那熟悉的身影let。在ES6里let并不是一个花俏的特性，它是更复杂的。Let是一种新的变量申明方式，它允许你把变量作用域控制在块级里面。\n\n     \n\n   在ES5中，大括号的块级作用域起不了任何作用：\n\n   ```javascript\n   function calculateTotalAmount (vip) {\n     var amount = 0;\n     if (vip) {\n       var amount = 1;\n     }\n     { \n       var amount = 100;\n       {\n         var amount = 1000;\n       }\n     }  \n     return amount;\n   }\n   console.log(calculateTotalAmount(true));　　　　// 1000，最后定义的生效，块级作用域无作用\n   ```\n\n   块级作用域中let定义的变量，只在此块级作用域中生效，外层无法访问。\n\n   ```javascript\n   function calculateTotalAmount (vip) {\n     var amount = 0; \n     if (vip) {\n       let amount = 1; \n     } \n     { \n       let amount = 100; \n       {\n         let amount = 1000; \n       }\n     }  \n     return amount;\n   }\n    \n   console.log(calculateTotalAmount(true));　　// 0，用let定义的变量都不可被最外层访问\n   ```\n\n   这里简单提一下，假如if句改为 **if( vip ){ amount = 1 } ，那么结果是1，因为这样相当于定义了一个全局变量。**\n\n    \n\n   我们知道，const用于声明常量，同一常量只可声明一次，声明后不可修改，而下面的代码中对于同一常量声明了多次，却没有报错，原因就是每个常量都只属于它所在的块级作用域，互不影响。\n\n   \n\n9. **类（Classes）**\n\n   现在就来看看如何用ES6写一个类吧。ES6没有用函数, 而是使用原型实现类。我们创建一个类baseModel ，并且在这个类里定义了一个constructor 和一个 getName()方法：\n\n   ```javascript\n   class baseModel {\n     constructor(options, data) {\n       this.name = 'Base';\n       this.url = 'http://azat.co/api';\n       this.data = data;\n       this.options = options;\n      }\n    \n       getName() { // class method\n           console.log(`Class name: ${this.name}`);\n       }\n   }\n   ```\n\n   AccountModel 从类baseModel 中继承而来:\n\n   ```javascript\n   class AccountModel extends baseModel {\n       constructor(options, data) {\n   　　　　//为了调用父级构造函数，可用super()参数传递：\n   　　　　super({private: true}, ['32113123123', '524214691']); //call the parent method with super\n          this.name = 'Account Model';\n          this.url +='/accounts/';\n       }\n   // 可以把 accountData 设置成一个属性：\n   　　get accountsData() { //calculated attribute getter\n        return this.data;\n      }\n   }\n   \n   ----------------------\n   \n   \n   let accounts = new AccountModel(5);\n   accounts.getName();    //Class name: Account Model\n   console.log('Data is %s', accounts.accountsData);    //Data is  32113123123,524214691\n   ```\n\n   \n\n10. **模块（Modules）**\n\n   众所周知，在ES6以前JavaScript并不支持本地的模块。人们想出了AMD，RequireJS，CommonJS以及其它解决方法。现在ES6中可以用模块import 和export 操作了。\n\n   \n   ```javascript\n   // 在ES5中，你可以在 <script>中直接写可以运行的代码（简称IIFE），或者一些库像AMD。然而在ES6中，你可以用export导入你的类。下面举个例子，在ES5中,module.js有port变量和getAccounts 方法:\n   // dev.js文件\n   module.exports = {\n     port: 3000,\n     getAccounts: function() {\n       ...\n     }\n   }\n   ```\n\n   在ES5中，需要依赖require(‘module’) 导入dev.js：\n\n   ```javascript\n   var service = require('dev.js');\n   console.log(service.port); // 3000\n   ```\n\n   但在ES6中，我们将用export and import。例如，这是我们用ES6 写的dev.js文件库：\n\n   ```javascript\n   // dev.js文件\n   export var port = 3000;\n   export function getAccounts(url) {\n     ...\n   }\n   ```\n\n   如果用ES6来导入到文件中，我们需用import {name} from ‘my-module’语法，例如：\n\n   ```javascript\n   import {port, getAccounts} from 'dev';\n   console.log(port); // 3000\n   ```\n\n   或者我们可以在文件中把整个模块导入, 并命名为 service：\n\n   ```javascript\n   import * as service from 'dev';\n   console.log(service.port); // 3000\n   ```\n\n# Vue框架面试题\n\n## V-show 指令，v-if 的区别？\n\n条件渲染指令，与v-if 不同的是，无论 v-show 的值为 true 或 false，元素都会存在于HTML代码中，而只有当 v-if 的值为true元素才会存在于 THML 代码中，v-show 指令只是设置了元素 CSS 的 style 值。\n\n使用MVVM模式有4个好处：\n\n1. 低耦合。view 可以独立于model 变化和修改，一个viewModel 可以绑定到不同的view上，当view 变化的时候model可以不变，当 Model 变化的时候 View 也可以不变。\n\n2. 可重用性。可以把一些视图的逻辑放在viewModel 里面，让很多View 重用这段视图逻辑\n\n3. 独立开发。开发人员专注与业务逻辑和数据的开发。设计人员可以专注于界面（View）的设计\n\n4. 可测试性。可以针对viewModel 来对界面进行测试\n\n   ![](https://zhanglong292383147.gitee.io/picture_images/picture/Mianjingxuan/MVVM模式工作原理.png)\n\nVue.js 特点：\n\n简洁：页面由HTML模式板 + JSON数据 + Vue 案例组成\n\n数据驱动：自动计算属性和追踪依赖的模板表达式\n\n组件化：用于复用、解耦的组件来构造页面\n\n轻量：代码量小，不依赖其他库\n\n快速：精确有效批量 DOM 更新\n\n模板友好：可通过npm，bower等多种方式安装，很容易融入\n\n\n\n## 怎么定义 vue-router 的动态路由？怎么获取传过来的动态参数？\n\n在 router 目录下的index.js文件中，对 path 属性上 /:id 的 params.id 使用 router 对象\n\n\n\n## vue-router 有哪种导航钩子？\n\n第一种：是全局导航钩子：router.beforeEach（to，from，next），作用：跳转前进进行判断拦截\n\n第二种：组件内的钩子\n\n第三种：单独路由独享组件\n\n\n\n## v-model 是什么？怎么使用？vue 中标签怎么绑定事件？\n\n```\n可以实现双向绑定，指令 （v-class，v-for，v-if，v-show，v-on） vue 的 model 层的 data 属性。绑定事件<input @click=del() />\n\n```\n\n## vuex 是什么？怎么使用？哪种功能场景使用它？\n\nVuex 是一个专为 Vue.js 应用程序开发的**状态管理模式**，在main.js 引入ctore，注入。新建一个目录 store、...export 场景有：单页应用中，组件之间的状态音乐播放器，登录状态，加入购物车\n\n------------------------------\n\n每一个 Vuex 应用的核心就是 store（仓库）。“store”基本上就是一个容器，它包含着你的应用中大部分的**状态 (state)**。Vuex 和单纯的全局对象有以下两点不同：\n\n1. Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。\n2. 你不能直接改变 store 中的状态。改变 store 中的状态的唯一途径就是显式地**提交 (commit) mutation**。这样使得我们可以方便地跟踪每一个状态的变化，从而让我们能够实现一些工具帮助我们更好地了解我们的应用。\n\n## 你是怎么认识 Vuex 的？\n\nVuex 可以理解为一种开发模式或框架。通过状态（数据源）集中管理驱动组件的变化。\n\n应用级的状态集中放在 store（仓库） 中，改变状态的方式是提交 mutations，这是个同步的事物，异步逻辑应该封装在 action 中\n\n![](https://zhanglong292383147.gitee.io/picture_images/picture/Mianjingxuan/Vuex是什么.jpg)\n\n- **state**，驱动应用的数据源；\n- **view**，以声明方式将 **state** 映射到视图；\n- **actions**，响应在 **view** 上的用户输入导致的状态变化。\n\n## vue-router是什么？它有哪些组件？\n\nvue用来写路由一个插件router-link，router-view\n\n\n\n## Vue的双向数据绑定原理是什么？\n\n![](https://zhanglong292383147.gitee.io/picture_images/picture/Mianjingxuan/VUE双向绑定原理.png)\n\n这里VM，就是 vue框架它相当于中间枢纽的作用，连接着 model 和 view\n\n当前台显示的 view 发生变化了，它会实时反应到 viewModel（上，如果有需要，viewModel会通过 Ajax 等方法将改变的数据传递给后台 model）\n\n同时从后台 model 获取过来的数据，通过 VM 将值响应到前台 UI 上\n\n![](https://zhanglong292383147.gitee.io/picture_images/picture/Mianjingxuan/input事件数据绑定原理.png)\n\nVM的核心是 view 和 data\n\n当 data 有变化的时候它通过 **object.defineProperty()**  方法中的 **set** 方法进行监控，并调用在此之前已经定义好 **data** 和 **view** 的关系了的回调函数，来通知 view 进行数据的改变。\n\n而 view 发生改变则是通过底层的 input 事件来进行 data 的响应更改\n\nVue 是通过 **object.defineProperty()** 来实现**数据劫持**的。（它可以来控制一个对象属性的一些特有操作，比如读写权、是否可以枚举）\n\n实现方法：观察者模式\n\nMVVM 框架类：\n\n![](https://zhanglong292383147.gitee.io/picture_images/picture/Mianjingxuan/观察者模式的MVVM框架的工作原理.png)\n\nObserver（object.defineProperty 中的 set）**监听** data 的变化，当 data **有变化**的时候**通知**观察者列表 **Dep**（里面有与 Data 变化对应的Update 函数），watcher**（监听器）** 负责向**观察者列表**（Dep）**添加**（订阅）对应的**更新函数**，Dep 里的更新函数执行了之后将*最新的值* **更新** 到 **View（视图）**上\n\n\n\n## 请详细说下你对 Vue 生命周期的理解？\n\n总共分 为 8个阶段：创建前 / 后，载入前 / 载入后，更新前 / 后，销毁前 / 后\n\n创建前 / 后：在 **beforeCreate (创建前)** 阶段，Vue实例的**挂载元素** el 和**数据对象** data 都为 **undefined**，还未初始化。在 **created (创建后)** 阶段，Vue 实例的**数据对象** data **有**了,  **el** 还**没有**。\n\n载入前 / 后：在**beforeMount** 阶段，Vue实例的 **el** 和 **data** 都**初始化**了，但还是挂载之前为虚拟的 DOM 节点，data.message 还未替换。在 **mounted** 阶段，Vue实例**挂载完成**，data.message 成功 **渲染**\n\n更新前 / 后：当 **data** 变化时，会**触发** beforeUpdate 和 updated 方法。\n\n销毁前 / 后：在执行 destroy 方法后，对 data 的改变不会再触发函数，说明此时 Vue 实例已经**解除**了**事件监听**以及和 **DOM 的绑定**，但是 dom **结构**依然**存在**\n\n```html\n<body>\n    <div id=\"app\">\n        <p>{{info}}</p>\n        <button @click=\"info='hello1'\">更新info</button>\n        <button @click=\"destroy\">销毁实例</button>\n    </div>\n    <script>\n        var vm = new Vue({\n            el: \"#app\",\n            data: {\n                info: \"hello\"\n            },\n            // 在实例初始化之后，数据观测 (data observer) 和 event/watcher 配置之前被调用。\n            beforeCreate: function () {\n                console.log(\"===============beforeCreate============================================\")\n                // $el表示Vue 实例使用的根 DOM 元素。\n                console.log('$el', this.$el);\n                // $data Vue 实例观察的数据对象\n                console.log('$data', this.$data);\n                console.log(\"info:\", this.info)\n            },\n            // 在实例创建完成后被立即调用。在这一步，实例已完成以下的配置：数据观测 (data observer)，属性和方法的运算，watch/event 事件回调。然而，挂载阶段还没开始，dom还未生成，$el 属性目前不可见。 一般都在created中发送请求\n            created: function () {\n                console.log(\"===============created=======================================\")\n                console.log('$el', this.$el);\n                console.log('$data', this.$data);\n                console.log(\"info:\", this.info)\n            },\n            // 模板编译挂载之前调用，首先会判断对象是否有el选项。如果有的话就继续向下编译，如果没有el选项，则停止编译，也就意味着停止了生命周期，直到在该vue实例上调用vm.$mount(el)。接着判断是否有template属性，有的话就以template属性中的值作为模板，如果没有的话，就以el属性指向的作为模板。这里会生成vm.$el，但指令尚未被解析\n            beforeMount: function () {\n                console.log(\"===============beforeMount=========================================\")\n                console.log('$el', this.$el);\n                console.log('$data', this.$data);\n                console.log(\"info:\", this.info)\n            },\n            // 模板编译挂载之后调用，vm.$el替换掉el指向的dom\n            mounted: function () {\n                console.log(\"===============mounted===========================================\")\n                console.log('$el', this.$el);\n                console.log('$data', this.$data);\n                console.log(\"info:\", this.info)\n            },\n            // 数据变更导致虚拟DOM重新渲染之前调用\n            beforeUpdate: function () {\n                console.log(\"===============beforeUpdate============================================\");\n\n            },\n            // 数据变更导致虚拟DOM重新渲染之后调用\n            updated: function () {\n                console.log(\"===============updated======================================================\");\n            },\n            // 实例销毁之前调用，在这一步，实例完全可用\n            beforeDestroy: function () {\n                console.log(\"===============beforeDestroy===============================================\")\n                console.log('$el', this.$el);\n                console.log('$data', this.$data);\n                console.log(\"info:\", this.info)\n            },\n            // vue实例指向的所有东西解除绑定，包括watcher、事件、所以的子组件，后续就不再受vue实例控制了\n            destroyed: function () {\n                console.log(\"===============destroyed================================================\")\n                console.log('$el', this.$el);\n                console.log('$data', this.$data);\n                console.log(\"info:\", this.info)\n            },\n            methods: {\n                destroy() {\n                    // 表示销毁组件\n                    this.$destroy()\n                },\n                udpateinfo() {\n                    this.info = 'hello2'\n                }\n            }\n        })\n    </script>\n</body>\n```\n\n\n\n## Vue 组件封装过程？\n\n首先，使用 Vue.extend() 创建一个组件\n\n然后，使用 Vue.component() 方法注册组件\n\n接着，如果子组件需要数据，可以在 props 中接受定义\n\n最后，子组件修改好数据之后，想把数据传递给父组件，可以使用 emit() 方法\n\n\n\n## Vue-loader 是什么？\n\n解析 Vue 文件的一个加载器，跟 template/js/style 转换成 JS 模块\n\n提供了一些非常酷炫的特性：\n\nES5默认可用；\n\n```\n在每个 Vue 组件内支持其他的 webpack 加载器，如用于 <style> 的 SASS 和用于<template>的 Jade\n\n把 <style>和<template>内引用的静态资源作为模块依赖项对待，并用 webpack 加载器处理。\n\n对每个组件模拟有作用域的 css\n\n开发阶段支持组件的热加载\n\n简单的说，webpack 和 vue-loader 的组合为你创作 Vue 应用一个更先进、更灵巧极其强大的前端开发模式\n```\n\n## 使用它的用途有哪些？\n\nJS 可以写 es6、style 样式可以 scss 或 less、template可以加 jade 等。\n\n\n\n## 说出至少4种Vue当中的指令和它的用法\n\nv-if：判断是否隐藏；\n\nv-for：数据循环出来；\n\nv-bind：class：绑定一个属性；\n\nv-model：实现双向绑定\n\n\n\n## 自定义指令（v-check、v-focus）的方法有哪些？它有哪些钩子函数？还有哪些钩子函数参数？\n\n全局定义指令：在 Vue 对象的 driective 方法里面有两个参数，一个是指令名称，另一个是函数。组件内定义指令：directives；\n\n钩子函数：bind（绑定事件触发），inserted（节点插入的时候触发）、update（组件内相关更新）\n\n钩子函数参数：el ， binding\n\n\n\n理解 Vue 自定义指令钩子函数：\n\n一个指令定义对象可以提供如下几个钩子函数（均为可选）：\n\nbind：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置\n\ninserted：被绑定元素插入父节点时调用（仅保证父节点存在，但不一定已被插入文档中）\n\nupdate：所在组件的 VNode 更新时调用，但是可能发生在其子 VNode 更新之前。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新\n\ncomponentUpdated：指令所在组件的 VNode 及其子 VNode 全部更新后调用。\n\nconbind：只调用一次，指令与元素解绑时调用。\n\n\n\n指令钩子函数会被传入以下参数：\n\nel：指令所绑定的元素，可以用来直接操作 DOM\n\nbinding：一个对象，包含以下属性：\n\nname：指令名，不包含 v-前缀\n\nvalue：指令的绑定值，例如：v-my-directive=“ 1 + 1” 中，绑定值为2\n\noldValue：指令绑定的前一个值，仅在 Update 和 compnentUpated 钩子中可用。无论值是否改变都可用\n\nexpression：字符串形式的指令表达式。例如 v-my-directive=“ 1 + 1 ” 中，表达式为“1+1”\n\navg：传给指令的参数，可选。例如：v-my-directive：foo 中，参数为 “foo”\n\nmodifiers：一个包含修饰符的对象。例如：v-my-directive.foo.bar 中，修饰符对象为 { foo：true，bar：true }\n\nvnode：Vue 编译生成的虚拟节点。移步 VNode API 来了解更多详情\n\noldVnode：上一个虚拟节点，仅在 update 和 componentUpdated 钩子中可用。\n\n\n\n## axios是什么？怎么使用？描述使用它实现登录功能的流程？\n\n1. 请求后台资源的模块。 npm i axios -s 装好\n2. 然后发送的是跨域，需在配置文件中 config/index.js 进行设置\n3. 后台如果是TP5 则定义一个资源路由。JS 使用import 进来，\n4. 然后 .get 或 .post 返回在 .this 函数中如果成功\n5. 失则则是在 .catch 函数中\n\n\n\n## axios + tp5 进价中，调用 axios.post(' api/user ') 是进行的什么操作？axios.put('api/8') 呢？\n\n跨域，添加用户操作，更新操作。\n\n\n\n## 请说下具体使用 Vue 的理解？\n\n1. 使用 Vue 不必担心布局更改和类名重复导致的 JS 重写，因为它是靠数据驱动双向绑定，底层是通过 Object.defineProperty() 定义的数据，set、get 函数原理实现。\n2. 组件化开发，让项目的可拓展性、移植性更好，代码重用性更高，就好像农民工建房子，拿起自己的工具包就可以开工。项目经理坐等收楼就好。\n3. 单页应用的体验零距离接触安卓原生应用，局部组件更新界面，让用户体验更快速省时。\n4. JS 的代码无形的规范，团队合作开发代码可阅读性更高。\n\n\n\n## 你觉得哪些项目适合 Vue 框架？\n\n1. 数据信息量比较多的，反之类似企业网站就无需此框架了\n2. 手机 web 和 app 应用多端共用一套界面的项目，因为使用 Vue.cli + webpack 后的前端目录，非常有利于项目的跨平台部署。\n\n\n\n## Vue 组件之间如何通信？\n\n作为一个vue初学者不得不了解的就是组件间的数据通信(暂且不谈vuex)。通信方式根据组件之间的关系有不同之处。组件关系有下面三种：**父-->子**、**子-->父**、**非父子**\n\n#### 父-->子\n\n父向子传递数据通过props\n\n```javascript\n//父组件代码\n<template>\n    <header-box :title-txt=\"showTitleTxt\"></header-box>\n</template>\n<script>\n    import Header from './header'\n    export default {\n        name: 'index',\n        components: {\n            'header-box': Header\n        },\n        data () {\n            return {\n                showTitleTxt: '首页'\n            }\n        }\n    }\n</script>\n```\n\n```javascript\n//子组件代码\n<template>\n    <header>\n        {{thisTitleTxt}}\n    </header>\n</template>\n<script>\n    export default {\n        name: 'header-box',\n        props: {\n            titleTxt: String\n        },\n        data () {\n            return {\n                thisTitleTxt: this.titleTxt\n            }\n        }\n    }\n</script>\n```\n\n#### 子-->父\n\n> 子组件向父组件传递分为两种类型。\n> 1、子组件改变父组件传递的props（你会发现通过props中的Object类型参数传输数据，可以通过子组件改变数据内容。这种方式是可行的，但是不推荐使用，因为官方定义prop是单向绑定）\n> 2、通过$on和$emit\n\n```javascript\n//通过props实现传递\n//父组件代码\n<template>\n    <header-box :title-txt=\"showTitleTxt\"></header-box>\n</template>\n<script>\n    import Header from './header'\n    export default {\n        name: 'index',\n        components: {\n            'header-box': Header\n        },\n        data () {\n            return {\n                showTitleTxt: {\n                    name: '首页'\n                }\n            }\n        }\n    }\n</script>\n```\n\n```javascript\n//子组件代码\n<template>\n    <header @click=\"changeTitleTxt\">\n        {{thisTitleTxt.name}}\n    </header>\n</template>\n<script>\n    export default {\n        name: 'header-box',\n        props: {\n            titleTxt: Object\n        },\n        data () {\n            return {\n                thisTitleTxt: this.titleTxt.name\n            }\n        },\n        metheds: {\n            changeTitleTxt () {\n                this.titleTxt.name = '切换'\n            }\n        }\n    }\n</script>\n```\n\n```javascript\n//通过$on,$emit\n//父组件代码\n<template>\n    <div id=\"counter-event-example\">\n      <p>{{ total }}</p>\n      <button-counter v-on:increment=\"incrementTotal\"></button-counter>\n</div>\n</template>\n<script>\n    import ButtonCounter from './buttonCounter'\n    export default {\n        name: 'index',\n        components: {\n            'button-conuter': ButtonCounter\n        },\n        data () {\n            return {\n                total: 0\n            }\n        },\n        methods: {\n            incrementTotal () {\n                this.total++\n            }\n        }\n    }\n</script>\n```\n\n```javascript\n//子组件代码\n<template>\n    <button @click=\"incrementCounter\">{{counter}}</button>\n</template>\n<script>\n    export default {\n        name: 'button-counter',\n        data () {\n            return {\n                counter: 0\n            }\n        },\n        metheds: {\n            incrementCounter () {\n                this.$emit('increment')\n                this.counter++\n            }\n        }\n    }\n</script>\n```\n\n#### 非父子\n\n> 简单情况下我们可以通过使用一个空的Vue实例作为中央事件总线，（这里也可以使用app实例，而不需要新建一个空Vue实例）\n\n```javascript\n//main.js\nlet bus = new Vue()\nVue.prototype.bus = bus\n```\n\n或者\n\n```js\n//main.js\nnew Vue({\n  el: '#app',\n  router,\n  template: '<App/>',\n  components: { App },\n  beforeCreate () {\n    Vue.prototype.bus = this\n  }\n})\n```\n\n```js\n//header组件\n<template>\n    <header @click=\"changeTitle\">{{title}}</header>\n</template>\n<script>\nexport default {\n    name: 'header',\n    data () {\n        return {\n            title: '头部'\n        }\n    },\n    methods: {\n        changeTitle () {\n            this.bus.$emit('toChangeTitle','首页')\n        }\n    }\n}\n</script>\n```\n\n```js\n//footer组件\n<template>\n    <footer>{{txt}}</footer>\n</template>\n<script>\nexport default {\n    name: 'footer',\n    mounted () {\n        this.bus.$on('toChangeTitle', function (title) {\n            console.log(title)\n        })\n    },\n    data () {\n        return {\n            txt: '尾部'\n        }\n    }\n}\n```\n\n\n\n## 关于vue在app首次加载缓慢的解决办法？\n\n*1.路由懒加载*\n\n![img](https:////upload-images.jianshu.io/upload_images/12205285-7190dce75d2c6b60.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/513/format/webp)\n\n​\t\t\t\t\t\t\t\t\t\t\t路由懒加载\n\n此方法会把原本打包到一个app.js文件分开成多个js文件打包，这样会减小单个文件的大小，但是不会减小整个js文件夹的大小。通过这种方式可以做到按需加载，只加载单个页面的js文件。\n\n*2.组件异步加载*\n\n![img](https:////upload-images.jianshu.io/upload_images/12205285-9aa4e5728fa3dce2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/372/format/webp)\n\n组件异步加载\n\n加载首页的时候，可以先给首页的子组件设置v-if = “false”，在页面初始化的时候再给子组件设置为true，此方法利用了v-if的惰性，setTimeout会使子组件在所有的组件初始化完成并显示后再对其子组件进行初始化。\n\n- [x] **注：在实际开发中还遇到了另一种情况也可以用此方法解决，在入口js中获取了app的token，但是在具体页面中发现不管是在created还是mounted中都是有时候能获取到token，有时候又不可以，是因为执行顺序的原因，可以通过 setTimeout 时间设置为0 这种方法把用到token的请求方法给排到最后，这样就能保证请求方法中有token了。**\n\n*3.使用异步组件，按需加载*\n\nnewVue({\n\n// ...\n\n  components: {\n\n​        'my-component':()=>import('./my-async-component')\n\n  }\n\n})\n\nes6的写法，`import` 函数会返回一个 `Promise` 对象。这样就实现了组件的按需加载，有需要的时候才会加载这个组件，同样也是优化首屏加载速度的一种方法。\n\n下面两张图片就可以清晰的了解 import xxx from \"./xxx.vue\" 与 import()方法 的不同，以及用import函数所带来的好处。\n\n\n\n\n\n![img](https:////upload-images.jianshu.io/upload_images/12205285-e3630781a7ba92e2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/656/format/webp)\n\n  import xxx from \"./xxx.vue\"  \n\n![img](https:////upload-images.jianshu.io/upload_images/12205285-fdb9ddf46f9da18e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/677/format/webp)\n\n   import()方法\n\n上面是两种方法，打包后所生成的文件，import函数的方法很明显多了几个js，这就是从原本 app.js 中分离出来的0.js，1.js，2.js。第一张图，在运行的时候会把app.js整个加载完，而第二张图会加载0.js+app.js，虽然多了一个文件，但实际上，后者整体加载的文件大小要比原本小很多。这就是按需加载，在需要1.js的时候才会加载它，而且加载过一次后就会缓存在本地，下次加载，会取缓存的文件。\n\n而且，因为import函数返回的是一个promise对象，因此可以用promise本身的then()和catch()方法去监听到组件的加载，如：\n\n![img](https:////upload-images.jianshu.io/upload_images/12205285-85fff817aae7b673.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/393/format/webp)\n\n*4.图片量多的时候可以进行分批的加载*\n\nvue-lazyload插件，图片懒加载\n\n*5.外部引入一些插件，不要在vue中引入*\n\n列入，我在次项目中有用到moment.js这个插件，在vue内部引入后打包的项目大小要比在外部用src的方式引入打包的项目大个300k左右。\n\n首先，下载好moment.min.js包，然后在vue项目的webpack.base.conf.js中添加下图箭头所指向的那段代码\n\n![img](https:////upload-images.jianshu.io/upload_images/12205285-96a1a056b87bd667.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/439/format/webp)\n\n加上上图的代码后是不会将moment.js给打包到js中的。\n\n","source":"_posts/mianshi/面试题精选.md","raw":"---\ntitle: 面试题精选\ntype: categories\nlayout: post\n---\n\n#面试题精选\n\n## 数组去重怎么实现？\n\n1、可以使用for循环去重\n\n```js\n/*\n* 新建一新数组，遍历传入数组，值不在新数组就push进该新数组中\n* IE8以下不支持数组的indexOf方法\n* */\nfunction uniq(array){\n    var temp = []; //一个新的临时数组\n    for(var i = 0; i < array.length; i++){\n        if(temp.indexOf(array[i]) == -1){\n            temp.push(array[i]);\n        }\n    }\n    return temp;\n}\n\nvar aa = [1,2,2,4,9,6,7,5,2,3,5,6,5];\nconsole.log(uniq(aa));\n\n//优化遍历数组法\n// 思路：获取没重复的最右一值放入新数组\n/*\n* 推荐的方法 *\n* 方法的实现代码相当酷炫，\n* 实现思路：获取没重复的最右一值放入新数组。\n* （检测到有重复值时终止当前循环同时进入顶层循环的下一轮判断）*/\nfunction uniq(array){\n    var temp = [];\n    var index = [];\n    var l = array.length;\n    for(var i = 0; i < l; i++) {\n        for(var j = i + 1; j < l; j++){\n            if (array[i] === array[j]){\n                i++;\n                j = i;\n            }\n        }\n        temp.push(array[i]);\n        index.push(i);\n    }\n    console.log(index);\n    return temp;\n}\n\nvar aa = [1,2,2,3,5,3,6,5];\nconsole.log(uniq(aa));\n\n//对象键值法去重\n/*\n* 速度最快， 占空间最多（空间换时间）\n* 该方法执行的速度比其他任何方法都快， 就是占用的内存大一些。\n* 现思路：新建一js对象以及新数组，遍历传入数组时，判断值是否为js对象的键，\n* 不是的话给对象新增该键并放入新数组。\n* 注意点：判断是否为js对象键时，会自动对传入的键执行“toString()”，\n* 不同的键可能会被误认为一样，例如n[val]-- n[1]、n[\"1\"]；\n* 解决上述问题还是得调用“indexOf”。*/\nfunction uniq(array){\n    var temp = {}, r = [], len = array.length, val, type;\n    for (var i = 0; i < len; i++) {\n        val = array[i];\n        type = typeof val;\n        if (!temp[val]) {\n            temp[val] = [type];\n            r.push(val);\n        } else if (temp[val].indexOf(type) < 0) {\n            temp[val].push(type);\n            r.push(val);\n        }\n    }\n    return r;\n}\n\nvar aa = [1,2,\"2\",4,9,\"a\",\"a\",2,3,5,6,5];\nconsole.log(uniq(aa));\n\n//数组下标法\n/*\n* 还是得调用“indexOf”性能跟方法1差不多，\n* 实现思路：如果当前数组的第i项在当前数组中第一次出现的位置不是i，\n* 那么表示第i项是重复的，忽略掉。否则存入结果数组。\n* */\nfunction uniq(array){\n    var temp = [];\n    for(var i = 0; i < array.length; i++) {\n        //如果当前数组的第i项在当前数组中第一次出现的位置是i，才存入数组；否则代表是重复的\n        if(array.indexOf(array[i]) == i){\n            temp.push(array[i])\n        }\n    }\n    return temp;\n}\n\nvar aa = [1,2,\"2\",4,9,\"a\",\"a\",2,3,5,6,5];\nconsole.log(uniq(aa));\n```\n\n2、利用hash表去重\n\n3、先排序后去重\n\n```js\n//排序后相邻去除法\n/*\n* 给传入数组排序，排序后相同值相邻，\n* 然后遍历时,新数组只加入不与前一值重复的值。\n* 会打乱原来数组的顺序\n* */\nfunction uniq(array){\n    array.sort();\n    var temp=[array[0]];\n    for(var i = 1; i < array.length; i++){\n        if( array[i] !== temp[temp.length-1]){\n            temp.push(array[i]);\n        }\n    }\n    return temp;\n}\n\nvar aa = [1,2,\"2\",4,9,\"a\",\"a\",2,3,5,6,5];\nconsole.log(uniq(aa));\n```\n\n4、Set方式去重\n\n```js\nconst removeDuplicateItems = arr => [...new Set(arr)]; console.log(removeDuplicateItems([42, 'foo', 42, 'foo', true, true])); // => [42, \"foo\", true]\n```\n\n\n\n## Javascript 基础数据类型？\n``` bash\nnumber(数值)\nstring(字符串)\nBoolean(布尔)\nnull(空)\nundefined(未定义)\n引用类型有：object\n```\n\n\n## 谈一谈Javascript作用域链？\n\n当执行一段JS代码(全局代码或函数)时，JS引擎会创建一个作用域又称为执行上下文，在页面加载后会首先创建一个全局的作用域，然后每执行一个函数，会建立一个对应的作用域，从而形成了一条作用域链。每个作用域都有一条对应的作用域链，链头是全局作用域，链尾是当前函数作用域。\n\n作用域链作用是用于解析标识符，当函数被创建时（不是执行），会将this.arguments、命名参数和该函数中的所有局部变量添加到该当前作用域中，当JS需要查找变量X的时候，这个过程称为变量解析，它首先会直到查找到链头，也就是全局作用域链，仍未找到该变量的话，就认为这段代码的作用域上不存在X变量，并抛出引用错误的异常。\n\n\n\n## 如何理解JS原型链？\n\nJS中的每一个prototype属性，我们称之为原型，而原型的值也是对象，因此它也有自己的原型，这样就串联起来了一条原型链，原型链的链头是object，它的prototype比较特殊，值为null。\n\n原型链的作用是用于对象继承，函数A的原型属性是一个对象，当这个函数被用作构造函数来创建实例时，该函数的原型属性将被作为原型赋值给所有对象实例，比如我们新建一个数组，数组的方法便从数组的原型上继承而来。\n\n当访问对象的一个属性时，首先查找对象本身，找到则返回；若未找到，则继续查找其原型对象的属性（如果还找不到实际上会沿着原型链向上查找，直到根），只要没有被覆盖的话，对象原型的属性就能在所有的实例中找到，若整个原型链未找到则返回undefined.\n\n```\n总结：\n\n1、每个函数对象都有一个 prototype 属性， 这个属性就是函数的原型对象\n\n2、原型链式 JavaScript 实现继承的重要方式，原型链的形成是真正是靠__proto__而非prototype\n```\n\n\n\n## （重点）如何理解和应用JS闭包？\n\n简单的理解是函数的嵌套形成闭包，闭包包括函数本身以及它的外部作用域，函数a内嵌套b，且返回b，当调用函数a时，用变量接收函数b，就形成了闭包。\n\n优点：\n\n① 减少全局变量。\n\n② 减少传递函数的参数量\n\n③ 封装\n\n缺点：延长了作用域链，需要释放的变量不能及时释放，可能引发内存泄漏，其实说白了就是该内存空间使用完毕之后未回收，即所谓内存泄漏，最终，结果是程序运行时间越长，占用存储空间越来越多，最终用尽全部存储空间，整个系统崩溃。(**使用闭包会占有内存资源，过多的使用闭包会导致内存溢出等.**)\n\n最简洁、直击要害的回答，我能想到的分别有这么三句\n\n**1、闭包是一个有状态**（不消失的私有数据）**的函数。**\n\n**2、闭包是一个有记忆的函数。**\n\n**3、闭包相当于一个只有一个方法的紧凑对象**（a compact object）。 \n\n**通俗的讲：就是函数a的内部函数b，被函数a外部的一个变量引用的时候，就创建了一个闭包。**\n\n```js\n//这样在执行完var c=a()后，变量c实际上是指向了函数b，再执行c()后就会弹出一个窗口显示i的值(第一次为1)。这段代码其实就创建了一个闭包，为什么？因为函数a外的变量c引用了函数a内的函数b\n\n   function a(){\n           var i=0;\n           function b(){\n              alert(++i);\n           }\n              return b;\n       }\n\n var c = a();\n        c();\n\n// 更容易理解的闭包\nfunction f1() {\n    var num = 0;\n    // 定义内部函数\n    function f2() {\n        return num + 1;\n    }\n    // 返回 f2函数引用\n    return f2;\n}\n\n// bar 变量也指向 f2 函数，在此也是一个闭包\nvar bar = f1();\n\n// 执行\nbar();  //1\n\n// 我们知道，函数中的变量会随着函数的执行完毕后会被销毁。而如上的代码，f1() 函数执行完毕后，将 f2 函数赋值给一个全局变量，而 f2 函数的变量又依赖 f1 的 num 变量，因此，f1中的 num 变量并不会随着 f1 的函数执行完毕后而销毁\n```\n\n\n\n## Javascript代理？\n\n当我们需要对很多元素添加事件的时候，可以通过将事件添加到它们的父节点而将事件委托给父节点来触发处理函数。\n\n\n\n## HTML5有哪些新特性？移除了哪些元素？如何处理HTML5新标签的浏览兼容问题？如何区别HTML和HTML5？\n\n1、HTML5现在已经不是SGML的子集，主要是关于图像，位置，存储，多任务等功能的增加；\n\n2、用于媒介回放的 *video* 和 *audio* 元素\n\n3、本地离线存储localStorge长期存储数据，浏览器关闭后数据不会丢失。\n\n4、语义化更好的内容元素，比如article、footer、header、nav、section\n\n5、新的技术webworker、websockt、geolocation移除的元素\n\n6、对可用性产生负面影响的元素：frame、frameset、noframes，支持HTML5标签\n\n7、IE8/IE7/IE6支持通过docment.createElement 方法产生的标签\n\n8、浏览器支持新标签后，还需要添加标签默认的样式\n\n\n\n## CSS隐藏元素的几种方法？\n\n1、opacity： 透明度\n\n2、visibility： 可见的\n\n3、display： 显示\n\n4、position： 位置\n\n\n\n## (重点) 性能优化的方法？\n\n1、减小http请求：css Sprites，JS，css源码压缩，图片大小控制合适；网页Gzip，CDN托管，data缓存，图片服务器\n\n2、用innerHTML代替DOM操作，减小DOM操作次数，优化Javascript性能\n\n3、避免使用CSS Expression（CSS表达式）又称Dynamic properties（动态属性）\n\n4、当需要设置的样式很多时设置 className 而不是直接操作style\n\n5、图片预加载，将样式表放在顶部，将脚本放在底部加上时间戳\n\n\n\n## 一个页面从输入URL到页面加载显示完成，这个过程中都发生了什么？\n\n4个步骤：\n\n1、当发送一个URL请求时，不管这个URL是web页面的URL还是web页面上每个资源的URL，浏览器都会开启一个线程来处理这个请求，同时在远程DNS服务器上启动一个DNS查询，这能使浏览器获取请求对应的IP地址\n\n2、浏览器与远程web服务器通过TCP三次握手协商来建立一个TCP/IP 连接。该握手包括一个同步报文，一个同步-应答报文和一个应答报文，这三个报文在浏览器和服务器之间传递。该握手首先由服务端尝试建立起通信，而后服务器应答并接受客户端的请求，最后由客户端发出该请求已经被接受的报文。\n\n3、一旦TCP/IP 连接建立，浏览器会通过该连接向远程服务器发送HTTP和GET请求。远程服务器找到资源并使用HTTP响应返回该资源，值为200 的 HTTP 响应状态表示一个正确的响应\n\n4、此时，web服务器提供资源服务，客户端开始下载资源。\n\n#### 简洁版\n\n*浏览器根据请求的URL交给DNS域名解析，找到真实的IP，向服务器发起请求；*\n\n*服务器交给后台处理完成后返回数据，浏览器接收文件(HTML，JS，CSS，图像等等)；*\n\n*浏览器对加载到的资源进行语法解析，建立相应的内部数据结构；*\n\n*载入解析到的资源文件，渲染页面，完成。*\n\n\n\n## Javascript对象的几种创建方法？\n\n1、工厂模式\n\n2、构造函数模式\n\n3、原型模式\n\n4、混合构造函数和原型模式\n\n5、动态原型模式\n\n6、寄生构造函数模式\n\n7、稳妥构造函数模式\n\n\n\n## Javascript继承的6种方法？\n\n1、原型链继承\n\n2、借用构造函数继承\n\n3、组合继承（原型 + 借用构造）\n\n4、原型式继承\n\n5、寄生式继承\n\n6、寄生组合式继承\n\n\n\n## AJAX过程？\n\n1#   创建XMLHttpRequest 对象，也就是创建一个异步调用对象\n\n2#  创建一个新的 HTTP 请求，并指定该 HTTP 请求的方法， URL 及验证信息\n\n3#  设置响应 HTTP 请求状态变化的函数\n\n4#  发送HTTP请求\n\n5#  获取异步调用返回的数据\n\n6#  使用 Javascript 和 DOM 实现局部刷新\n\n\n\n另一个说法：\n\n1、服务器获得请求参数\n\n2、服务器处理请求参数（添加，查询等操作）\n\n3、服务器响应数据给浏览器\n\nAJAX 引擎获得服务端响应的数据，通过执行JS的回调函数将数据传递给浏览器页面\n\n1、通过设置而给Ajax引擎的回调函数获得服务器响应的数据\n\n2、使用JS在指定的位置，显示响应数据，从而局部修改页面的数据，达到局部刷新目的。\n\n\n\n## JSONP原理是什么？\n\n首先客户端注册一个callback，然后callback的名字传给服务器。此时，服务器生成 json 数据，然后以 JS 方法的方式，生成 function，function 名字就是传递上来带参数jsonp。最后将 json 数据直接以入参的方式，放置 function 中，这样就生成JS语法的文档，返回给客户端，客户端浏览器，解析script 变迁，并执行返回JS文档，此时数据作为参数，传入了客户端预先定义好的 callback 函数里。简单地说，就是利用script 标签没有跨域限制的 “漏洞” 来达到与第三方通讯的目的。\n\njson是一种数据格式，jsonp是一种数据调用的方式，带 callback 的 json 就是 jsonp\n\n\n\n## JSONP的缺点？\n\njsonp有个缺陷就是只能get\n\n而且会把请求的内容发送到url中导致安全性极低\n\n\n\n## 移动端性能优化？\n\n尽量使用CSS动画，开启硬件加速。适应使用 touch 事件代替 click 事件。避免使用 CSS3 渐变阴影效果。\n\n尽可能少的使用 box-shadow（阴影） 与 gradients（渐变）。box-shadow 与 gradients 往往都是页面的性能杀手。\n\n\n\n## 说说你this的理解？\n\n在JS中，this通常指向的是我们正在执行的函数本身，或者是指向该函数所属的对象。\n\n1、普通函数中 this 是window\n\n2、构造函数中 this 是当前的实例对象\n\n3、对象中的 this 是指其本身\n\n4、原型对象的方法中 this 是当前的实例对象\n\n5、计时器中 this 是 window\n\n6、事件处理函数，this 是触发该事件的对象\n\n\n\n## 如何编写高性能的JS？\n\n1、使用 DocumentFragment 优化多次 append\n\n2、通过模板元素clone，替代 createElement\n\n3、使用一次innerHTML 赋值代构建 DOM 元素\n\n4、使用 firstChild 和 nextSibling 代替 childNods 遍历 DOM 元素\n\n5、使用 Array 作为 StringBuffter ，代替字符串拼接的操作\n\n6、将循环控制量保存到局部变量\n\n7、顺序无关的遍历时，用 while 代替 for\n\n8、将条件分支，按可能性顺序从到低排列\n\n9、在同一条件子的多（> 2）条件分支时，使用 switch 优于 if\n\n10、在使用三目运算符替代条件分支\n\n11、需要不断执行的时间后，优先考虑使用 setInterval\n\n\n\n## 哪些操作会造成内存泄漏？\n\n所谓的内存泄漏，就是在您不再拥有或需要它的时候，仍然存在\n\n垃圾回收机制会定期扫描对象，并计算引用了每个对象的其他对象的数量，如果一个对象的没有被其他对象引用过，或该对象的唯一引用是循环的，那么该对象内存即可回收。\n\n1、setTimeout 的第一个参数使用字符串而非函数的话， 会引发内泄漏\n\n2、闭包\n\n3、控制台日志\n\n4、循环（在两个对象彼此引用且彼此保留时，就会产生一个循环）\n\n\n\n## ES6更新了哪些新特性？\n\n1. **默认参数**\n\n   ```javascript\n   //ES5我们这样定义默认参数\n   var link = function (height, color, url) {\n       var height = height || 50;\n       var color = color || 'red';\n       var url = url || 'http://azat.co';\n       ...\n   }\n   ```\n\n   这样做是有一点小问题的，当默认参数为0时就暴露问题了，因为在JavaScript中，0表示false。\n\n   ```javascript\n   // ES6可以默认值写在函数声明里\n   var link = function(height = 50, color = 'red', url = 'http://azat.co') {\n     ...\n   }\n   ```\n\n   \n\n2. **模板文本**\n\n   ```javascript\n   // ES5的字符串拼接\n   var name = 'Your name is ' + first + ' ' + last + '.';\n   var url = 'http://localhost:3000/api/messages/' + id;\n   ```\n\n   ES6的字符串远不用如此麻烦，我们可以在反引号（~符的unshift键）中使用新语法 **${变量名称}** 表示。\n\n   ```javascript\n   // ES6\n   var name = `Your name is ${first} ${last}. `;\n   var url = `http://localhost:3000/api/messages/${id}`;\n   ```\n\n3. **多行字符串**\n\n   ```javascript\n   // ES5 多行字符串需要 + 号连接\n   var roadPoem = 'Then took the other, as just as fair,nt'\n       + 'And having perhaps the better claimnt'\n       + 'Because it was grassy and wanted wear,nt'\n       + 'Though as for that the passing therent'\n       + 'Had worn them really about the same,nt';\n   var fourAgreements = 'You have the right to be you.n\n       You can only be you when you do your best.';\n   ```\n\n   然而在ES6中，仅仅用反引号就可以解决了：\n\n   ```javascript\n   var roadPoem = `Then took the other, as just as fair,\n       And having perhaps the better claim\n       Because it was grassy and wanted wear,\n       Though as for that the passing there\n       Had worn them really about the same,`;\n   var fourAgreements = `You have the right to be you.\n       You can only be you when you do your best.`;\n   ```\n\n   \n\n4. **解构赋值**\n\n   这是一个比较难掌握的知识点，我们先用比较简单的例子切入。\n\n   下面这些情况都是很常见的：\n\n   ```javascript\n   //ES5中获取data对象中的属性\n   var data = response.data,    // data has properties info and imageLink \n       info = data.info,\n       imageLink = data.imageLink \n   //ES5获取一个模块中的方法\n   var stringHandle = require('toolModule').stringHandle ;\n   ```\n\n   ES6中，我们可以使用解构处理以上两种情况：\n\n   ```javascript\n   var {info, imageLink} = response.data;\n   var {stringHandle} = require('toolModule')\n   ```\n\n   右侧的response.data和require('toolModule')都是对象，与左侧的 { } 格式相同，首先要保证这一点。个人理解{info, imageLink} = response.data像是**{info, imageLink} = {response.data.info, response.data.imageLink}这样一个对应关系**，然后我们就可以直接使用 info 和 imageLink 这两个变量了。\n\n   \n\n5. **增强的对象文本**\n\n   下面是一个典型ES5对象文本，里面有一些方法和属性：\n\n   ```javascript\n   var serviceBase = {port: 3000, url: 'azat.co'},\n       getAccounts = function(){return [1,2,3]};\n   var accountServiceES5 = {\n     port: serviceBase.port,\n     url: serviceBase.url,\n     getAccounts: getAccounts,\n      toString: function() {\n         return JSON.stringify(this.valueOf());\n     },\n     getUrl: function() {return \"http://\" + this.url + ':' + this.port},\n     valueOf_1_2_3: getAccounts()\n   }\n   ```\n\n   如果我们想让它更有意思，我们可以用Object.create从serviceBase继承原型的方法：\n\n   ```javascript\n   var accountServiceES5ObjectCreate = Object.create(serviceBase)\n   var accountServiceES5ObjectCreate = {\n     getAccounts: getAccounts,\n     toString: function() {\n       return JSON.stringify(this.valueOf());\n     },\n     getUrl: function() {return \"http://\" + this.url + ':' + this.port},\n     valueOf_1_2_3: getAccounts()\n   }\n   ```\n\n   \n\n6. **箭头函数**\n\n   这是我迫不及待想讲的一个特征，CoffeeScript 就是因为它丰富的箭头函数让很多开发者喜爱。在ES6中，也有了丰富的箭头函数。这些丰富的箭头是令人惊讶的因为它们将使许多操作变成现实，比如，\n\n   以前我们使用闭包，this总是预期之外地产生改变，而箭头函数的迷人之处在于，现在你的this可以按照你的预期使用了，身处箭头函数里面，this还是原来的this。\n\n   有了箭头函数在ES6中， 我们就不必用that = this或 self =  this  或 _this = this  或.bind(this)。例如，下面的代码用ES5就不是很优雅：\n\n   ```javascript\n   var _this = this;\n   $('.btn').click(function(event){\n     _this.sendData();\n   })\n   ```\n\n   在ES6中就不需要用 _this = this：\n\n   ```javascript\n   $('.btn').click((event) =>{\n     this.sendData();\n   })\n   ```\n\n7. **Promises**\n\n   Promises 是一个有争议的话题。因此有许多略微不同的promise 实现语法。Q，bluebird，deferred.js，vow, avow, jquery 一些可以列出名字的。也有人说我们不需要promises，仅仅使用异步，生成器，回调等就够了。但令人高兴的是，在ES6中有标准的Promise实现。\n\n   下面是一个简单的用setTimeout()实现的异步延迟加载函数:\n\n   ```javascript\n   setTimeout(function(){\n     console.log('Yay!');\n   }, 1000);\n   ```\n\n   或者用ES6的箭头函数：\n\n   ```javascript\n   var wait1000 =  new Promise((resolve, reject)=> {\n     setTimeout(resolve, 1000);\n   }).then(()=> {\n     console.log('Yay!');\n   });\n   ```\n\n8. **块作用域和构造 let 和 const**\n\n   在ES6代码中，你可能已经看到那熟悉的身影let。在ES6里let并不是一个花俏的特性，它是更复杂的。Let是一种新的变量申明方式，它允许你把变量作用域控制在块级里面。\n\n     \n\n   在ES5中，大括号的块级作用域起不了任何作用：\n\n   ```javascript\n   function calculateTotalAmount (vip) {\n     var amount = 0;\n     if (vip) {\n       var amount = 1;\n     }\n     { \n       var amount = 100;\n       {\n         var amount = 1000;\n       }\n     }  \n     return amount;\n   }\n   console.log(calculateTotalAmount(true));　　　　// 1000，最后定义的生效，块级作用域无作用\n   ```\n\n   块级作用域中let定义的变量，只在此块级作用域中生效，外层无法访问。\n\n   ```javascript\n   function calculateTotalAmount (vip) {\n     var amount = 0; \n     if (vip) {\n       let amount = 1; \n     } \n     { \n       let amount = 100; \n       {\n         let amount = 1000; \n       }\n     }  \n     return amount;\n   }\n    \n   console.log(calculateTotalAmount(true));　　// 0，用let定义的变量都不可被最外层访问\n   ```\n\n   这里简单提一下，假如if句改为 **if( vip ){ amount = 1 } ，那么结果是1，因为这样相当于定义了一个全局变量。**\n\n    \n\n   我们知道，const用于声明常量，同一常量只可声明一次，声明后不可修改，而下面的代码中对于同一常量声明了多次，却没有报错，原因就是每个常量都只属于它所在的块级作用域，互不影响。\n\n   \n\n9. **类（Classes）**\n\n   现在就来看看如何用ES6写一个类吧。ES6没有用函数, 而是使用原型实现类。我们创建一个类baseModel ，并且在这个类里定义了一个constructor 和一个 getName()方法：\n\n   ```javascript\n   class baseModel {\n     constructor(options, data) {\n       this.name = 'Base';\n       this.url = 'http://azat.co/api';\n       this.data = data;\n       this.options = options;\n      }\n    \n       getName() { // class method\n           console.log(`Class name: ${this.name}`);\n       }\n   }\n   ```\n\n   AccountModel 从类baseModel 中继承而来:\n\n   ```javascript\n   class AccountModel extends baseModel {\n       constructor(options, data) {\n   　　　　//为了调用父级构造函数，可用super()参数传递：\n   　　　　super({private: true}, ['32113123123', '524214691']); //call the parent method with super\n          this.name = 'Account Model';\n          this.url +='/accounts/';\n       }\n   // 可以把 accountData 设置成一个属性：\n   　　get accountsData() { //calculated attribute getter\n        return this.data;\n      }\n   }\n   \n   ----------------------\n   \n   \n   let accounts = new AccountModel(5);\n   accounts.getName();    //Class name: Account Model\n   console.log('Data is %s', accounts.accountsData);    //Data is  32113123123,524214691\n   ```\n\n   \n\n10. **模块（Modules）**\n\n   众所周知，在ES6以前JavaScript并不支持本地的模块。人们想出了AMD，RequireJS，CommonJS以及其它解决方法。现在ES6中可以用模块import 和export 操作了。\n\n   \n   ```javascript\n   // 在ES5中，你可以在 <script>中直接写可以运行的代码（简称IIFE），或者一些库像AMD。然而在ES6中，你可以用export导入你的类。下面举个例子，在ES5中,module.js有port变量和getAccounts 方法:\n   // dev.js文件\n   module.exports = {\n     port: 3000,\n     getAccounts: function() {\n       ...\n     }\n   }\n   ```\n\n   在ES5中，需要依赖require(‘module’) 导入dev.js：\n\n   ```javascript\n   var service = require('dev.js');\n   console.log(service.port); // 3000\n   ```\n\n   但在ES6中，我们将用export and import。例如，这是我们用ES6 写的dev.js文件库：\n\n   ```javascript\n   // dev.js文件\n   export var port = 3000;\n   export function getAccounts(url) {\n     ...\n   }\n   ```\n\n   如果用ES6来导入到文件中，我们需用import {name} from ‘my-module’语法，例如：\n\n   ```javascript\n   import {port, getAccounts} from 'dev';\n   console.log(port); // 3000\n   ```\n\n   或者我们可以在文件中把整个模块导入, 并命名为 service：\n\n   ```javascript\n   import * as service from 'dev';\n   console.log(service.port); // 3000\n   ```\n\n# Vue框架面试题\n\n## V-show 指令，v-if 的区别？\n\n条件渲染指令，与v-if 不同的是，无论 v-show 的值为 true 或 false，元素都会存在于HTML代码中，而只有当 v-if 的值为true元素才会存在于 THML 代码中，v-show 指令只是设置了元素 CSS 的 style 值。\n\n使用MVVM模式有4个好处：\n\n1. 低耦合。view 可以独立于model 变化和修改，一个viewModel 可以绑定到不同的view上，当view 变化的时候model可以不变，当 Model 变化的时候 View 也可以不变。\n\n2. 可重用性。可以把一些视图的逻辑放在viewModel 里面，让很多View 重用这段视图逻辑\n\n3. 独立开发。开发人员专注与业务逻辑和数据的开发。设计人员可以专注于界面（View）的设计\n\n4. 可测试性。可以针对viewModel 来对界面进行测试\n\n   ![](https://zhanglong292383147.gitee.io/picture_images/picture/Mianjingxuan/MVVM模式工作原理.png)\n\nVue.js 特点：\n\n简洁：页面由HTML模式板 + JSON数据 + Vue 案例组成\n\n数据驱动：自动计算属性和追踪依赖的模板表达式\n\n组件化：用于复用、解耦的组件来构造页面\n\n轻量：代码量小，不依赖其他库\n\n快速：精确有效批量 DOM 更新\n\n模板友好：可通过npm，bower等多种方式安装，很容易融入\n\n\n\n## 怎么定义 vue-router 的动态路由？怎么获取传过来的动态参数？\n\n在 router 目录下的index.js文件中，对 path 属性上 /:id 的 params.id 使用 router 对象\n\n\n\n## vue-router 有哪种导航钩子？\n\n第一种：是全局导航钩子：router.beforeEach（to，from，next），作用：跳转前进进行判断拦截\n\n第二种：组件内的钩子\n\n第三种：单独路由独享组件\n\n\n\n## v-model 是什么？怎么使用？vue 中标签怎么绑定事件？\n\n```\n可以实现双向绑定，指令 （v-class，v-for，v-if，v-show，v-on） vue 的 model 层的 data 属性。绑定事件<input @click=del() />\n\n```\n\n## vuex 是什么？怎么使用？哪种功能场景使用它？\n\nVuex 是一个专为 Vue.js 应用程序开发的**状态管理模式**，在main.js 引入ctore，注入。新建一个目录 store、...export 场景有：单页应用中，组件之间的状态音乐播放器，登录状态，加入购物车\n\n------------------------------\n\n每一个 Vuex 应用的核心就是 store（仓库）。“store”基本上就是一个容器，它包含着你的应用中大部分的**状态 (state)**。Vuex 和单纯的全局对象有以下两点不同：\n\n1. Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。\n2. 你不能直接改变 store 中的状态。改变 store 中的状态的唯一途径就是显式地**提交 (commit) mutation**。这样使得我们可以方便地跟踪每一个状态的变化，从而让我们能够实现一些工具帮助我们更好地了解我们的应用。\n\n## 你是怎么认识 Vuex 的？\n\nVuex 可以理解为一种开发模式或框架。通过状态（数据源）集中管理驱动组件的变化。\n\n应用级的状态集中放在 store（仓库） 中，改变状态的方式是提交 mutations，这是个同步的事物，异步逻辑应该封装在 action 中\n\n![](https://zhanglong292383147.gitee.io/picture_images/picture/Mianjingxuan/Vuex是什么.jpg)\n\n- **state**，驱动应用的数据源；\n- **view**，以声明方式将 **state** 映射到视图；\n- **actions**，响应在 **view** 上的用户输入导致的状态变化。\n\n## vue-router是什么？它有哪些组件？\n\nvue用来写路由一个插件router-link，router-view\n\n\n\n## Vue的双向数据绑定原理是什么？\n\n![](https://zhanglong292383147.gitee.io/picture_images/picture/Mianjingxuan/VUE双向绑定原理.png)\n\n这里VM，就是 vue框架它相当于中间枢纽的作用，连接着 model 和 view\n\n当前台显示的 view 发生变化了，它会实时反应到 viewModel（上，如果有需要，viewModel会通过 Ajax 等方法将改变的数据传递给后台 model）\n\n同时从后台 model 获取过来的数据，通过 VM 将值响应到前台 UI 上\n\n![](https://zhanglong292383147.gitee.io/picture_images/picture/Mianjingxuan/input事件数据绑定原理.png)\n\nVM的核心是 view 和 data\n\n当 data 有变化的时候它通过 **object.defineProperty()**  方法中的 **set** 方法进行监控，并调用在此之前已经定义好 **data** 和 **view** 的关系了的回调函数，来通知 view 进行数据的改变。\n\n而 view 发生改变则是通过底层的 input 事件来进行 data 的响应更改\n\nVue 是通过 **object.defineProperty()** 来实现**数据劫持**的。（它可以来控制一个对象属性的一些特有操作，比如读写权、是否可以枚举）\n\n实现方法：观察者模式\n\nMVVM 框架类：\n\n![](https://zhanglong292383147.gitee.io/picture_images/picture/Mianjingxuan/观察者模式的MVVM框架的工作原理.png)\n\nObserver（object.defineProperty 中的 set）**监听** data 的变化，当 data **有变化**的时候**通知**观察者列表 **Dep**（里面有与 Data 变化对应的Update 函数），watcher**（监听器）** 负责向**观察者列表**（Dep）**添加**（订阅）对应的**更新函数**，Dep 里的更新函数执行了之后将*最新的值* **更新** 到 **View（视图）**上\n\n\n\n## 请详细说下你对 Vue 生命周期的理解？\n\n总共分 为 8个阶段：创建前 / 后，载入前 / 载入后，更新前 / 后，销毁前 / 后\n\n创建前 / 后：在 **beforeCreate (创建前)** 阶段，Vue实例的**挂载元素** el 和**数据对象** data 都为 **undefined**，还未初始化。在 **created (创建后)** 阶段，Vue 实例的**数据对象** data **有**了,  **el** 还**没有**。\n\n载入前 / 后：在**beforeMount** 阶段，Vue实例的 **el** 和 **data** 都**初始化**了，但还是挂载之前为虚拟的 DOM 节点，data.message 还未替换。在 **mounted** 阶段，Vue实例**挂载完成**，data.message 成功 **渲染**\n\n更新前 / 后：当 **data** 变化时，会**触发** beforeUpdate 和 updated 方法。\n\n销毁前 / 后：在执行 destroy 方法后，对 data 的改变不会再触发函数，说明此时 Vue 实例已经**解除**了**事件监听**以及和 **DOM 的绑定**，但是 dom **结构**依然**存在**\n\n```html\n<body>\n    <div id=\"app\">\n        <p>{{info}}</p>\n        <button @click=\"info='hello1'\">更新info</button>\n        <button @click=\"destroy\">销毁实例</button>\n    </div>\n    <script>\n        var vm = new Vue({\n            el: \"#app\",\n            data: {\n                info: \"hello\"\n            },\n            // 在实例初始化之后，数据观测 (data observer) 和 event/watcher 配置之前被调用。\n            beforeCreate: function () {\n                console.log(\"===============beforeCreate============================================\")\n                // $el表示Vue 实例使用的根 DOM 元素。\n                console.log('$el', this.$el);\n                // $data Vue 实例观察的数据对象\n                console.log('$data', this.$data);\n                console.log(\"info:\", this.info)\n            },\n            // 在实例创建完成后被立即调用。在这一步，实例已完成以下的配置：数据观测 (data observer)，属性和方法的运算，watch/event 事件回调。然而，挂载阶段还没开始，dom还未生成，$el 属性目前不可见。 一般都在created中发送请求\n            created: function () {\n                console.log(\"===============created=======================================\")\n                console.log('$el', this.$el);\n                console.log('$data', this.$data);\n                console.log(\"info:\", this.info)\n            },\n            // 模板编译挂载之前调用，首先会判断对象是否有el选项。如果有的话就继续向下编译，如果没有el选项，则停止编译，也就意味着停止了生命周期，直到在该vue实例上调用vm.$mount(el)。接着判断是否有template属性，有的话就以template属性中的值作为模板，如果没有的话，就以el属性指向的作为模板。这里会生成vm.$el，但指令尚未被解析\n            beforeMount: function () {\n                console.log(\"===============beforeMount=========================================\")\n                console.log('$el', this.$el);\n                console.log('$data', this.$data);\n                console.log(\"info:\", this.info)\n            },\n            // 模板编译挂载之后调用，vm.$el替换掉el指向的dom\n            mounted: function () {\n                console.log(\"===============mounted===========================================\")\n                console.log('$el', this.$el);\n                console.log('$data', this.$data);\n                console.log(\"info:\", this.info)\n            },\n            // 数据变更导致虚拟DOM重新渲染之前调用\n            beforeUpdate: function () {\n                console.log(\"===============beforeUpdate============================================\");\n\n            },\n            // 数据变更导致虚拟DOM重新渲染之后调用\n            updated: function () {\n                console.log(\"===============updated======================================================\");\n            },\n            // 实例销毁之前调用，在这一步，实例完全可用\n            beforeDestroy: function () {\n                console.log(\"===============beforeDestroy===============================================\")\n                console.log('$el', this.$el);\n                console.log('$data', this.$data);\n                console.log(\"info:\", this.info)\n            },\n            // vue实例指向的所有东西解除绑定，包括watcher、事件、所以的子组件，后续就不再受vue实例控制了\n            destroyed: function () {\n                console.log(\"===============destroyed================================================\")\n                console.log('$el', this.$el);\n                console.log('$data', this.$data);\n                console.log(\"info:\", this.info)\n            },\n            methods: {\n                destroy() {\n                    // 表示销毁组件\n                    this.$destroy()\n                },\n                udpateinfo() {\n                    this.info = 'hello2'\n                }\n            }\n        })\n    </script>\n</body>\n```\n\n\n\n## Vue 组件封装过程？\n\n首先，使用 Vue.extend() 创建一个组件\n\n然后，使用 Vue.component() 方法注册组件\n\n接着，如果子组件需要数据，可以在 props 中接受定义\n\n最后，子组件修改好数据之后，想把数据传递给父组件，可以使用 emit() 方法\n\n\n\n## Vue-loader 是什么？\n\n解析 Vue 文件的一个加载器，跟 template/js/style 转换成 JS 模块\n\n提供了一些非常酷炫的特性：\n\nES5默认可用；\n\n```\n在每个 Vue 组件内支持其他的 webpack 加载器，如用于 <style> 的 SASS 和用于<template>的 Jade\n\n把 <style>和<template>内引用的静态资源作为模块依赖项对待，并用 webpack 加载器处理。\n\n对每个组件模拟有作用域的 css\n\n开发阶段支持组件的热加载\n\n简单的说，webpack 和 vue-loader 的组合为你创作 Vue 应用一个更先进、更灵巧极其强大的前端开发模式\n```\n\n## 使用它的用途有哪些？\n\nJS 可以写 es6、style 样式可以 scss 或 less、template可以加 jade 等。\n\n\n\n## 说出至少4种Vue当中的指令和它的用法\n\nv-if：判断是否隐藏；\n\nv-for：数据循环出来；\n\nv-bind：class：绑定一个属性；\n\nv-model：实现双向绑定\n\n\n\n## 自定义指令（v-check、v-focus）的方法有哪些？它有哪些钩子函数？还有哪些钩子函数参数？\n\n全局定义指令：在 Vue 对象的 driective 方法里面有两个参数，一个是指令名称，另一个是函数。组件内定义指令：directives；\n\n钩子函数：bind（绑定事件触发），inserted（节点插入的时候触发）、update（组件内相关更新）\n\n钩子函数参数：el ， binding\n\n\n\n理解 Vue 自定义指令钩子函数：\n\n一个指令定义对象可以提供如下几个钩子函数（均为可选）：\n\nbind：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置\n\ninserted：被绑定元素插入父节点时调用（仅保证父节点存在，但不一定已被插入文档中）\n\nupdate：所在组件的 VNode 更新时调用，但是可能发生在其子 VNode 更新之前。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新\n\ncomponentUpdated：指令所在组件的 VNode 及其子 VNode 全部更新后调用。\n\nconbind：只调用一次，指令与元素解绑时调用。\n\n\n\n指令钩子函数会被传入以下参数：\n\nel：指令所绑定的元素，可以用来直接操作 DOM\n\nbinding：一个对象，包含以下属性：\n\nname：指令名，不包含 v-前缀\n\nvalue：指令的绑定值，例如：v-my-directive=“ 1 + 1” 中，绑定值为2\n\noldValue：指令绑定的前一个值，仅在 Update 和 compnentUpated 钩子中可用。无论值是否改变都可用\n\nexpression：字符串形式的指令表达式。例如 v-my-directive=“ 1 + 1 ” 中，表达式为“1+1”\n\navg：传给指令的参数，可选。例如：v-my-directive：foo 中，参数为 “foo”\n\nmodifiers：一个包含修饰符的对象。例如：v-my-directive.foo.bar 中，修饰符对象为 { foo：true，bar：true }\n\nvnode：Vue 编译生成的虚拟节点。移步 VNode API 来了解更多详情\n\noldVnode：上一个虚拟节点，仅在 update 和 componentUpdated 钩子中可用。\n\n\n\n## axios是什么？怎么使用？描述使用它实现登录功能的流程？\n\n1. 请求后台资源的模块。 npm i axios -s 装好\n2. 然后发送的是跨域，需在配置文件中 config/index.js 进行设置\n3. 后台如果是TP5 则定义一个资源路由。JS 使用import 进来，\n4. 然后 .get 或 .post 返回在 .this 函数中如果成功\n5. 失则则是在 .catch 函数中\n\n\n\n## axios + tp5 进价中，调用 axios.post(' api/user ') 是进行的什么操作？axios.put('api/8') 呢？\n\n跨域，添加用户操作，更新操作。\n\n\n\n## 请说下具体使用 Vue 的理解？\n\n1. 使用 Vue 不必担心布局更改和类名重复导致的 JS 重写，因为它是靠数据驱动双向绑定，底层是通过 Object.defineProperty() 定义的数据，set、get 函数原理实现。\n2. 组件化开发，让项目的可拓展性、移植性更好，代码重用性更高，就好像农民工建房子，拿起自己的工具包就可以开工。项目经理坐等收楼就好。\n3. 单页应用的体验零距离接触安卓原生应用，局部组件更新界面，让用户体验更快速省时。\n4. JS 的代码无形的规范，团队合作开发代码可阅读性更高。\n\n\n\n## 你觉得哪些项目适合 Vue 框架？\n\n1. 数据信息量比较多的，反之类似企业网站就无需此框架了\n2. 手机 web 和 app 应用多端共用一套界面的项目，因为使用 Vue.cli + webpack 后的前端目录，非常有利于项目的跨平台部署。\n\n\n\n## Vue 组件之间如何通信？\n\n作为一个vue初学者不得不了解的就是组件间的数据通信(暂且不谈vuex)。通信方式根据组件之间的关系有不同之处。组件关系有下面三种：**父-->子**、**子-->父**、**非父子**\n\n#### 父-->子\n\n父向子传递数据通过props\n\n```javascript\n//父组件代码\n<template>\n    <header-box :title-txt=\"showTitleTxt\"></header-box>\n</template>\n<script>\n    import Header from './header'\n    export default {\n        name: 'index',\n        components: {\n            'header-box': Header\n        },\n        data () {\n            return {\n                showTitleTxt: '首页'\n            }\n        }\n    }\n</script>\n```\n\n```javascript\n//子组件代码\n<template>\n    <header>\n        {{thisTitleTxt}}\n    </header>\n</template>\n<script>\n    export default {\n        name: 'header-box',\n        props: {\n            titleTxt: String\n        },\n        data () {\n            return {\n                thisTitleTxt: this.titleTxt\n            }\n        }\n    }\n</script>\n```\n\n#### 子-->父\n\n> 子组件向父组件传递分为两种类型。\n> 1、子组件改变父组件传递的props（你会发现通过props中的Object类型参数传输数据，可以通过子组件改变数据内容。这种方式是可行的，但是不推荐使用，因为官方定义prop是单向绑定）\n> 2、通过$on和$emit\n\n```javascript\n//通过props实现传递\n//父组件代码\n<template>\n    <header-box :title-txt=\"showTitleTxt\"></header-box>\n</template>\n<script>\n    import Header from './header'\n    export default {\n        name: 'index',\n        components: {\n            'header-box': Header\n        },\n        data () {\n            return {\n                showTitleTxt: {\n                    name: '首页'\n                }\n            }\n        }\n    }\n</script>\n```\n\n```javascript\n//子组件代码\n<template>\n    <header @click=\"changeTitleTxt\">\n        {{thisTitleTxt.name}}\n    </header>\n</template>\n<script>\n    export default {\n        name: 'header-box',\n        props: {\n            titleTxt: Object\n        },\n        data () {\n            return {\n                thisTitleTxt: this.titleTxt.name\n            }\n        },\n        metheds: {\n            changeTitleTxt () {\n                this.titleTxt.name = '切换'\n            }\n        }\n    }\n</script>\n```\n\n```javascript\n//通过$on,$emit\n//父组件代码\n<template>\n    <div id=\"counter-event-example\">\n      <p>{{ total }}</p>\n      <button-counter v-on:increment=\"incrementTotal\"></button-counter>\n</div>\n</template>\n<script>\n    import ButtonCounter from './buttonCounter'\n    export default {\n        name: 'index',\n        components: {\n            'button-conuter': ButtonCounter\n        },\n        data () {\n            return {\n                total: 0\n            }\n        },\n        methods: {\n            incrementTotal () {\n                this.total++\n            }\n        }\n    }\n</script>\n```\n\n```javascript\n//子组件代码\n<template>\n    <button @click=\"incrementCounter\">{{counter}}</button>\n</template>\n<script>\n    export default {\n        name: 'button-counter',\n        data () {\n            return {\n                counter: 0\n            }\n        },\n        metheds: {\n            incrementCounter () {\n                this.$emit('increment')\n                this.counter++\n            }\n        }\n    }\n</script>\n```\n\n#### 非父子\n\n> 简单情况下我们可以通过使用一个空的Vue实例作为中央事件总线，（这里也可以使用app实例，而不需要新建一个空Vue实例）\n\n```javascript\n//main.js\nlet bus = new Vue()\nVue.prototype.bus = bus\n```\n\n或者\n\n```js\n//main.js\nnew Vue({\n  el: '#app',\n  router,\n  template: '<App/>',\n  components: { App },\n  beforeCreate () {\n    Vue.prototype.bus = this\n  }\n})\n```\n\n```js\n//header组件\n<template>\n    <header @click=\"changeTitle\">{{title}}</header>\n</template>\n<script>\nexport default {\n    name: 'header',\n    data () {\n        return {\n            title: '头部'\n        }\n    },\n    methods: {\n        changeTitle () {\n            this.bus.$emit('toChangeTitle','首页')\n        }\n    }\n}\n</script>\n```\n\n```js\n//footer组件\n<template>\n    <footer>{{txt}}</footer>\n</template>\n<script>\nexport default {\n    name: 'footer',\n    mounted () {\n        this.bus.$on('toChangeTitle', function (title) {\n            console.log(title)\n        })\n    },\n    data () {\n        return {\n            txt: '尾部'\n        }\n    }\n}\n```\n\n\n\n## 关于vue在app首次加载缓慢的解决办法？\n\n*1.路由懒加载*\n\n![img](https:////upload-images.jianshu.io/upload_images/12205285-7190dce75d2c6b60.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/513/format/webp)\n\n​\t\t\t\t\t\t\t\t\t\t\t路由懒加载\n\n此方法会把原本打包到一个app.js文件分开成多个js文件打包，这样会减小单个文件的大小，但是不会减小整个js文件夹的大小。通过这种方式可以做到按需加载，只加载单个页面的js文件。\n\n*2.组件异步加载*\n\n![img](https:////upload-images.jianshu.io/upload_images/12205285-9aa4e5728fa3dce2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/372/format/webp)\n\n组件异步加载\n\n加载首页的时候，可以先给首页的子组件设置v-if = “false”，在页面初始化的时候再给子组件设置为true，此方法利用了v-if的惰性，setTimeout会使子组件在所有的组件初始化完成并显示后再对其子组件进行初始化。\n\n- [x] **注：在实际开发中还遇到了另一种情况也可以用此方法解决，在入口js中获取了app的token，但是在具体页面中发现不管是在created还是mounted中都是有时候能获取到token，有时候又不可以，是因为执行顺序的原因，可以通过 setTimeout 时间设置为0 这种方法把用到token的请求方法给排到最后，这样就能保证请求方法中有token了。**\n\n*3.使用异步组件，按需加载*\n\nnewVue({\n\n// ...\n\n  components: {\n\n​        'my-component':()=>import('./my-async-component')\n\n  }\n\n})\n\nes6的写法，`import` 函数会返回一个 `Promise` 对象。这样就实现了组件的按需加载，有需要的时候才会加载这个组件，同样也是优化首屏加载速度的一种方法。\n\n下面两张图片就可以清晰的了解 import xxx from \"./xxx.vue\" 与 import()方法 的不同，以及用import函数所带来的好处。\n\n\n\n\n\n![img](https:////upload-images.jianshu.io/upload_images/12205285-e3630781a7ba92e2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/656/format/webp)\n\n  import xxx from \"./xxx.vue\"  \n\n![img](https:////upload-images.jianshu.io/upload_images/12205285-fdb9ddf46f9da18e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/677/format/webp)\n\n   import()方法\n\n上面是两种方法，打包后所生成的文件，import函数的方法很明显多了几个js，这就是从原本 app.js 中分离出来的0.js，1.js，2.js。第一张图，在运行的时候会把app.js整个加载完，而第二张图会加载0.js+app.js，虽然多了一个文件，但实际上，后者整体加载的文件大小要比原本小很多。这就是按需加载，在需要1.js的时候才会加载它，而且加载过一次后就会缓存在本地，下次加载，会取缓存的文件。\n\n而且，因为import函数返回的是一个promise对象，因此可以用promise本身的then()和catch()方法去监听到组件的加载，如：\n\n![img](https:////upload-images.jianshu.io/upload_images/12205285-85fff817aae7b673.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/393/format/webp)\n\n*4.图片量多的时候可以进行分批的加载*\n\nvue-lazyload插件，图片懒加载\n\n*5.外部引入一些插件，不要在vue中引入*\n\n列入，我在次项目中有用到moment.js这个插件，在vue内部引入后打包的项目大小要比在外部用src的方式引入打包的项目大个300k左右。\n\n首先，下载好moment.min.js包，然后在vue项目的webpack.base.conf.js中添加下图箭头所指向的那段代码\n\n![img](https:////upload-images.jianshu.io/upload_images/12205285-96a1a056b87bd667.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/439/format/webp)\n\n加上上图的代码后是不会将moment.js给打包到js中的。\n\n","slug":"mianshi/面试题精选","published":1,"date":"2019-02-25T04:45:27.498Z","updated":"2019-03-09T16:11:21.979Z","comments":1,"photos":[],"link":"","_id":"cjt1pka8100079gnpwd7zbk3w","content":"<p>#面试题精选</p>\n<h2 id=\"数组去重怎么实现？\"><a href=\"#数组去重怎么实现？\" class=\"headerlink\" title=\"数组去重怎么实现？\"></a>数组去重怎么实现？</h2><p>1、可以使用for循环去重</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">* 新建一新数组，遍历传入数组，值不在新数组就push进该新数组中</span></span><br><span class=\"line\"><span class=\"comment\">* IE8以下不支持数组的indexOf方法</span></span><br><span class=\"line\"><span class=\"comment\">* */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">uniq</span>(<span class=\"params\">array</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> temp = []; <span class=\"comment\">//一个新的临时数组</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; array.length; i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(temp.indexOf(array[i]) == <span class=\"number\">-1</span>)&#123;</span><br><span class=\"line\">            temp.push(array[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> temp;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> aa = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">2</span>,<span class=\"number\">4</span>,<span class=\"number\">9</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>,<span class=\"number\">5</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">5</span>];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(uniq(aa));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//优化遍历数组法</span></span><br><span class=\"line\"><span class=\"comment\">// 思路：获取没重复的最右一值放入新数组</span></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">* 推荐的方法 *</span></span><br><span class=\"line\"><span class=\"comment\">* 方法的实现代码相当酷炫，</span></span><br><span class=\"line\"><span class=\"comment\">* 实现思路：获取没重复的最右一值放入新数组。</span></span><br><span class=\"line\"><span class=\"comment\">* （检测到有重复值时终止当前循环同时进入顶层循环的下一轮判断）*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">uniq</span>(<span class=\"params\">array</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> temp = [];</span><br><span class=\"line\">    <span class=\"keyword\">var</span> index = [];</span><br><span class=\"line\">    <span class=\"keyword\">var</span> l = array.length;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; l; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> j = i + <span class=\"number\">1</span>; j &lt; l; j++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (array[i] === array[j])&#123;</span><br><span class=\"line\">                i++;</span><br><span class=\"line\">                j = i;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        temp.push(array[i]);</span><br><span class=\"line\">        index.push(i);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(index);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> temp;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> aa = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">5</span>,<span class=\"number\">3</span>,<span class=\"number\">6</span>,<span class=\"number\">5</span>];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(uniq(aa));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//对象键值法去重</span></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">* 速度最快， 占空间最多（空间换时间）</span></span><br><span class=\"line\"><span class=\"comment\">* 该方法执行的速度比其他任何方法都快， 就是占用的内存大一些。</span></span><br><span class=\"line\"><span class=\"comment\">* 现思路：新建一js对象以及新数组，遍历传入数组时，判断值是否为js对象的键，</span></span><br><span class=\"line\"><span class=\"comment\">* 不是的话给对象新增该键并放入新数组。</span></span><br><span class=\"line\"><span class=\"comment\">* 注意点：判断是否为js对象键时，会自动对传入的键执行“toString()”，</span></span><br><span class=\"line\"><span class=\"comment\">* 不同的键可能会被误认为一样，例如n[val]-- n[1]、n[\"1\"]；</span></span><br><span class=\"line\"><span class=\"comment\">* 解决上述问题还是得调用“indexOf”。*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">uniq</span>(<span class=\"params\">array</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> temp = &#123;&#125;, r = [], len = array.length, val, type;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">        val = array[i];</span><br><span class=\"line\">        type = <span class=\"keyword\">typeof</span> val;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!temp[val]) &#123;</span><br><span class=\"line\">            temp[val] = [type];</span><br><span class=\"line\">            r.push(val);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (temp[val].indexOf(type) &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            temp[val].push(type);</span><br><span class=\"line\">            r.push(val);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> r;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> aa = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"string\">\"2\"</span>,<span class=\"number\">4</span>,<span class=\"number\">9</span>,<span class=\"string\">\"a\"</span>,<span class=\"string\">\"a\"</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">5</span>];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(uniq(aa));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//数组下标法</span></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">* 还是得调用“indexOf”性能跟方法1差不多，</span></span><br><span class=\"line\"><span class=\"comment\">* 实现思路：如果当前数组的第i项在当前数组中第一次出现的位置不是i，</span></span><br><span class=\"line\"><span class=\"comment\">* 那么表示第i项是重复的，忽略掉。否则存入结果数组。</span></span><br><span class=\"line\"><span class=\"comment\">* */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">uniq</span>(<span class=\"params\">array</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> temp = [];</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; array.length; i++) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//如果当前数组的第i项在当前数组中第一次出现的位置是i，才存入数组；否则代表是重复的</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(array.indexOf(array[i]) == i)&#123;</span><br><span class=\"line\">            temp.push(array[i])</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> temp;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> aa = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"string\">\"2\"</span>,<span class=\"number\">4</span>,<span class=\"number\">9</span>,<span class=\"string\">\"a\"</span>,<span class=\"string\">\"a\"</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">5</span>];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(uniq(aa));</span><br></pre></td></tr></table></figure>\n<p>2、利用hash表去重</p>\n<p>3、先排序后去重</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//排序后相邻去除法</span></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">* 给传入数组排序，排序后相同值相邻，</span></span><br><span class=\"line\"><span class=\"comment\">* 然后遍历时,新数组只加入不与前一值重复的值。</span></span><br><span class=\"line\"><span class=\"comment\">* 会打乱原来数组的顺序</span></span><br><span class=\"line\"><span class=\"comment\">* */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">uniq</span>(<span class=\"params\">array</span>)</span>&#123;</span><br><span class=\"line\">    array.sort();</span><br><span class=\"line\">    <span class=\"keyword\">var</span> temp=[array[<span class=\"number\">0</span>]];</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">1</span>; i &lt; array.length; i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>( array[i] !== temp[temp.length<span class=\"number\">-1</span>])&#123;</span><br><span class=\"line\">            temp.push(array[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> temp;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> aa = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"string\">\"2\"</span>,<span class=\"number\">4</span>,<span class=\"number\">9</span>,<span class=\"string\">\"a\"</span>,<span class=\"string\">\"a\"</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">5</span>];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(uniq(aa));</span><br></pre></td></tr></table></figure>\n<p>4、Set方式去重</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> removeDuplicateItems = <span class=\"function\"><span class=\"params\">arr</span> =&gt;</span> [...new <span class=\"built_in\">Set</span>(arr)]; <span class=\"built_in\">console</span>.log(removeDuplicateItems([<span class=\"number\">42</span>, <span class=\"string\">'foo'</span>, <span class=\"number\">42</span>, <span class=\"string\">'foo'</span>, <span class=\"literal\">true</span>, <span class=\"literal\">true</span>])); <span class=\"comment\">// =&gt; [42, \"foo\", true]</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"Javascript-基础数据类型？\"><a href=\"#Javascript-基础数据类型？\" class=\"headerlink\" title=\"Javascript 基础数据类型？\"></a>Javascript 基础数据类型？</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">number(数值)</span><br><span class=\"line\">string(字符串)</span><br><span class=\"line\">Boolean(布尔)</span><br><span class=\"line\">null(空)</span><br><span class=\"line\">undefined(未定义)</span><br><span class=\"line\">引用类型有：object</span><br></pre></td></tr></table></figure>\n<h2 id=\"谈一谈Javascript作用域链？\"><a href=\"#谈一谈Javascript作用域链？\" class=\"headerlink\" title=\"谈一谈Javascript作用域链？\"></a>谈一谈Javascript作用域链？</h2><p>当执行一段JS代码(全局代码或函数)时，JS引擎会创建一个作用域又称为执行上下文，在页面加载后会首先创建一个全局的作用域，然后每执行一个函数，会建立一个对应的作用域，从而形成了一条作用域链。每个作用域都有一条对应的作用域链，链头是全局作用域，链尾是当前函数作用域。</p>\n<p>作用域链作用是用于解析标识符，当函数被创建时（不是执行），会将this.arguments、命名参数和该函数中的所有局部变量添加到该当前作用域中，当JS需要查找变量X的时候，这个过程称为变量解析，它首先会直到查找到链头，也就是全局作用域链，仍未找到该变量的话，就认为这段代码的作用域上不存在X变量，并抛出引用错误的异常。</p>\n<h2 id=\"如何理解JS原型链？\"><a href=\"#如何理解JS原型链？\" class=\"headerlink\" title=\"如何理解JS原型链？\"></a>如何理解JS原型链？</h2><p>JS中的每一个prototype属性，我们称之为原型，而原型的值也是对象，因此它也有自己的原型，这样就串联起来了一条原型链，原型链的链头是object，它的prototype比较特殊，值为null。</p>\n<p>原型链的作用是用于对象继承，函数A的原型属性是一个对象，当这个函数被用作构造函数来创建实例时，该函数的原型属性将被作为原型赋值给所有对象实例，比如我们新建一个数组，数组的方法便从数组的原型上继承而来。</p>\n<p>当访问对象的一个属性时，首先查找对象本身，找到则返回；若未找到，则继续查找其原型对象的属性（如果还找不到实际上会沿着原型链向上查找，直到根），只要没有被覆盖的话，对象原型的属性就能在所有的实例中找到，若整个原型链未找到则返回undefined.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">总结：</span><br><span class=\"line\"></span><br><span class=\"line\">1、每个函数对象都有一个 prototype 属性， 这个属性就是函数的原型对象</span><br><span class=\"line\"></span><br><span class=\"line\">2、原型链式 JavaScript 实现继承的重要方式，原型链的形成是真正是靠__proto__而非prototype</span><br></pre></td></tr></table></figure>\n<h2 id=\"（重点）如何理解和应用JS闭包？\"><a href=\"#（重点）如何理解和应用JS闭包？\" class=\"headerlink\" title=\"（重点）如何理解和应用JS闭包？\"></a>（重点）如何理解和应用JS闭包？</h2><p>简单的理解是函数的嵌套形成闭包，闭包包括函数本身以及它的外部作用域，函数a内嵌套b，且返回b，当调用函数a时，用变量接收函数b，就形成了闭包。</p>\n<p>优点：</p>\n<p>① 减少全局变量。</p>\n<p>② 减少传递函数的参数量</p>\n<p>③ 封装</p>\n<p>缺点：延长了作用域链，需要释放的变量不能及时释放，可能引发内存泄漏，其实说白了就是该内存空间使用完毕之后未回收，即所谓内存泄漏，最终，结果是程序运行时间越长，占用存储空间越来越多，最终用尽全部存储空间，整个系统崩溃。(<strong>使用闭包会占有内存资源，过多的使用闭包会导致内存溢出等.</strong>)</p>\n<p>最简洁、直击要害的回答，我能想到的分别有这么三句</p>\n<p><strong>1、闭包是一个有状态</strong>（不消失的私有数据）<strong>的函数。</strong></p>\n<p><strong>2、闭包是一个有记忆的函数。</strong></p>\n<p><strong>3、闭包相当于一个只有一个方法的紧凑对象</strong>（a compact object）。 </p>\n<p><strong>通俗的讲：就是函数a的内部函数b，被函数a外部的一个变量引用的时候，就创建了一个闭包。</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//这样在执行完var c=a()后，变量c实际上是指向了函数b，再执行c()后就会弹出一个窗口显示i的值(第一次为1)。这段代码其实就创建了一个闭包，为什么？因为函数a外的变量c引用了函数a内的函数b</span></span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">a</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">           <span class=\"keyword\">var</span> i=<span class=\"number\">0</span>;</span><br><span class=\"line\">           <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">b</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">              alert(++i);</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">              <span class=\"keyword\">return</span> b;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"keyword\">var</span> c = a();</span><br><span class=\"line\">        c();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 更容易理解的闭包</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f1</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> num = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 定义内部函数</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f2</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> num + <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 返回 f2函数引用</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> f2;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// bar 变量也指向 f2 函数，在此也是一个闭包</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> bar = f1();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 执行</span></span><br><span class=\"line\">bar();  <span class=\"comment\">//1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 我们知道，函数中的变量会随着函数的执行完毕后会被销毁。而如上的代码，f1() 函数执行完毕后，将 f2 函数赋值给一个全局变量，而 f2 函数的变量又依赖 f1 的 num 变量，因此，f1中的 num 变量并不会随着 f1 的函数执行完毕后而销毁</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"Javascript代理？\"><a href=\"#Javascript代理？\" class=\"headerlink\" title=\"Javascript代理？\"></a>Javascript代理？</h2><p>当我们需要对很多元素添加事件的时候，可以通过将事件添加到它们的父节点而将事件委托给父节点来触发处理函数。</p>\n<h2 id=\"HTML5有哪些新特性？移除了哪些元素？如何处理HTML5新标签的浏览兼容问题？如何区别HTML和HTML5？\"><a href=\"#HTML5有哪些新特性？移除了哪些元素？如何处理HTML5新标签的浏览兼容问题？如何区别HTML和HTML5？\" class=\"headerlink\" title=\"HTML5有哪些新特性？移除了哪些元素？如何处理HTML5新标签的浏览兼容问题？如何区别HTML和HTML5？\"></a>HTML5有哪些新特性？移除了哪些元素？如何处理HTML5新标签的浏览兼容问题？如何区别HTML和HTML5？</h2><p>1、HTML5现在已经不是SGML的子集，主要是关于图像，位置，存储，多任务等功能的增加；</p>\n<p>2、用于媒介回放的 <em>video</em> 和 <em>audio</em> 元素</p>\n<p>3、本地离线存储localStorge长期存储数据，浏览器关闭后数据不会丢失。</p>\n<p>4、语义化更好的内容元素，比如article、footer、header、nav、section</p>\n<p>5、新的技术webworker、websockt、geolocation移除的元素</p>\n<p>6、对可用性产生负面影响的元素：frame、frameset、noframes，支持HTML5标签</p>\n<p>7、IE8/IE7/IE6支持通过docment.createElement 方法产生的标签</p>\n<p>8、浏览器支持新标签后，还需要添加标签默认的样式</p>\n<h2 id=\"CSS隐藏元素的几种方法？\"><a href=\"#CSS隐藏元素的几种方法？\" class=\"headerlink\" title=\"CSS隐藏元素的几种方法？\"></a>CSS隐藏元素的几种方法？</h2><p>1、opacity： 透明度</p>\n<p>2、visibility： 可见的</p>\n<p>3、display： 显示</p>\n<p>4、position： 位置</p>\n<h2 id=\"重点-性能优化的方法？\"><a href=\"#重点-性能优化的方法？\" class=\"headerlink\" title=\"(重点) 性能优化的方法？\"></a>(重点) 性能优化的方法？</h2><p>1、减小http请求：css Sprites，JS，css源码压缩，图片大小控制合适；网页Gzip，CDN托管，data缓存，图片服务器</p>\n<p>2、用innerHTML代替DOM操作，减小DOM操作次数，优化Javascript性能</p>\n<p>3、避免使用CSS Expression（CSS表达式）又称Dynamic properties（动态属性）</p>\n<p>4、当需要设置的样式很多时设置 className 而不是直接操作style</p>\n<p>5、图片预加载，将样式表放在顶部，将脚本放在底部加上时间戳</p>\n<h2 id=\"一个页面从输入URL到页面加载显示完成，这个过程中都发生了什么？\"><a href=\"#一个页面从输入URL到页面加载显示完成，这个过程中都发生了什么？\" class=\"headerlink\" title=\"一个页面从输入URL到页面加载显示完成，这个过程中都发生了什么？\"></a>一个页面从输入URL到页面加载显示完成，这个过程中都发生了什么？</h2><p>4个步骤：</p>\n<p>1、当发送一个URL请求时，不管这个URL是web页面的URL还是web页面上每个资源的URL，浏览器都会开启一个线程来处理这个请求，同时在远程DNS服务器上启动一个DNS查询，这能使浏览器获取请求对应的IP地址</p>\n<p>2、浏览器与远程web服务器通过TCP三次握手协商来建立一个TCP/IP 连接。该握手包括一个同步报文，一个同步-应答报文和一个应答报文，这三个报文在浏览器和服务器之间传递。该握手首先由服务端尝试建立起通信，而后服务器应答并接受客户端的请求，最后由客户端发出该请求已经被接受的报文。</p>\n<p>3、一旦TCP/IP 连接建立，浏览器会通过该连接向远程服务器发送HTTP和GET请求。远程服务器找到资源并使用HTTP响应返回该资源，值为200 的 HTTP 响应状态表示一个正确的响应</p>\n<p>4、此时，web服务器提供资源服务，客户端开始下载资源。</p>\n<h4 id=\"简洁版\"><a href=\"#简洁版\" class=\"headerlink\" title=\"简洁版\"></a>简洁版</h4><p><em>浏览器根据请求的URL交给DNS域名解析，找到真实的IP，向服务器发起请求；</em></p>\n<p><em>服务器交给后台处理完成后返回数据，浏览器接收文件(HTML，JS，CSS，图像等等)；</em></p>\n<p><em>浏览器对加载到的资源进行语法解析，建立相应的内部数据结构；</em></p>\n<p><em>载入解析到的资源文件，渲染页面，完成。</em></p>\n<h2 id=\"Javascript对象的几种创建方法？\"><a href=\"#Javascript对象的几种创建方法？\" class=\"headerlink\" title=\"Javascript对象的几种创建方法？\"></a>Javascript对象的几种创建方法？</h2><p>1、工厂模式</p>\n<p>2、构造函数模式</p>\n<p>3、原型模式</p>\n<p>4、混合构造函数和原型模式</p>\n<p>5、动态原型模式</p>\n<p>6、寄生构造函数模式</p>\n<p>7、稳妥构造函数模式</p>\n<h2 id=\"Javascript继承的6种方法？\"><a href=\"#Javascript继承的6种方法？\" class=\"headerlink\" title=\"Javascript继承的6种方法？\"></a>Javascript继承的6种方法？</h2><p>1、原型链继承</p>\n<p>2、借用构造函数继承</p>\n<p>3、组合继承（原型 + 借用构造）</p>\n<p>4、原型式继承</p>\n<p>5、寄生式继承</p>\n<p>6、寄生组合式继承</p>\n<h2 id=\"AJAX过程？\"><a href=\"#AJAX过程？\" class=\"headerlink\" title=\"AJAX过程？\"></a>AJAX过程？</h2><p>1#   创建XMLHttpRequest 对象，也就是创建一个异步调用对象</p>\n<p>2#  创建一个新的 HTTP 请求，并指定该 HTTP 请求的方法， URL 及验证信息</p>\n<p>3#  设置响应 HTTP 请求状态变化的函数</p>\n<p>4#  发送HTTP请求</p>\n<p>5#  获取异步调用返回的数据</p>\n<p>6#  使用 Javascript 和 DOM 实现局部刷新</p>\n<p>另一个说法：</p>\n<p>1、服务器获得请求参数</p>\n<p>2、服务器处理请求参数（添加，查询等操作）</p>\n<p>3、服务器响应数据给浏览器</p>\n<p>AJAX 引擎获得服务端响应的数据，通过执行JS的回调函数将数据传递给浏览器页面</p>\n<p>1、通过设置而给Ajax引擎的回调函数获得服务器响应的数据</p>\n<p>2、使用JS在指定的位置，显示响应数据，从而局部修改页面的数据，达到局部刷新目的。</p>\n<h2 id=\"JSONP原理是什么？\"><a href=\"#JSONP原理是什么？\" class=\"headerlink\" title=\"JSONP原理是什么？\"></a>JSONP原理是什么？</h2><p>首先客户端注册一个callback，然后callback的名字传给服务器。此时，服务器生成 json 数据，然后以 JS 方法的方式，生成 function，function 名字就是传递上来带参数jsonp。最后将 json 数据直接以入参的方式，放置 function 中，这样就生成JS语法的文档，返回给客户端，客户端浏览器，解析script 变迁，并执行返回JS文档，此时数据作为参数，传入了客户端预先定义好的 callback 函数里。简单地说，就是利用script 标签没有跨域限制的 “漏洞” 来达到与第三方通讯的目的。</p>\n<p>json是一种数据格式，jsonp是一种数据调用的方式，带 callback 的 json 就是 jsonp</p>\n<h2 id=\"JSONP的缺点？\"><a href=\"#JSONP的缺点？\" class=\"headerlink\" title=\"JSONP的缺点？\"></a>JSONP的缺点？</h2><p>jsonp有个缺陷就是只能get</p>\n<p>而且会把请求的内容发送到url中导致安全性极低</p>\n<h2 id=\"移动端性能优化？\"><a href=\"#移动端性能优化？\" class=\"headerlink\" title=\"移动端性能优化？\"></a>移动端性能优化？</h2><p>尽量使用CSS动画，开启硬件加速。适应使用 touch 事件代替 click 事件。避免使用 CSS3 渐变阴影效果。</p>\n<p>尽可能少的使用 box-shadow（阴影） 与 gradients（渐变）。box-shadow 与 gradients 往往都是页面的性能杀手。</p>\n<h2 id=\"说说你this的理解？\"><a href=\"#说说你this的理解？\" class=\"headerlink\" title=\"说说你this的理解？\"></a>说说你this的理解？</h2><p>在JS中，this通常指向的是我们正在执行的函数本身，或者是指向该函数所属的对象。</p>\n<p>1、普通函数中 this 是window</p>\n<p>2、构造函数中 this 是当前的实例对象</p>\n<p>3、对象中的 this 是指其本身</p>\n<p>4、原型对象的方法中 this 是当前的实例对象</p>\n<p>5、计时器中 this 是 window</p>\n<p>6、事件处理函数，this 是触发该事件的对象</p>\n<h2 id=\"如何编写高性能的JS？\"><a href=\"#如何编写高性能的JS？\" class=\"headerlink\" title=\"如何编写高性能的JS？\"></a>如何编写高性能的JS？</h2><p>1、使用 DocumentFragment 优化多次 append</p>\n<p>2、通过模板元素clone，替代 createElement</p>\n<p>3、使用一次innerHTML 赋值代构建 DOM 元素</p>\n<p>4、使用 firstChild 和 nextSibling 代替 childNods 遍历 DOM 元素</p>\n<p>5、使用 Array 作为 StringBuffter ，代替字符串拼接的操作</p>\n<p>6、将循环控制量保存到局部变量</p>\n<p>7、顺序无关的遍历时，用 while 代替 for</p>\n<p>8、将条件分支，按可能性顺序从到低排列</p>\n<p>9、在同一条件子的多（&gt; 2）条件分支时，使用 switch 优于 if</p>\n<p>10、在使用三目运算符替代条件分支</p>\n<p>11、需要不断执行的时间后，优先考虑使用 setInterval</p>\n<h2 id=\"哪些操作会造成内存泄漏？\"><a href=\"#哪些操作会造成内存泄漏？\" class=\"headerlink\" title=\"哪些操作会造成内存泄漏？\"></a>哪些操作会造成内存泄漏？</h2><p>所谓的内存泄漏，就是在您不再拥有或需要它的时候，仍然存在</p>\n<p>垃圾回收机制会定期扫描对象，并计算引用了每个对象的其他对象的数量，如果一个对象的没有被其他对象引用过，或该对象的唯一引用是循环的，那么该对象内存即可回收。</p>\n<p>1、setTimeout 的第一个参数使用字符串而非函数的话， 会引发内泄漏</p>\n<p>2、闭包</p>\n<p>3、控制台日志</p>\n<p>4、循环（在两个对象彼此引用且彼此保留时，就会产生一个循环）</p>\n<h2 id=\"ES6更新了哪些新特性？\"><a href=\"#ES6更新了哪些新特性？\" class=\"headerlink\" title=\"ES6更新了哪些新特性？\"></a>ES6更新了哪些新特性？</h2><ol>\n<li><p><strong>默认参数</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//ES5我们这样定义默认参数</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> link = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">height, color, url</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> height = height || <span class=\"number\">50</span>;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> color = color || <span class=\"string\">'red'</span>;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> url = url || <span class=\"string\">'http://azat.co'</span>;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样做是有一点小问题的，当默认参数为0时就暴露问题了，因为在JavaScript中，0表示false。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ES6可以默认值写在函数声明里</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> link = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">height = <span class=\"number\">50</span>, color = <span class=\"string\">'red'</span>, url = <span class=\"string\">'http://azat.co'</span></span>) </span>&#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<ol start=\"2\">\n<li><p><strong>模板文本</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ES5的字符串拼接</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> name = <span class=\"string\">'Your name is '</span> + first + <span class=\"string\">' '</span> + last + <span class=\"string\">'.'</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> url = <span class=\"string\">'http://localhost:3000/api/messages/'</span> + id;</span><br></pre></td></tr></table></figure>\n<p>ES6的字符串远不用如此麻烦，我们可以在反引号（~符的unshift键）中使用新语法 <strong>${变量名称}</strong> 表示。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ES6</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> name = <span class=\"string\">`Your name is <span class=\"subst\">$&#123;first&#125;</span> <span class=\"subst\">$&#123;last&#125;</span>. `</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> url = <span class=\"string\">`http://localhost:3000/api/messages/<span class=\"subst\">$&#123;id&#125;</span>`</span>;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>多行字符串</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ES5 多行字符串需要 + 号连接</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> roadPoem = <span class=\"string\">'Then took the other, as just as fair,nt'</span></span><br><span class=\"line\">    + <span class=\"string\">'And having perhaps the better claimnt'</span></span><br><span class=\"line\">    + <span class=\"string\">'Because it was grassy and wanted wear,nt'</span></span><br><span class=\"line\">    + <span class=\"string\">'Though as for that the passing therent'</span></span><br><span class=\"line\">    + <span class=\"string\">'Had worn them really about the same,nt'</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> fourAgreements = <span class=\"string\">'You have the right to be you.n</span></span><br><span class=\"line\"><span class=\"string\">    You can only be you when you do your best.'</span>;</span><br></pre></td></tr></table></figure>\n<p>然而在ES6中，仅仅用反引号就可以解决了：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> roadPoem = <span class=\"string\">`Then took the other, as just as fair,</span></span><br><span class=\"line\"><span class=\"string\">    And having perhaps the better claim</span></span><br><span class=\"line\"><span class=\"string\">    Because it was grassy and wanted wear,</span></span><br><span class=\"line\"><span class=\"string\">    Though as for that the passing there</span></span><br><span class=\"line\"><span class=\"string\">    Had worn them really about the same,`</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> fourAgreements = <span class=\"string\">`You have the right to be you.</span></span><br><span class=\"line\"><span class=\"string\">    You can only be you when you do your best.`</span>;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<ol start=\"4\">\n<li><p><strong>解构赋值</strong></p>\n<p>这是一个比较难掌握的知识点，我们先用比较简单的例子切入。</p>\n<p>下面这些情况都是很常见的：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//ES5中获取data对象中的属性</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> data = response.data,    <span class=\"comment\">// data has properties info and imageLink </span></span><br><span class=\"line\">    info = data.info,</span><br><span class=\"line\">    imageLink = data.imageLink </span><br><span class=\"line\"><span class=\"comment\">//ES5获取一个模块中的方法</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> stringHandle = <span class=\"built_in\">require</span>(<span class=\"string\">'toolModule'</span>).stringHandle ;</span><br></pre></td></tr></table></figure>\n<p>ES6中，我们可以使用解构处理以上两种情况：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> &#123;info, imageLink&#125; = response.data;</span><br><span class=\"line\"><span class=\"keyword\">var</span> &#123;stringHandle&#125; = <span class=\"built_in\">require</span>(<span class=\"string\">'toolModule'</span>)</span><br></pre></td></tr></table></figure>\n<p>右侧的response.data和require(‘toolModule’)都是对象，与左侧的 { } 格式相同，首先要保证这一点。个人理解{info, imageLink} = response.data像是<strong>{info, imageLink} = {response.data.info, response.data.imageLink}这样一个对应关系</strong>，然后我们就可以直接使用 info 和 imageLink 这两个变量了。</p>\n</li>\n</ol>\n<ol start=\"5\">\n<li><p><strong>增强的对象文本</strong></p>\n<p>下面是一个典型ES5对象文本，里面有一些方法和属性：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> serviceBase = &#123;<span class=\"attr\">port</span>: <span class=\"number\">3000</span>, <span class=\"attr\">url</span>: <span class=\"string\">'azat.co'</span>&#125;,</span><br><span class=\"line\">    getAccounts = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;<span class=\"keyword\">return</span> [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> accountServiceES5 = &#123;</span><br><span class=\"line\">  port: serviceBase.port,</span><br><span class=\"line\">  url: serviceBase.url,</span><br><span class=\"line\">  getAccounts: getAccounts,</span><br><span class=\"line\">   toString: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"built_in\">JSON</span>.stringify(<span class=\"keyword\">this</span>.valueOf());</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  getUrl: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;<span class=\"keyword\">return</span> <span class=\"string\">\"http://\"</span> + <span class=\"keyword\">this</span>.url + <span class=\"string\">':'</span> + <span class=\"keyword\">this</span>.port&#125;,</span><br><span class=\"line\">  valueOf_1_2_3: getAccounts()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果我们想让它更有意思，我们可以用Object.create从serviceBase继承原型的方法：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> accountServiceES5ObjectCreate = <span class=\"built_in\">Object</span>.create(serviceBase)</span><br><span class=\"line\"><span class=\"keyword\">var</span> accountServiceES5ObjectCreate = &#123;</span><br><span class=\"line\">  getAccounts: getAccounts,</span><br><span class=\"line\">  toString: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">JSON</span>.stringify(<span class=\"keyword\">this</span>.valueOf());</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  getUrl: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;<span class=\"keyword\">return</span> <span class=\"string\">\"http://\"</span> + <span class=\"keyword\">this</span>.url + <span class=\"string\">':'</span> + <span class=\"keyword\">this</span>.port&#125;,</span><br><span class=\"line\">  valueOf_1_2_3: getAccounts()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<ol start=\"6\">\n<li><p><strong>箭头函数</strong></p>\n<p>这是我迫不及待想讲的一个特征，CoffeeScript 就是因为它丰富的箭头函数让很多开发者喜爱。在ES6中，也有了丰富的箭头函数。这些丰富的箭头是令人惊讶的因为它们将使许多操作变成现实，比如，</p>\n<p>以前我们使用闭包，this总是预期之外地产生改变，而箭头函数的迷人之处在于，现在你的this可以按照你的预期使用了，身处箭头函数里面，this还是原来的this。</p>\n<p>有了箭头函数在ES6中， 我们就不必用that = this或 self =  this  或 _this = this  或.bind(this)。例如，下面的代码用ES5就不是很优雅：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> _this = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">$(<span class=\"string\">'.btn'</span>).click(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">event</span>)</span>&#123;</span><br><span class=\"line\">  _this.sendData();</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>在ES6中就不需要用 _this = this：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$(<span class=\"string\">'.btn'</span>).click(<span class=\"function\">(<span class=\"params\">event</span>) =&gt;</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.sendData();</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>Promises</strong></p>\n<p>Promises 是一个有争议的话题。因此有许多略微不同的promise 实现语法。Q，bluebird，deferred.js，vow, avow, jquery 一些可以列出名字的。也有人说我们不需要promises，仅仅使用异步，生成器，回调等就够了。但令人高兴的是，在ES6中有标准的Promise实现。</p>\n<p>下面是一个简单的用setTimeout()实现的异步延迟加载函数:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'Yay!'</span>);</span><br><span class=\"line\">&#125;, <span class=\"number\">1000</span>);</span><br></pre></td></tr></table></figure>\n<p>或者用ES6的箭头函数：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> wait1000 =  <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>)=&gt;</span> &#123;</span><br><span class=\"line\">  setTimeout(resolve, <span class=\"number\">1000</span>);</span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'Yay!'</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>块作用域和构造 let 和 const</strong></p>\n<p>在ES6代码中，你可能已经看到那熟悉的身影let。在ES6里let并不是一个花俏的特性，它是更复杂的。Let是一种新的变量申明方式，它允许你把变量作用域控制在块级里面。</p>\n</li>\n</ol>\n<p>   在ES5中，大括号的块级作用域起不了任何作用：</p>\n   <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">calculateTotalAmount</span> (<span class=\"params\">vip</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> amount = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (vip) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> amount = <span class=\"number\">1</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  &#123; </span><br><span class=\"line\">    <span class=\"keyword\">var</span> amount = <span class=\"number\">100</span>;</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"keyword\">var</span> amount = <span class=\"number\">1000</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">  <span class=\"keyword\">return</span> amount;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(calculateTotalAmount(<span class=\"literal\">true</span>));　　　　<span class=\"comment\">// 1000，最后定义的生效，块级作用域无作用</span></span><br></pre></td></tr></table></figure>\n<p>   块级作用域中let定义的变量，只在此块级作用域中生效，外层无法访问。</p>\n   <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">calculateTotalAmount</span> (<span class=\"params\">vip</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> amount = <span class=\"number\">0</span>; </span><br><span class=\"line\">  <span class=\"keyword\">if</span> (vip) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> amount = <span class=\"number\">1</span>; </span><br><span class=\"line\">  &#125; </span><br><span class=\"line\">  &#123; </span><br><span class=\"line\">    <span class=\"keyword\">let</span> amount = <span class=\"number\">100</span>; </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"keyword\">let</span> amount = <span class=\"number\">1000</span>; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">  <span class=\"keyword\">return</span> amount;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(calculateTotalAmount(<span class=\"literal\">true</span>));　　<span class=\"comment\">// 0，用let定义的变量都不可被最外层访问</span></span><br></pre></td></tr></table></figure>\n<p>   这里简单提一下，假如if句改为 <strong>if( vip ){ amount = 1 } ，那么结果是1，因为这样相当于定义了一个全局变量。</strong></p>\n<p>   我们知道，const用于声明常量，同一常量只可声明一次，声明后不可修改，而下面的代码中对于同一常量声明了多次，却没有报错，原因就是每个常量都只属于它所在的块级作用域，互不影响。</p>\n<ol start=\"9\">\n<li><p><strong>类（Classes）</strong></p>\n<p>现在就来看看如何用ES6写一个类吧。ES6没有用函数, 而是使用原型实现类。我们创建一个类baseModel ，并且在这个类里定义了一个constructor 和一个 getName()方法：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">baseModel</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(options, data) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = <span class=\"string\">'Base'</span>;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.url = <span class=\"string\">'http://azat.co/api'</span>;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.data = data;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.options = options;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    getName() &#123; <span class=\"comment\">// class method</span></span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">`Class name: <span class=\"subst\">$&#123;<span class=\"keyword\">this</span>.name&#125;</span>`</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>AccountModel 从类baseModel 中继承而来:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AccountModel</span> <span class=\"keyword\">extends</span> <span class=\"title\">baseModel</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(options, data) &#123;</span><br><span class=\"line\">　　　　<span class=\"comment\">//为了调用父级构造函数，可用super()参数传递：</span></span><br><span class=\"line\">　　　　<span class=\"keyword\">super</span>(&#123;<span class=\"attr\">private</span>: <span class=\"literal\">true</span>&#125;, [<span class=\"string\">'32113123123'</span>, <span class=\"string\">'524214691'</span>]); <span class=\"comment\">//call the parent method with super</span></span><br><span class=\"line\">       <span class=\"keyword\">this</span>.name = <span class=\"string\">'Account Model'</span>;</span><br><span class=\"line\">       <span class=\"keyword\">this</span>.url +=<span class=\"string\">'/accounts/'</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"comment\">// 可以把 accountData 设置成一个属性：</span></span><br><span class=\"line\">　　get accountsData() &#123; <span class=\"comment\">//calculated attribute getter</span></span><br><span class=\"line\">     <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.data;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">----------------------</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> accounts = <span class=\"keyword\">new</span> AccountModel(<span class=\"number\">5</span>);</span><br><span class=\"line\">accounts.getName();    <span class=\"comment\">//Class name: Account Model</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'Data is %s'</span>, accounts.accountsData);    <span class=\"comment\">//Data is  32113123123,524214691</span></span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<ol start=\"10\">\n<li><p><strong>模块（Modules）</strong></p>\n<p>众所周知，在ES6以前JavaScript并不支持本地的模块。人们想出了AMD，RequireJS，CommonJS以及其它解决方法。现在ES6中可以用模块import 和export 操作了。</p>\n</li>\n</ol>\n   <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 在ES5中，你可以在 &lt;script&gt;中直接写可以运行的代码（简称IIFE），或者一些库像AMD。然而在ES6中，你可以用export导入你的类。下面举个例子，在ES5中,module.js有port变量和getAccounts 方法:</span></span><br><span class=\"line\"><span class=\"comment\">// dev.js文件</span></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  port: <span class=\"number\">3000</span>,</span><br><span class=\"line\">  getAccounts: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>   在ES5中，需要依赖require(‘module’) 导入dev.js：</p>\n   <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> service = <span class=\"built_in\">require</span>(<span class=\"string\">'dev.js'</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(service.port); <span class=\"comment\">// 3000</span></span><br></pre></td></tr></table></figure>\n<p>   但在ES6中，我们将用export and import。例如，这是我们用ES6 写的dev.js文件库：</p>\n   <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// dev.js文件</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">var</span> port = <span class=\"number\">3000</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getAccounts</span>(<span class=\"params\">url</span>) </span>&#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>   如果用ES6来导入到文件中，我们需用import {name} from ‘my-module’语法，例如：</p>\n   <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123;port, getAccounts&#125; <span class=\"keyword\">from</span> <span class=\"string\">'dev'</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(port); <span class=\"comment\">// 3000</span></span><br></pre></td></tr></table></figure>\n<p>   或者我们可以在文件中把整个模块导入, 并命名为 service：</p>\n   <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> service <span class=\"keyword\">from</span> <span class=\"string\">'dev'</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(service.port); <span class=\"comment\">// 3000</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"Vue框架面试题\"><a href=\"#Vue框架面试题\" class=\"headerlink\" title=\"Vue框架面试题\"></a>Vue框架面试题</h1><h2 id=\"V-show-指令，v-if-的区别？\"><a href=\"#V-show-指令，v-if-的区别？\" class=\"headerlink\" title=\"V-show 指令，v-if 的区别？\"></a>V-show 指令，v-if 的区别？</h2><p>条件渲染指令，与v-if 不同的是，无论 v-show 的值为 true 或 false，元素都会存在于HTML代码中，而只有当 v-if 的值为true元素才会存在于 THML 代码中，v-show 指令只是设置了元素 CSS 的 style 值。</p>\n<p>使用MVVM模式有4个好处：</p>\n<ol>\n<li><p>低耦合。view 可以独立于model 变化和修改，一个viewModel 可以绑定到不同的view上，当view 变化的时候model可以不变，当 Model 变化的时候 View 也可以不变。</p>\n</li>\n<li><p>可重用性。可以把一些视图的逻辑放在viewModel 里面，让很多View 重用这段视图逻辑</p>\n</li>\n<li><p>独立开发。开发人员专注与业务逻辑和数据的开发。设计人员可以专注于界面（View）的设计</p>\n</li>\n<li><p>可测试性。可以针对viewModel 来对界面进行测试</p>\n<p><img src=\"https://zhanglong292383147.gitee.io/picture_images/picture/Mianjingxuan/MVVM模式工作原理.png\" alt=\"\"></p>\n</li>\n</ol>\n<p>Vue.js 特点：</p>\n<p>简洁：页面由HTML模式板 + JSON数据 + Vue 案例组成</p>\n<p>数据驱动：自动计算属性和追踪依赖的模板表达式</p>\n<p>组件化：用于复用、解耦的组件来构造页面</p>\n<p>轻量：代码量小，不依赖其他库</p>\n<p>快速：精确有效批量 DOM 更新</p>\n<p>模板友好：可通过npm，bower等多种方式安装，很容易融入</p>\n<h2 id=\"怎么定义-vue-router-的动态路由？怎么获取传过来的动态参数？\"><a href=\"#怎么定义-vue-router-的动态路由？怎么获取传过来的动态参数？\" class=\"headerlink\" title=\"怎么定义 vue-router 的动态路由？怎么获取传过来的动态参数？\"></a>怎么定义 vue-router 的动态路由？怎么获取传过来的动态参数？</h2><p>在 router 目录下的index.js文件中，对 path 属性上 /:id 的 params.id 使用 router 对象</p>\n<h2 id=\"vue-router-有哪种导航钩子？\"><a href=\"#vue-router-有哪种导航钩子？\" class=\"headerlink\" title=\"vue-router 有哪种导航钩子？\"></a>vue-router 有哪种导航钩子？</h2><p>第一种：是全局导航钩子：router.beforeEach（to，from，next），作用：跳转前进进行判断拦截</p>\n<p>第二种：组件内的钩子</p>\n<p>第三种：单独路由独享组件</p>\n<h2 id=\"v-model-是什么？怎么使用？vue-中标签怎么绑定事件？\"><a href=\"#v-model-是什么？怎么使用？vue-中标签怎么绑定事件？\" class=\"headerlink\" title=\"v-model 是什么？怎么使用？vue 中标签怎么绑定事件？\"></a>v-model 是什么？怎么使用？vue 中标签怎么绑定事件？</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">可以实现双向绑定，指令 （v-class，v-for，v-if，v-show，v-on） vue 的 model 层的 data 属性。绑定事件&lt;input @click=del() /&gt;</span><br></pre></td></tr></table></figure>\n<h2 id=\"vuex-是什么？怎么使用？哪种功能场景使用它？\"><a href=\"#vuex-是什么？怎么使用？哪种功能场景使用它？\" class=\"headerlink\" title=\"vuex 是什么？怎么使用？哪种功能场景使用它？\"></a>vuex 是什么？怎么使用？哪种功能场景使用它？</h2><p>Vuex 是一个专为 Vue.js 应用程序开发的<strong>状态管理模式</strong>，在main.js 引入ctore，注入。新建一个目录 store、…export 场景有：单页应用中，组件之间的状态音乐播放器，登录状态，加入购物车</p>\n<hr>\n<p>每一个 Vuex 应用的核心就是 store（仓库）。“store”基本上就是一个容器，它包含着你的应用中大部分的<strong>状态 (state)</strong>。Vuex 和单纯的全局对象有以下两点不同：</p>\n<ol>\n<li>Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。</li>\n<li>你不能直接改变 store 中的状态。改变 store 中的状态的唯一途径就是显式地<strong>提交 (commit) mutation</strong>。这样使得我们可以方便地跟踪每一个状态的变化，从而让我们能够实现一些工具帮助我们更好地了解我们的应用。</li>\n</ol>\n<h2 id=\"你是怎么认识-Vuex-的？\"><a href=\"#你是怎么认识-Vuex-的？\" class=\"headerlink\" title=\"你是怎么认识 Vuex 的？\"></a>你是怎么认识 Vuex 的？</h2><p>Vuex 可以理解为一种开发模式或框架。通过状态（数据源）集中管理驱动组件的变化。</p>\n<p>应用级的状态集中放在 store（仓库） 中，改变状态的方式是提交 mutations，这是个同步的事物，异步逻辑应该封装在 action 中</p>\n<p><img src=\"https://zhanglong292383147.gitee.io/picture_images/picture/Mianjingxuan/Vuex是什么.jpg\" alt=\"\"></p>\n<ul>\n<li><strong>state</strong>，驱动应用的数据源；</li>\n<li><strong>view</strong>，以声明方式将 <strong>state</strong> 映射到视图；</li>\n<li><strong>actions</strong>，响应在 <strong>view</strong> 上的用户输入导致的状态变化。</li>\n</ul>\n<h2 id=\"vue-router是什么？它有哪些组件？\"><a href=\"#vue-router是什么？它有哪些组件？\" class=\"headerlink\" title=\"vue-router是什么？它有哪些组件？\"></a>vue-router是什么？它有哪些组件？</h2><p>vue用来写路由一个插件router-link，router-view</p>\n<h2 id=\"Vue的双向数据绑定原理是什么？\"><a href=\"#Vue的双向数据绑定原理是什么？\" class=\"headerlink\" title=\"Vue的双向数据绑定原理是什么？\"></a>Vue的双向数据绑定原理是什么？</h2><p><img src=\"https://zhanglong292383147.gitee.io/picture_images/picture/Mianjingxuan/VUE双向绑定原理.png\" alt=\"\"></p>\n<p>这里VM，就是 vue框架它相当于中间枢纽的作用，连接着 model 和 view</p>\n<p>当前台显示的 view 发生变化了，它会实时反应到 viewModel（上，如果有需要，viewModel会通过 Ajax 等方法将改变的数据传递给后台 model）</p>\n<p>同时从后台 model 获取过来的数据，通过 VM 将值响应到前台 UI 上</p>\n<p><img src=\"https://zhanglong292383147.gitee.io/picture_images/picture/Mianjingxuan/input事件数据绑定原理.png\" alt=\"\"></p>\n<p>VM的核心是 view 和 data</p>\n<p>当 data 有变化的时候它通过 <strong>object.defineProperty()</strong>  方法中的 <strong>set</strong> 方法进行监控，并调用在此之前已经定义好 <strong>data</strong> 和 <strong>view</strong> 的关系了的回调函数，来通知 view 进行数据的改变。</p>\n<p>而 view 发生改变则是通过底层的 input 事件来进行 data 的响应更改</p>\n<p>Vue 是通过 <strong>object.defineProperty()</strong> 来实现<strong>数据劫持</strong>的。（它可以来控制一个对象属性的一些特有操作，比如读写权、是否可以枚举）</p>\n<p>实现方法：观察者模式</p>\n<p>MVVM 框架类：</p>\n<p><img src=\"https://zhanglong292383147.gitee.io/picture_images/picture/Mianjingxuan/观察者模式的MVVM框架的工作原理.png\" alt=\"\"></p>\n<p>Observer（object.defineProperty 中的 set）<strong>监听</strong> data 的变化，当 data <strong>有变化</strong>的时候<strong>通知</strong>观察者列表 <strong>Dep</strong>（里面有与 Data 变化对应的Update 函数），watcher<strong>（监听器）</strong> 负责向<strong>观察者列表</strong>（Dep）<strong>添加</strong>（订阅）对应的<strong>更新函数</strong>，Dep 里的更新函数执行了之后将<em>最新的值</em> <strong>更新</strong> 到 <strong>View（视图）</strong>上</p>\n<h2 id=\"请详细说下你对-Vue-生命周期的理解？\"><a href=\"#请详细说下你对-Vue-生命周期的理解？\" class=\"headerlink\" title=\"请详细说下你对 Vue 生命周期的理解？\"></a>请详细说下你对 Vue 生命周期的理解？</h2><p>总共分 为 8个阶段：创建前 / 后，载入前 / 载入后，更新前 / 后，销毁前 / 后</p>\n<p>创建前 / 后：在 <strong>beforeCreate (创建前)</strong> 阶段，Vue实例的<strong>挂载元素</strong> el 和<strong>数据对象</strong> data 都为 <strong>undefined</strong>，还未初始化。在 <strong>created (创建后)</strong> 阶段，Vue 实例的<strong>数据对象</strong> data <strong>有</strong>了,  <strong>el</strong> 还<strong>没有</strong>。</p>\n<p>载入前 / 后：在<strong>beforeMount</strong> 阶段，Vue实例的 <strong>el</strong> 和 <strong>data</strong> 都<strong>初始化</strong>了，但还是挂载之前为虚拟的 DOM 节点，data.message 还未替换。在 <strong>mounted</strong> 阶段，Vue实例<strong>挂载完成</strong>，data.message 成功 <strong>渲染</strong></p>\n<p>更新前 / 后：当 <strong>data</strong> 变化时，会<strong>触发</strong> beforeUpdate 和 updated 方法。</p>\n<p>销毁前 / 后：在执行 destroy 方法后，对 data 的改变不会再触发函数，说明此时 Vue 实例已经<strong>解除</strong>了<strong>事件监听</strong>以及和 <strong>DOM 的绑定</strong>，但是 dom <strong>结构</strong>依然<strong>存在</strong></p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"app\"</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>&#123;&#123;info&#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">button</span> @<span class=\"attr\">click</span>=<span class=\"string\">\"info='hello1'\"</span>&gt;</span>更新info<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">button</span> @<span class=\"attr\">click</span>=<span class=\"string\">\"destroy\"</span>&gt;</span>销毁实例<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"keyword\">var</span> vm = <span class=\"keyword\">new</span> Vue(&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">            el: <span class=\"string\">\"#app\"</span>,</span></span><br><span class=\"line\"><span class=\"undefined\">            data: &#123;</span></span><br><span class=\"line\"><span class=\"javascript\">                info: <span class=\"string\">\"hello\"</span></span></span><br><span class=\"line\"><span class=\"undefined\">            &#125;,</span></span><br><span class=\"line\"><span class=\"javascript\">            <span class=\"comment\">// 在实例初始化之后，数据观测 (data observer) 和 event/watcher 配置之前被调用。</span></span></span><br><span class=\"line\"><span class=\"javascript\">            beforeCreate: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">                <span class=\"built_in\">console</span>.log(<span class=\"string\">\"===============beforeCreate============================================\"</span>)</span></span><br><span class=\"line\"><span class=\"javascript\">                <span class=\"comment\">// $el表示Vue 实例使用的根 DOM 元素。</span></span></span><br><span class=\"line\"><span class=\"javascript\">                <span class=\"built_in\">console</span>.log(<span class=\"string\">'$el'</span>, <span class=\"keyword\">this</span>.$el);</span></span><br><span class=\"line\"><span class=\"javascript\">                <span class=\"comment\">// $data Vue 实例观察的数据对象</span></span></span><br><span class=\"line\"><span class=\"javascript\">                <span class=\"built_in\">console</span>.log(<span class=\"string\">'$data'</span>, <span class=\"keyword\">this</span>.$data);</span></span><br><span class=\"line\"><span class=\"javascript\">                <span class=\"built_in\">console</span>.log(<span class=\"string\">\"info:\"</span>, <span class=\"keyword\">this</span>.info)</span></span><br><span class=\"line\"><span class=\"undefined\">            &#125;,</span></span><br><span class=\"line\"><span class=\"javascript\">            <span class=\"comment\">// 在实例创建完成后被立即调用。在这一步，实例已完成以下的配置：数据观测 (data observer)，属性和方法的运算，watch/event 事件回调。然而，挂载阶段还没开始，dom还未生成，$el 属性目前不可见。 一般都在created中发送请求</span></span></span><br><span class=\"line\"><span class=\"javascript\">            created: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">                <span class=\"built_in\">console</span>.log(<span class=\"string\">\"===============created=======================================\"</span>)</span></span><br><span class=\"line\"><span class=\"javascript\">                <span class=\"built_in\">console</span>.log(<span class=\"string\">'$el'</span>, <span class=\"keyword\">this</span>.$el);</span></span><br><span class=\"line\"><span class=\"javascript\">                <span class=\"built_in\">console</span>.log(<span class=\"string\">'$data'</span>, <span class=\"keyword\">this</span>.$data);</span></span><br><span class=\"line\"><span class=\"javascript\">                <span class=\"built_in\">console</span>.log(<span class=\"string\">\"info:\"</span>, <span class=\"keyword\">this</span>.info)</span></span><br><span class=\"line\"><span class=\"undefined\">            &#125;,</span></span><br><span class=\"line\"><span class=\"javascript\">            <span class=\"comment\">// 模板编译挂载之前调用，首先会判断对象是否有el选项。如果有的话就继续向下编译，如果没有el选项，则停止编译，也就意味着停止了生命周期，直到在该vue实例上调用vm.$mount(el)。接着判断是否有template属性，有的话就以template属性中的值作为模板，如果没有的话，就以el属性指向的作为模板。这里会生成vm.$el，但指令尚未被解析</span></span></span><br><span class=\"line\"><span class=\"javascript\">            beforeMount: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">                <span class=\"built_in\">console</span>.log(<span class=\"string\">\"===============beforeMount=========================================\"</span>)</span></span><br><span class=\"line\"><span class=\"javascript\">                <span class=\"built_in\">console</span>.log(<span class=\"string\">'$el'</span>, <span class=\"keyword\">this</span>.$el);</span></span><br><span class=\"line\"><span class=\"javascript\">                <span class=\"built_in\">console</span>.log(<span class=\"string\">'$data'</span>, <span class=\"keyword\">this</span>.$data);</span></span><br><span class=\"line\"><span class=\"javascript\">                <span class=\"built_in\">console</span>.log(<span class=\"string\">\"info:\"</span>, <span class=\"keyword\">this</span>.info)</span></span><br><span class=\"line\"><span class=\"undefined\">            &#125;,</span></span><br><span class=\"line\"><span class=\"javascript\">            <span class=\"comment\">// 模板编译挂载之后调用，vm.$el替换掉el指向的dom</span></span></span><br><span class=\"line\"><span class=\"javascript\">            mounted: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">                <span class=\"built_in\">console</span>.log(<span class=\"string\">\"===============mounted===========================================\"</span>)</span></span><br><span class=\"line\"><span class=\"javascript\">                <span class=\"built_in\">console</span>.log(<span class=\"string\">'$el'</span>, <span class=\"keyword\">this</span>.$el);</span></span><br><span class=\"line\"><span class=\"javascript\">                <span class=\"built_in\">console</span>.log(<span class=\"string\">'$data'</span>, <span class=\"keyword\">this</span>.$data);</span></span><br><span class=\"line\"><span class=\"javascript\">                <span class=\"built_in\">console</span>.log(<span class=\"string\">\"info:\"</span>, <span class=\"keyword\">this</span>.info)</span></span><br><span class=\"line\"><span class=\"undefined\">            &#125;,</span></span><br><span class=\"line\"><span class=\"javascript\">            <span class=\"comment\">// 数据变更导致虚拟DOM重新渲染之前调用</span></span></span><br><span class=\"line\"><span class=\"javascript\">            beforeUpdate: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">                <span class=\"built_in\">console</span>.log(<span class=\"string\">\"===============beforeUpdate============================================\"</span>);</span></span><br><span class=\"line\"><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"undefined\">            &#125;,</span></span><br><span class=\"line\"><span class=\"javascript\">            <span class=\"comment\">// 数据变更导致虚拟DOM重新渲染之后调用</span></span></span><br><span class=\"line\"><span class=\"javascript\">            updated: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">                <span class=\"built_in\">console</span>.log(<span class=\"string\">\"===============updated======================================================\"</span>);</span></span><br><span class=\"line\"><span class=\"undefined\">            &#125;,</span></span><br><span class=\"line\"><span class=\"javascript\">            <span class=\"comment\">// 实例销毁之前调用，在这一步，实例完全可用</span></span></span><br><span class=\"line\"><span class=\"javascript\">            beforeDestroy: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">                <span class=\"built_in\">console</span>.log(<span class=\"string\">\"===============beforeDestroy===============================================\"</span>)</span></span><br><span class=\"line\"><span class=\"javascript\">                <span class=\"built_in\">console</span>.log(<span class=\"string\">'$el'</span>, <span class=\"keyword\">this</span>.$el);</span></span><br><span class=\"line\"><span class=\"javascript\">                <span class=\"built_in\">console</span>.log(<span class=\"string\">'$data'</span>, <span class=\"keyword\">this</span>.$data);</span></span><br><span class=\"line\"><span class=\"javascript\">                <span class=\"built_in\">console</span>.log(<span class=\"string\">\"info:\"</span>, <span class=\"keyword\">this</span>.info)</span></span><br><span class=\"line\"><span class=\"undefined\">            &#125;,</span></span><br><span class=\"line\"><span class=\"javascript\">            <span class=\"comment\">// vue实例指向的所有东西解除绑定，包括watcher、事件、所以的子组件，后续就不再受vue实例控制了</span></span></span><br><span class=\"line\"><span class=\"javascript\">            destroyed: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">                <span class=\"built_in\">console</span>.log(<span class=\"string\">\"===============destroyed================================================\"</span>)</span></span><br><span class=\"line\"><span class=\"javascript\">                <span class=\"built_in\">console</span>.log(<span class=\"string\">'$el'</span>, <span class=\"keyword\">this</span>.$el);</span></span><br><span class=\"line\"><span class=\"javascript\">                <span class=\"built_in\">console</span>.log(<span class=\"string\">'$data'</span>, <span class=\"keyword\">this</span>.$data);</span></span><br><span class=\"line\"><span class=\"javascript\">                <span class=\"built_in\">console</span>.log(<span class=\"string\">\"info:\"</span>, <span class=\"keyword\">this</span>.info)</span></span><br><span class=\"line\"><span class=\"undefined\">            &#125;,</span></span><br><span class=\"line\"><span class=\"undefined\">            methods: &#123;</span></span><br><span class=\"line\"><span class=\"undefined\">                destroy() &#123;</span></span><br><span class=\"line\"><span class=\"javascript\">                    <span class=\"comment\">// 表示销毁组件</span></span></span><br><span class=\"line\"><span class=\"javascript\">                    <span class=\"keyword\">this</span>.$destroy()</span></span><br><span class=\"line\"><span class=\"undefined\">                &#125;,</span></span><br><span class=\"line\"><span class=\"undefined\">                udpateinfo() &#123;</span></span><br><span class=\"line\"><span class=\"javascript\">                    <span class=\"keyword\">this</span>.info = <span class=\"string\">'hello2'</span></span></span><br><span class=\"line\"><span class=\"undefined\">                &#125;</span></span><br><span class=\"line\"><span class=\"undefined\">            &#125;</span></span><br><span class=\"line\"><span class=\"undefined\">        &#125;)</span></span><br><span class=\"line\"><span class=\"undefined\">    </span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"Vue-组件封装过程？\"><a href=\"#Vue-组件封装过程？\" class=\"headerlink\" title=\"Vue 组件封装过程？\"></a>Vue 组件封装过程？</h2><p>首先，使用 Vue.extend() 创建一个组件</p>\n<p>然后，使用 Vue.component() 方法注册组件</p>\n<p>接着，如果子组件需要数据，可以在 props 中接受定义</p>\n<p>最后，子组件修改好数据之后，想把数据传递给父组件，可以使用 emit() 方法</p>\n<h2 id=\"Vue-loader-是什么？\"><a href=\"#Vue-loader-是什么？\" class=\"headerlink\" title=\"Vue-loader 是什么？\"></a>Vue-loader 是什么？</h2><p>解析 Vue 文件的一个加载器，跟 template/js/style 转换成 JS 模块</p>\n<p>提供了一些非常酷炫的特性：</p>\n<p>ES5默认可用；</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">在每个 Vue 组件内支持其他的 webpack 加载器，如用于 &lt;style&gt; 的 SASS 和用于&lt;template&gt;的 Jade</span><br><span class=\"line\"></span><br><span class=\"line\">把 &lt;style&gt;和&lt;template&gt;内引用的静态资源作为模块依赖项对待，并用 webpack 加载器处理。</span><br><span class=\"line\"></span><br><span class=\"line\">对每个组件模拟有作用域的 css</span><br><span class=\"line\"></span><br><span class=\"line\">开发阶段支持组件的热加载</span><br><span class=\"line\"></span><br><span class=\"line\">简单的说，webpack 和 vue-loader 的组合为你创作 Vue 应用一个更先进、更灵巧极其强大的前端开发模式</span><br></pre></td></tr></table></figure>\n<h2 id=\"使用它的用途有哪些？\"><a href=\"#使用它的用途有哪些？\" class=\"headerlink\" title=\"使用它的用途有哪些？\"></a>使用它的用途有哪些？</h2><p>JS 可以写 es6、style 样式可以 scss 或 less、template可以加 jade 等。</p>\n<h2 id=\"说出至少4种Vue当中的指令和它的用法\"><a href=\"#说出至少4种Vue当中的指令和它的用法\" class=\"headerlink\" title=\"说出至少4种Vue当中的指令和它的用法\"></a>说出至少4种Vue当中的指令和它的用法</h2><p>v-if：判断是否隐藏；</p>\n<p>v-for：数据循环出来；</p>\n<p>v-bind：class：绑定一个属性；</p>\n<p>v-model：实现双向绑定</p>\n<h2 id=\"自定义指令（v-check、v-focus）的方法有哪些？它有哪些钩子函数？还有哪些钩子函数参数？\"><a href=\"#自定义指令（v-check、v-focus）的方法有哪些？它有哪些钩子函数？还有哪些钩子函数参数？\" class=\"headerlink\" title=\"自定义指令（v-check、v-focus）的方法有哪些？它有哪些钩子函数？还有哪些钩子函数参数？\"></a>自定义指令（v-check、v-focus）的方法有哪些？它有哪些钩子函数？还有哪些钩子函数参数？</h2><p>全局定义指令：在 Vue 对象的 driective 方法里面有两个参数，一个是指令名称，另一个是函数。组件内定义指令：directives；</p>\n<p>钩子函数：bind（绑定事件触发），inserted（节点插入的时候触发）、update（组件内相关更新）</p>\n<p>钩子函数参数：el ， binding</p>\n<p>理解 Vue 自定义指令钩子函数：</p>\n<p>一个指令定义对象可以提供如下几个钩子函数（均为可选）：</p>\n<p>bind：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置</p>\n<p>inserted：被绑定元素插入父节点时调用（仅保证父节点存在，但不一定已被插入文档中）</p>\n<p>update：所在组件的 VNode 更新时调用，但是可能发生在其子 VNode 更新之前。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新</p>\n<p>componentUpdated：指令所在组件的 VNode 及其子 VNode 全部更新后调用。</p>\n<p>conbind：只调用一次，指令与元素解绑时调用。</p>\n<p>指令钩子函数会被传入以下参数：</p>\n<p>el：指令所绑定的元素，可以用来直接操作 DOM</p>\n<p>binding：一个对象，包含以下属性：</p>\n<p>name：指令名，不包含 v-前缀</p>\n<p>value：指令的绑定值，例如：v-my-directive=“ 1 + 1” 中，绑定值为2</p>\n<p>oldValue：指令绑定的前一个值，仅在 Update 和 compnentUpated 钩子中可用。无论值是否改变都可用</p>\n<p>expression：字符串形式的指令表达式。例如 v-my-directive=“ 1 + 1 ” 中，表达式为“1+1”</p>\n<p>avg：传给指令的参数，可选。例如：v-my-directive：foo 中，参数为 “foo”</p>\n<p>modifiers：一个包含修饰符的对象。例如：v-my-directive.foo.bar 中，修饰符对象为 { foo：true，bar：true }</p>\n<p>vnode：Vue 编译生成的虚拟节点。移步 VNode API 来了解更多详情</p>\n<p>oldVnode：上一个虚拟节点，仅在 update 和 componentUpdated 钩子中可用。</p>\n<h2 id=\"axios是什么？怎么使用？描述使用它实现登录功能的流程？\"><a href=\"#axios是什么？怎么使用？描述使用它实现登录功能的流程？\" class=\"headerlink\" title=\"axios是什么？怎么使用？描述使用它实现登录功能的流程？\"></a>axios是什么？怎么使用？描述使用它实现登录功能的流程？</h2><ol>\n<li>请求后台资源的模块。 npm i axios -s 装好</li>\n<li>然后发送的是跨域，需在配置文件中 config/index.js 进行设置</li>\n<li>后台如果是TP5 则定义一个资源路由。JS 使用import 进来，</li>\n<li>然后 .get 或 .post 返回在 .this 函数中如果成功</li>\n<li>失则则是在 .catch 函数中</li>\n</ol>\n<h2 id=\"axios-tp5-进价中，调用-axios-post-‘-api-user-‘-是进行的什么操作？axios-put-‘api-8’-呢？\"><a href=\"#axios-tp5-进价中，调用-axios-post-‘-api-user-‘-是进行的什么操作？axios-put-‘api-8’-呢？\" class=\"headerlink\" title=\"axios + tp5 进价中，调用 axios.post(‘ api/user ‘) 是进行的什么操作？axios.put(‘api/8’) 呢？\"></a>axios + tp5 进价中，调用 axios.post(‘ api/user ‘) 是进行的什么操作？axios.put(‘api/8’) 呢？</h2><p>跨域，添加用户操作，更新操作。</p>\n<h2 id=\"请说下具体使用-Vue-的理解？\"><a href=\"#请说下具体使用-Vue-的理解？\" class=\"headerlink\" title=\"请说下具体使用 Vue 的理解？\"></a>请说下具体使用 Vue 的理解？</h2><ol>\n<li>使用 Vue 不必担心布局更改和类名重复导致的 JS 重写，因为它是靠数据驱动双向绑定，底层是通过 Object.defineProperty() 定义的数据，set、get 函数原理实现。</li>\n<li>组件化开发，让项目的可拓展性、移植性更好，代码重用性更高，就好像农民工建房子，拿起自己的工具包就可以开工。项目经理坐等收楼就好。</li>\n<li>单页应用的体验零距离接触安卓原生应用，局部组件更新界面，让用户体验更快速省时。</li>\n<li>JS 的代码无形的规范，团队合作开发代码可阅读性更高。</li>\n</ol>\n<h2 id=\"你觉得哪些项目适合-Vue-框架？\"><a href=\"#你觉得哪些项目适合-Vue-框架？\" class=\"headerlink\" title=\"你觉得哪些项目适合 Vue 框架？\"></a>你觉得哪些项目适合 Vue 框架？</h2><ol>\n<li>数据信息量比较多的，反之类似企业网站就无需此框架了</li>\n<li>手机 web 和 app 应用多端共用一套界面的项目，因为使用 Vue.cli + webpack 后的前端目录，非常有利于项目的跨平台部署。</li>\n</ol>\n<h2 id=\"Vue-组件之间如何通信？\"><a href=\"#Vue-组件之间如何通信？\" class=\"headerlink\" title=\"Vue 组件之间如何通信？\"></a>Vue 组件之间如何通信？</h2><p>作为一个vue初学者不得不了解的就是组件间的数据通信(暂且不谈vuex)。通信方式根据组件之间的关系有不同之处。组件关系有下面三种：<strong>父–&gt;子</strong>、<strong>子–&gt;父</strong>、<strong>非父子</strong></p>\n<h4 id=\"父–-gt-子\"><a href=\"#父–-gt-子\" class=\"headerlink\" title=\"父–&gt;子\"></a>父–&gt;子</h4><p>父向子传递数据通过props</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//父组件代码</span></span><br><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">    &lt;header-box :title-txt=<span class=\"string\">\"showTitleTxt\"</span>&gt;<span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">header-box</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span></span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    <span class=\"keyword\">import</span> Header <span class=\"keyword\">from</span> <span class=\"string\">'./header'</span></span><br><span class=\"line\">    <span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">        name: <span class=\"string\">'index'</span>,</span><br><span class=\"line\">        components: &#123;</span><br><span class=\"line\">            <span class=\"string\">'header-box'</span>: Header</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        data () &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">                showTitleTxt: <span class=\"string\">'首页'</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&lt;<span class=\"regexp\">/script&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//子组件代码</span></span><br><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">    &lt;header&gt;</span><br><span class=\"line\">        &#123;&#123;thisTitleTxt&#125;&#125;</span><br><span class=\"line\">    &lt;<span class=\"regexp\">/header&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">&lt;/</span>template&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    <span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">        name: <span class=\"string\">'header-box'</span>,</span><br><span class=\"line\">        props: &#123;</span><br><span class=\"line\">            titleTxt: <span class=\"built_in\">String</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        data () &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">                thisTitleTxt: <span class=\"keyword\">this</span>.titleTxt</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&lt;<span class=\"regexp\">/script&gt;</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"子–-gt-父\"><a href=\"#子–-gt-父\" class=\"headerlink\" title=\"子–&gt;父\"></a>子–&gt;父</h4><blockquote>\n<p>子组件向父组件传递分为两种类型。<br>1、子组件改变父组件传递的props（你会发现通过props中的Object类型参数传输数据，可以通过子组件改变数据内容。这种方式是可行的，但是不推荐使用，因为官方定义prop是单向绑定）<br>2、通过$on和$emit</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//通过props实现传递</span></span><br><span class=\"line\"><span class=\"comment\">//父组件代码</span></span><br><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">    &lt;header-box :title-txt=<span class=\"string\">\"showTitleTxt\"</span>&gt;<span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">header-box</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span></span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    <span class=\"keyword\">import</span> Header <span class=\"keyword\">from</span> <span class=\"string\">'./header'</span></span><br><span class=\"line\">    <span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">        name: <span class=\"string\">'index'</span>,</span><br><span class=\"line\">        components: &#123;</span><br><span class=\"line\">            <span class=\"string\">'header-box'</span>: Header</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        data () &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">                showTitleTxt: &#123;</span><br><span class=\"line\">                    name: <span class=\"string\">'首页'</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&lt;<span class=\"regexp\">/script&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//子组件代码</span></span><br><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">    &lt;header @click=<span class=\"string\">\"changeTitleTxt\"</span>&gt;</span><br><span class=\"line\">        &#123;&#123;thisTitleTxt.name&#125;&#125;</span><br><span class=\"line\">    &lt;<span class=\"regexp\">/header&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">&lt;/</span>template&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    <span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">        name: <span class=\"string\">'header-box'</span>,</span><br><span class=\"line\">        props: &#123;</span><br><span class=\"line\">            titleTxt: <span class=\"built_in\">Object</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        data () &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">                thisTitleTxt: <span class=\"keyword\">this</span>.titleTxt.name</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        metheds: &#123;</span><br><span class=\"line\">            changeTitleTxt () &#123;</span><br><span class=\"line\">                <span class=\"keyword\">this</span>.titleTxt.name = <span class=\"string\">'切换'</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&lt;<span class=\"regexp\">/script&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//通过$on,$emit</span></span><br><span class=\"line\"><span class=\"comment\">//父组件代码</span></span><br><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">    &lt;div id=<span class=\"string\">\"counter-event-example\"</span>&gt;</span><br><span class=\"line\">      &lt;p&gt;&#123;&#123; total &#125;&#125;&lt;<span class=\"regexp\">/p&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">      &lt;button-counter v-on:increment=\"incrementTotal\"&gt;&lt;/</span>button-counter&gt;</span><br><span class=\"line\">&lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">&lt;/</span>template&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    <span class=\"keyword\">import</span> ButtonCounter <span class=\"keyword\">from</span> <span class=\"string\">'./buttonCounter'</span></span><br><span class=\"line\">    <span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">        name: <span class=\"string\">'index'</span>,</span><br><span class=\"line\">        components: &#123;</span><br><span class=\"line\">            <span class=\"string\">'button-conuter'</span>: ButtonCounter</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        data () &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">                total: <span class=\"number\">0</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        methods: &#123;</span><br><span class=\"line\">            incrementTotal () &#123;</span><br><span class=\"line\">                <span class=\"keyword\">this</span>.total++</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&lt;<span class=\"regexp\">/script&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//子组件代码</span></span><br><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">    &lt;button @click=<span class=\"string\">\"incrementCounter\"</span>&gt;&#123;&#123;counter&#125;&#125;&lt;<span class=\"regexp\">/button&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">&lt;/</span>template&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    <span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">        name: <span class=\"string\">'button-counter'</span>,</span><br><span class=\"line\">        data () &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">                counter: <span class=\"number\">0</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        metheds: &#123;</span><br><span class=\"line\">            incrementCounter () &#123;</span><br><span class=\"line\">                <span class=\"keyword\">this</span>.$emit(<span class=\"string\">'increment'</span>)</span><br><span class=\"line\">                <span class=\"keyword\">this</span>.counter++</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&lt;<span class=\"regexp\">/script&gt;</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"非父子\"><a href=\"#非父子\" class=\"headerlink\" title=\"非父子\"></a>非父子</h4><blockquote>\n<p>简单情况下我们可以通过使用一个空的Vue实例作为中央事件总线，（这里也可以使用app实例，而不需要新建一个空Vue实例）</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//main.js</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> bus = <span class=\"keyword\">new</span> Vue()</span><br><span class=\"line\">Vue.prototype.bus = bus</span><br></pre></td></tr></table></figure>\n<p>或者</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//main.js</span></span><br><span class=\"line\"><span class=\"keyword\">new</span> Vue(&#123;</span><br><span class=\"line\">  el: <span class=\"string\">'#app'</span>,</span><br><span class=\"line\">  router,</span><br><span class=\"line\">  template: <span class=\"string\">'&lt;App/&gt;'</span>,</span><br><span class=\"line\">  components: &#123; App &#125;,</span><br><span class=\"line\">  beforeCreate () &#123;</span><br><span class=\"line\">    Vue.prototype.bus = <span class=\"keyword\">this</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//header组件</span></span><br><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">    &lt;header @click=<span class=\"string\">\"changeTitle\"</span>&gt;&#123;&#123;title&#125;&#125;&lt;<span class=\"regexp\">/header&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">&lt;/</span>template&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">    name: <span class=\"string\">'header'</span>,</span><br><span class=\"line\">    data () &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">            title: <span class=\"string\">'头部'</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    methods: &#123;</span><br><span class=\"line\">        changeTitle () &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.bus.$emit(<span class=\"string\">'toChangeTitle'</span>,<span class=\"string\">'首页'</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;<span class=\"regexp\">/script&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//footer组件</span></span><br><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">    &lt;footer&gt;&#123;&#123;txt&#125;&#125;&lt;<span class=\"regexp\">/footer&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">&lt;/</span>template&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">    name: <span class=\"string\">'footer'</span>,</span><br><span class=\"line\">    mounted () &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.bus.$on(<span class=\"string\">'toChangeTitle'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">title</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(title)</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    data () &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">            txt: <span class=\"string\">'尾部'</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"关于vue在app首次加载缓慢的解决办法？\"><a href=\"#关于vue在app首次加载缓慢的解决办法？\" class=\"headerlink\" title=\"关于vue在app首次加载缓慢的解决办法？\"></a>关于vue在app首次加载缓慢的解决办法？</h2><p><em>1.路由懒加载</em></p>\n<p><img src=\"https:////upload-images.jianshu.io/upload_images/12205285-7190dce75d2c6b60.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/513/format/webp\" alt=\"img\"></p>\n<p>​                                            路由懒加载</p>\n<p>此方法会把原本打包到一个app.js文件分开成多个js文件打包，这样会减小单个文件的大小，但是不会减小整个js文件夹的大小。通过这种方式可以做到按需加载，只加载单个页面的js文件。</p>\n<p><em>2.组件异步加载</em></p>\n<p><img src=\"https:////upload-images.jianshu.io/upload_images/12205285-9aa4e5728fa3dce2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/372/format/webp\" alt=\"img\"></p>\n<p>组件异步加载</p>\n<p>加载首页的时候，可以先给首页的子组件设置v-if = “false”，在页面初始化的时候再给子组件设置为true，此方法利用了v-if的惰性，setTimeout会使子组件在所有的组件初始化完成并显示后再对其子组件进行初始化。</p>\n<ul>\n<li style=\"list-style: none\"><input type=\"checkbox\" checked> <strong>注：在实际开发中还遇到了另一种情况也可以用此方法解决，在入口js中获取了app的token，但是在具体页面中发现不管是在created还是mounted中都是有时候能获取到token，有时候又不可以，是因为执行顺序的原因，可以通过 setTimeout 时间设置为0 这种方法把用到token的请求方法给排到最后，这样就能保证请求方法中有token了。</strong></li>\n</ul>\n<p><em>3.使用异步组件，按需加载</em></p>\n<p>newVue({</p>\n<p>// …</p>\n<p>  components: {</p>\n<p>​        ‘my-component’:()=&gt;import(‘./my-async-component’)</p>\n<p>  }</p>\n<p>})</p>\n<p>es6的写法，<code>import</code> 函数会返回一个 <code>Promise</code> 对象。这样就实现了组件的按需加载，有需要的时候才会加载这个组件，同样也是优化首屏加载速度的一种方法。</p>\n<p>下面两张图片就可以清晰的了解 import xxx from “./xxx.vue” 与 import()方法 的不同，以及用import函数所带来的好处。</p>\n<p><img src=\"https:////upload-images.jianshu.io/upload_images/12205285-e3630781a7ba92e2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/656/format/webp\" alt=\"img\"></p>\n<p>  import xxx from “./xxx.vue”  </p>\n<p><img src=\"https:////upload-images.jianshu.io/upload_images/12205285-fdb9ddf46f9da18e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/677/format/webp\" alt=\"img\"></p>\n<p>   import()方法</p>\n<p>上面是两种方法，打包后所生成的文件，import函数的方法很明显多了几个js，这就是从原本 app.js 中分离出来的0.js，1.js，2.js。第一张图，在运行的时候会把app.js整个加载完，而第二张图会加载0.js+app.js，虽然多了一个文件，但实际上，后者整体加载的文件大小要比原本小很多。这就是按需加载，在需要1.js的时候才会加载它，而且加载过一次后就会缓存在本地，下次加载，会取缓存的文件。</p>\n<p>而且，因为import函数返回的是一个promise对象，因此可以用promise本身的then()和catch()方法去监听到组件的加载，如：</p>\n<p><img src=\"https:////upload-images.jianshu.io/upload_images/12205285-85fff817aae7b673.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/393/format/webp\" alt=\"img\"></p>\n<p><em>4.图片量多的时候可以进行分批的加载</em></p>\n<p>vue-lazyload插件，图片懒加载</p>\n<p><em>5.外部引入一些插件，不要在vue中引入</em></p>\n<p>列入，我在次项目中有用到moment.js这个插件，在vue内部引入后打包的项目大小要比在外部用src的方式引入打包的项目大个300k左右。</p>\n<p>首先，下载好moment.min.js包，然后在vue项目的webpack.base.conf.js中添加下图箭头所指向的那段代码</p>\n<p><img src=\"https:////upload-images.jianshu.io/upload_images/12205285-96a1a056b87bd667.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/439/format/webp\" alt=\"img\"></p>\n<p>加上上图的代码后是不会将moment.js给打包到js中的。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>#面试题精选</p>\n<h2 id=\"数组去重怎么实现？\"><a href=\"#数组去重怎么实现？\" class=\"headerlink\" title=\"数组去重怎么实现？\"></a>数组去重怎么实现？</h2><p>1、可以使用for循环去重</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">* 新建一新数组，遍历传入数组，值不在新数组就push进该新数组中</span></span><br><span class=\"line\"><span class=\"comment\">* IE8以下不支持数组的indexOf方法</span></span><br><span class=\"line\"><span class=\"comment\">* */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">uniq</span>(<span class=\"params\">array</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> temp = []; <span class=\"comment\">//一个新的临时数组</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; array.length; i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(temp.indexOf(array[i]) == <span class=\"number\">-1</span>)&#123;</span><br><span class=\"line\">            temp.push(array[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> temp;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> aa = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">2</span>,<span class=\"number\">4</span>,<span class=\"number\">9</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>,<span class=\"number\">5</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">5</span>];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(uniq(aa));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//优化遍历数组法</span></span><br><span class=\"line\"><span class=\"comment\">// 思路：获取没重复的最右一值放入新数组</span></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">* 推荐的方法 *</span></span><br><span class=\"line\"><span class=\"comment\">* 方法的实现代码相当酷炫，</span></span><br><span class=\"line\"><span class=\"comment\">* 实现思路：获取没重复的最右一值放入新数组。</span></span><br><span class=\"line\"><span class=\"comment\">* （检测到有重复值时终止当前循环同时进入顶层循环的下一轮判断）*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">uniq</span>(<span class=\"params\">array</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> temp = [];</span><br><span class=\"line\">    <span class=\"keyword\">var</span> index = [];</span><br><span class=\"line\">    <span class=\"keyword\">var</span> l = array.length;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; l; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> j = i + <span class=\"number\">1</span>; j &lt; l; j++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (array[i] === array[j])&#123;</span><br><span class=\"line\">                i++;</span><br><span class=\"line\">                j = i;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        temp.push(array[i]);</span><br><span class=\"line\">        index.push(i);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(index);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> temp;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> aa = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">5</span>,<span class=\"number\">3</span>,<span class=\"number\">6</span>,<span class=\"number\">5</span>];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(uniq(aa));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//对象键值法去重</span></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">* 速度最快， 占空间最多（空间换时间）</span></span><br><span class=\"line\"><span class=\"comment\">* 该方法执行的速度比其他任何方法都快， 就是占用的内存大一些。</span></span><br><span class=\"line\"><span class=\"comment\">* 现思路：新建一js对象以及新数组，遍历传入数组时，判断值是否为js对象的键，</span></span><br><span class=\"line\"><span class=\"comment\">* 不是的话给对象新增该键并放入新数组。</span></span><br><span class=\"line\"><span class=\"comment\">* 注意点：判断是否为js对象键时，会自动对传入的键执行“toString()”，</span></span><br><span class=\"line\"><span class=\"comment\">* 不同的键可能会被误认为一样，例如n[val]-- n[1]、n[\"1\"]；</span></span><br><span class=\"line\"><span class=\"comment\">* 解决上述问题还是得调用“indexOf”。*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">uniq</span>(<span class=\"params\">array</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> temp = &#123;&#125;, r = [], len = array.length, val, type;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">        val = array[i];</span><br><span class=\"line\">        type = <span class=\"keyword\">typeof</span> val;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!temp[val]) &#123;</span><br><span class=\"line\">            temp[val] = [type];</span><br><span class=\"line\">            r.push(val);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (temp[val].indexOf(type) &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            temp[val].push(type);</span><br><span class=\"line\">            r.push(val);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> r;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> aa = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"string\">\"2\"</span>,<span class=\"number\">4</span>,<span class=\"number\">9</span>,<span class=\"string\">\"a\"</span>,<span class=\"string\">\"a\"</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">5</span>];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(uniq(aa));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//数组下标法</span></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">* 还是得调用“indexOf”性能跟方法1差不多，</span></span><br><span class=\"line\"><span class=\"comment\">* 实现思路：如果当前数组的第i项在当前数组中第一次出现的位置不是i，</span></span><br><span class=\"line\"><span class=\"comment\">* 那么表示第i项是重复的，忽略掉。否则存入结果数组。</span></span><br><span class=\"line\"><span class=\"comment\">* */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">uniq</span>(<span class=\"params\">array</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> temp = [];</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; array.length; i++) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//如果当前数组的第i项在当前数组中第一次出现的位置是i，才存入数组；否则代表是重复的</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(array.indexOf(array[i]) == i)&#123;</span><br><span class=\"line\">            temp.push(array[i])</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> temp;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> aa = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"string\">\"2\"</span>,<span class=\"number\">4</span>,<span class=\"number\">9</span>,<span class=\"string\">\"a\"</span>,<span class=\"string\">\"a\"</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">5</span>];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(uniq(aa));</span><br></pre></td></tr></table></figure>\n<p>2、利用hash表去重</p>\n<p>3、先排序后去重</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//排序后相邻去除法</span></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">* 给传入数组排序，排序后相同值相邻，</span></span><br><span class=\"line\"><span class=\"comment\">* 然后遍历时,新数组只加入不与前一值重复的值。</span></span><br><span class=\"line\"><span class=\"comment\">* 会打乱原来数组的顺序</span></span><br><span class=\"line\"><span class=\"comment\">* */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">uniq</span>(<span class=\"params\">array</span>)</span>&#123;</span><br><span class=\"line\">    array.sort();</span><br><span class=\"line\">    <span class=\"keyword\">var</span> temp=[array[<span class=\"number\">0</span>]];</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">1</span>; i &lt; array.length; i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>( array[i] !== temp[temp.length<span class=\"number\">-1</span>])&#123;</span><br><span class=\"line\">            temp.push(array[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> temp;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> aa = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"string\">\"2\"</span>,<span class=\"number\">4</span>,<span class=\"number\">9</span>,<span class=\"string\">\"a\"</span>,<span class=\"string\">\"a\"</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">5</span>];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(uniq(aa));</span><br></pre></td></tr></table></figure>\n<p>4、Set方式去重</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> removeDuplicateItems = <span class=\"function\"><span class=\"params\">arr</span> =&gt;</span> [...new <span class=\"built_in\">Set</span>(arr)]; <span class=\"built_in\">console</span>.log(removeDuplicateItems([<span class=\"number\">42</span>, <span class=\"string\">'foo'</span>, <span class=\"number\">42</span>, <span class=\"string\">'foo'</span>, <span class=\"literal\">true</span>, <span class=\"literal\">true</span>])); <span class=\"comment\">// =&gt; [42, \"foo\", true]</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"Javascript-基础数据类型？\"><a href=\"#Javascript-基础数据类型？\" class=\"headerlink\" title=\"Javascript 基础数据类型？\"></a>Javascript 基础数据类型？</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">number(数值)</span><br><span class=\"line\">string(字符串)</span><br><span class=\"line\">Boolean(布尔)</span><br><span class=\"line\">null(空)</span><br><span class=\"line\">undefined(未定义)</span><br><span class=\"line\">引用类型有：object</span><br></pre></td></tr></table></figure>\n<h2 id=\"谈一谈Javascript作用域链？\"><a href=\"#谈一谈Javascript作用域链？\" class=\"headerlink\" title=\"谈一谈Javascript作用域链？\"></a>谈一谈Javascript作用域链？</h2><p>当执行一段JS代码(全局代码或函数)时，JS引擎会创建一个作用域又称为执行上下文，在页面加载后会首先创建一个全局的作用域，然后每执行一个函数，会建立一个对应的作用域，从而形成了一条作用域链。每个作用域都有一条对应的作用域链，链头是全局作用域，链尾是当前函数作用域。</p>\n<p>作用域链作用是用于解析标识符，当函数被创建时（不是执行），会将this.arguments、命名参数和该函数中的所有局部变量添加到该当前作用域中，当JS需要查找变量X的时候，这个过程称为变量解析，它首先会直到查找到链头，也就是全局作用域链，仍未找到该变量的话，就认为这段代码的作用域上不存在X变量，并抛出引用错误的异常。</p>\n<h2 id=\"如何理解JS原型链？\"><a href=\"#如何理解JS原型链？\" class=\"headerlink\" title=\"如何理解JS原型链？\"></a>如何理解JS原型链？</h2><p>JS中的每一个prototype属性，我们称之为原型，而原型的值也是对象，因此它也有自己的原型，这样就串联起来了一条原型链，原型链的链头是object，它的prototype比较特殊，值为null。</p>\n<p>原型链的作用是用于对象继承，函数A的原型属性是一个对象，当这个函数被用作构造函数来创建实例时，该函数的原型属性将被作为原型赋值给所有对象实例，比如我们新建一个数组，数组的方法便从数组的原型上继承而来。</p>\n<p>当访问对象的一个属性时，首先查找对象本身，找到则返回；若未找到，则继续查找其原型对象的属性（如果还找不到实际上会沿着原型链向上查找，直到根），只要没有被覆盖的话，对象原型的属性就能在所有的实例中找到，若整个原型链未找到则返回undefined.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">总结：</span><br><span class=\"line\"></span><br><span class=\"line\">1、每个函数对象都有一个 prototype 属性， 这个属性就是函数的原型对象</span><br><span class=\"line\"></span><br><span class=\"line\">2、原型链式 JavaScript 实现继承的重要方式，原型链的形成是真正是靠__proto__而非prototype</span><br></pre></td></tr></table></figure>\n<h2 id=\"（重点）如何理解和应用JS闭包？\"><a href=\"#（重点）如何理解和应用JS闭包？\" class=\"headerlink\" title=\"（重点）如何理解和应用JS闭包？\"></a>（重点）如何理解和应用JS闭包？</h2><p>简单的理解是函数的嵌套形成闭包，闭包包括函数本身以及它的外部作用域，函数a内嵌套b，且返回b，当调用函数a时，用变量接收函数b，就形成了闭包。</p>\n<p>优点：</p>\n<p>① 减少全局变量。</p>\n<p>② 减少传递函数的参数量</p>\n<p>③ 封装</p>\n<p>缺点：延长了作用域链，需要释放的变量不能及时释放，可能引发内存泄漏，其实说白了就是该内存空间使用完毕之后未回收，即所谓内存泄漏，最终，结果是程序运行时间越长，占用存储空间越来越多，最终用尽全部存储空间，整个系统崩溃。(<strong>使用闭包会占有内存资源，过多的使用闭包会导致内存溢出等.</strong>)</p>\n<p>最简洁、直击要害的回答，我能想到的分别有这么三句</p>\n<p><strong>1、闭包是一个有状态</strong>（不消失的私有数据）<strong>的函数。</strong></p>\n<p><strong>2、闭包是一个有记忆的函数。</strong></p>\n<p><strong>3、闭包相当于一个只有一个方法的紧凑对象</strong>（a compact object）。 </p>\n<p><strong>通俗的讲：就是函数a的内部函数b，被函数a外部的一个变量引用的时候，就创建了一个闭包。</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//这样在执行完var c=a()后，变量c实际上是指向了函数b，再执行c()后就会弹出一个窗口显示i的值(第一次为1)。这段代码其实就创建了一个闭包，为什么？因为函数a外的变量c引用了函数a内的函数b</span></span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">a</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">           <span class=\"keyword\">var</span> i=<span class=\"number\">0</span>;</span><br><span class=\"line\">           <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">b</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">              alert(++i);</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">              <span class=\"keyword\">return</span> b;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"keyword\">var</span> c = a();</span><br><span class=\"line\">        c();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 更容易理解的闭包</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f1</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> num = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 定义内部函数</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f2</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> num + <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 返回 f2函数引用</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> f2;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// bar 变量也指向 f2 函数，在此也是一个闭包</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> bar = f1();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 执行</span></span><br><span class=\"line\">bar();  <span class=\"comment\">//1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 我们知道，函数中的变量会随着函数的执行完毕后会被销毁。而如上的代码，f1() 函数执行完毕后，将 f2 函数赋值给一个全局变量，而 f2 函数的变量又依赖 f1 的 num 变量，因此，f1中的 num 变量并不会随着 f1 的函数执行完毕后而销毁</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"Javascript代理？\"><a href=\"#Javascript代理？\" class=\"headerlink\" title=\"Javascript代理？\"></a>Javascript代理？</h2><p>当我们需要对很多元素添加事件的时候，可以通过将事件添加到它们的父节点而将事件委托给父节点来触发处理函数。</p>\n<h2 id=\"HTML5有哪些新特性？移除了哪些元素？如何处理HTML5新标签的浏览兼容问题？如何区别HTML和HTML5？\"><a href=\"#HTML5有哪些新特性？移除了哪些元素？如何处理HTML5新标签的浏览兼容问题？如何区别HTML和HTML5？\" class=\"headerlink\" title=\"HTML5有哪些新特性？移除了哪些元素？如何处理HTML5新标签的浏览兼容问题？如何区别HTML和HTML5？\"></a>HTML5有哪些新特性？移除了哪些元素？如何处理HTML5新标签的浏览兼容问题？如何区别HTML和HTML5？</h2><p>1、HTML5现在已经不是SGML的子集，主要是关于图像，位置，存储，多任务等功能的增加；</p>\n<p>2、用于媒介回放的 <em>video</em> 和 <em>audio</em> 元素</p>\n<p>3、本地离线存储localStorge长期存储数据，浏览器关闭后数据不会丢失。</p>\n<p>4、语义化更好的内容元素，比如article、footer、header、nav、section</p>\n<p>5、新的技术webworker、websockt、geolocation移除的元素</p>\n<p>6、对可用性产生负面影响的元素：frame、frameset、noframes，支持HTML5标签</p>\n<p>7、IE8/IE7/IE6支持通过docment.createElement 方法产生的标签</p>\n<p>8、浏览器支持新标签后，还需要添加标签默认的样式</p>\n<h2 id=\"CSS隐藏元素的几种方法？\"><a href=\"#CSS隐藏元素的几种方法？\" class=\"headerlink\" title=\"CSS隐藏元素的几种方法？\"></a>CSS隐藏元素的几种方法？</h2><p>1、opacity： 透明度</p>\n<p>2、visibility： 可见的</p>\n<p>3、display： 显示</p>\n<p>4、position： 位置</p>\n<h2 id=\"重点-性能优化的方法？\"><a href=\"#重点-性能优化的方法？\" class=\"headerlink\" title=\"(重点) 性能优化的方法？\"></a>(重点) 性能优化的方法？</h2><p>1、减小http请求：css Sprites，JS，css源码压缩，图片大小控制合适；网页Gzip，CDN托管，data缓存，图片服务器</p>\n<p>2、用innerHTML代替DOM操作，减小DOM操作次数，优化Javascript性能</p>\n<p>3、避免使用CSS Expression（CSS表达式）又称Dynamic properties（动态属性）</p>\n<p>4、当需要设置的样式很多时设置 className 而不是直接操作style</p>\n<p>5、图片预加载，将样式表放在顶部，将脚本放在底部加上时间戳</p>\n<h2 id=\"一个页面从输入URL到页面加载显示完成，这个过程中都发生了什么？\"><a href=\"#一个页面从输入URL到页面加载显示完成，这个过程中都发生了什么？\" class=\"headerlink\" title=\"一个页面从输入URL到页面加载显示完成，这个过程中都发生了什么？\"></a>一个页面从输入URL到页面加载显示完成，这个过程中都发生了什么？</h2><p>4个步骤：</p>\n<p>1、当发送一个URL请求时，不管这个URL是web页面的URL还是web页面上每个资源的URL，浏览器都会开启一个线程来处理这个请求，同时在远程DNS服务器上启动一个DNS查询，这能使浏览器获取请求对应的IP地址</p>\n<p>2、浏览器与远程web服务器通过TCP三次握手协商来建立一个TCP/IP 连接。该握手包括一个同步报文，一个同步-应答报文和一个应答报文，这三个报文在浏览器和服务器之间传递。该握手首先由服务端尝试建立起通信，而后服务器应答并接受客户端的请求，最后由客户端发出该请求已经被接受的报文。</p>\n<p>3、一旦TCP/IP 连接建立，浏览器会通过该连接向远程服务器发送HTTP和GET请求。远程服务器找到资源并使用HTTP响应返回该资源，值为200 的 HTTP 响应状态表示一个正确的响应</p>\n<p>4、此时，web服务器提供资源服务，客户端开始下载资源。</p>\n<h4 id=\"简洁版\"><a href=\"#简洁版\" class=\"headerlink\" title=\"简洁版\"></a>简洁版</h4><p><em>浏览器根据请求的URL交给DNS域名解析，找到真实的IP，向服务器发起请求；</em></p>\n<p><em>服务器交给后台处理完成后返回数据，浏览器接收文件(HTML，JS，CSS，图像等等)；</em></p>\n<p><em>浏览器对加载到的资源进行语法解析，建立相应的内部数据结构；</em></p>\n<p><em>载入解析到的资源文件，渲染页面，完成。</em></p>\n<h2 id=\"Javascript对象的几种创建方法？\"><a href=\"#Javascript对象的几种创建方法？\" class=\"headerlink\" title=\"Javascript对象的几种创建方法？\"></a>Javascript对象的几种创建方法？</h2><p>1、工厂模式</p>\n<p>2、构造函数模式</p>\n<p>3、原型模式</p>\n<p>4、混合构造函数和原型模式</p>\n<p>5、动态原型模式</p>\n<p>6、寄生构造函数模式</p>\n<p>7、稳妥构造函数模式</p>\n<h2 id=\"Javascript继承的6种方法？\"><a href=\"#Javascript继承的6种方法？\" class=\"headerlink\" title=\"Javascript继承的6种方法？\"></a>Javascript继承的6种方法？</h2><p>1、原型链继承</p>\n<p>2、借用构造函数继承</p>\n<p>3、组合继承（原型 + 借用构造）</p>\n<p>4、原型式继承</p>\n<p>5、寄生式继承</p>\n<p>6、寄生组合式继承</p>\n<h2 id=\"AJAX过程？\"><a href=\"#AJAX过程？\" class=\"headerlink\" title=\"AJAX过程？\"></a>AJAX过程？</h2><p>1#   创建XMLHttpRequest 对象，也就是创建一个异步调用对象</p>\n<p>2#  创建一个新的 HTTP 请求，并指定该 HTTP 请求的方法， URL 及验证信息</p>\n<p>3#  设置响应 HTTP 请求状态变化的函数</p>\n<p>4#  发送HTTP请求</p>\n<p>5#  获取异步调用返回的数据</p>\n<p>6#  使用 Javascript 和 DOM 实现局部刷新</p>\n<p>另一个说法：</p>\n<p>1、服务器获得请求参数</p>\n<p>2、服务器处理请求参数（添加，查询等操作）</p>\n<p>3、服务器响应数据给浏览器</p>\n<p>AJAX 引擎获得服务端响应的数据，通过执行JS的回调函数将数据传递给浏览器页面</p>\n<p>1、通过设置而给Ajax引擎的回调函数获得服务器响应的数据</p>\n<p>2、使用JS在指定的位置，显示响应数据，从而局部修改页面的数据，达到局部刷新目的。</p>\n<h2 id=\"JSONP原理是什么？\"><a href=\"#JSONP原理是什么？\" class=\"headerlink\" title=\"JSONP原理是什么？\"></a>JSONP原理是什么？</h2><p>首先客户端注册一个callback，然后callback的名字传给服务器。此时，服务器生成 json 数据，然后以 JS 方法的方式，生成 function，function 名字就是传递上来带参数jsonp。最后将 json 数据直接以入参的方式，放置 function 中，这样就生成JS语法的文档，返回给客户端，客户端浏览器，解析script 变迁，并执行返回JS文档，此时数据作为参数，传入了客户端预先定义好的 callback 函数里。简单地说，就是利用script 标签没有跨域限制的 “漏洞” 来达到与第三方通讯的目的。</p>\n<p>json是一种数据格式，jsonp是一种数据调用的方式，带 callback 的 json 就是 jsonp</p>\n<h2 id=\"JSONP的缺点？\"><a href=\"#JSONP的缺点？\" class=\"headerlink\" title=\"JSONP的缺点？\"></a>JSONP的缺点？</h2><p>jsonp有个缺陷就是只能get</p>\n<p>而且会把请求的内容发送到url中导致安全性极低</p>\n<h2 id=\"移动端性能优化？\"><a href=\"#移动端性能优化？\" class=\"headerlink\" title=\"移动端性能优化？\"></a>移动端性能优化？</h2><p>尽量使用CSS动画，开启硬件加速。适应使用 touch 事件代替 click 事件。避免使用 CSS3 渐变阴影效果。</p>\n<p>尽可能少的使用 box-shadow（阴影） 与 gradients（渐变）。box-shadow 与 gradients 往往都是页面的性能杀手。</p>\n<h2 id=\"说说你this的理解？\"><a href=\"#说说你this的理解？\" class=\"headerlink\" title=\"说说你this的理解？\"></a>说说你this的理解？</h2><p>在JS中，this通常指向的是我们正在执行的函数本身，或者是指向该函数所属的对象。</p>\n<p>1、普通函数中 this 是window</p>\n<p>2、构造函数中 this 是当前的实例对象</p>\n<p>3、对象中的 this 是指其本身</p>\n<p>4、原型对象的方法中 this 是当前的实例对象</p>\n<p>5、计时器中 this 是 window</p>\n<p>6、事件处理函数，this 是触发该事件的对象</p>\n<h2 id=\"如何编写高性能的JS？\"><a href=\"#如何编写高性能的JS？\" class=\"headerlink\" title=\"如何编写高性能的JS？\"></a>如何编写高性能的JS？</h2><p>1、使用 DocumentFragment 优化多次 append</p>\n<p>2、通过模板元素clone，替代 createElement</p>\n<p>3、使用一次innerHTML 赋值代构建 DOM 元素</p>\n<p>4、使用 firstChild 和 nextSibling 代替 childNods 遍历 DOM 元素</p>\n<p>5、使用 Array 作为 StringBuffter ，代替字符串拼接的操作</p>\n<p>6、将循环控制量保存到局部变量</p>\n<p>7、顺序无关的遍历时，用 while 代替 for</p>\n<p>8、将条件分支，按可能性顺序从到低排列</p>\n<p>9、在同一条件子的多（&gt; 2）条件分支时，使用 switch 优于 if</p>\n<p>10、在使用三目运算符替代条件分支</p>\n<p>11、需要不断执行的时间后，优先考虑使用 setInterval</p>\n<h2 id=\"哪些操作会造成内存泄漏？\"><a href=\"#哪些操作会造成内存泄漏？\" class=\"headerlink\" title=\"哪些操作会造成内存泄漏？\"></a>哪些操作会造成内存泄漏？</h2><p>所谓的内存泄漏，就是在您不再拥有或需要它的时候，仍然存在</p>\n<p>垃圾回收机制会定期扫描对象，并计算引用了每个对象的其他对象的数量，如果一个对象的没有被其他对象引用过，或该对象的唯一引用是循环的，那么该对象内存即可回收。</p>\n<p>1、setTimeout 的第一个参数使用字符串而非函数的话， 会引发内泄漏</p>\n<p>2、闭包</p>\n<p>3、控制台日志</p>\n<p>4、循环（在两个对象彼此引用且彼此保留时，就会产生一个循环）</p>\n<h2 id=\"ES6更新了哪些新特性？\"><a href=\"#ES6更新了哪些新特性？\" class=\"headerlink\" title=\"ES6更新了哪些新特性？\"></a>ES6更新了哪些新特性？</h2><ol>\n<li><p><strong>默认参数</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//ES5我们这样定义默认参数</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> link = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">height, color, url</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> height = height || <span class=\"number\">50</span>;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> color = color || <span class=\"string\">'red'</span>;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> url = url || <span class=\"string\">'http://azat.co'</span>;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样做是有一点小问题的，当默认参数为0时就暴露问题了，因为在JavaScript中，0表示false。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ES6可以默认值写在函数声明里</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> link = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">height = <span class=\"number\">50</span>, color = <span class=\"string\">'red'</span>, url = <span class=\"string\">'http://azat.co'</span></span>) </span>&#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<ol start=\"2\">\n<li><p><strong>模板文本</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ES5的字符串拼接</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> name = <span class=\"string\">'Your name is '</span> + first + <span class=\"string\">' '</span> + last + <span class=\"string\">'.'</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> url = <span class=\"string\">'http://localhost:3000/api/messages/'</span> + id;</span><br></pre></td></tr></table></figure>\n<p>ES6的字符串远不用如此麻烦，我们可以在反引号（~符的unshift键）中使用新语法 <strong>${变量名称}</strong> 表示。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ES6</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> name = <span class=\"string\">`Your name is <span class=\"subst\">$&#123;first&#125;</span> <span class=\"subst\">$&#123;last&#125;</span>. `</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> url = <span class=\"string\">`http://localhost:3000/api/messages/<span class=\"subst\">$&#123;id&#125;</span>`</span>;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>多行字符串</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ES5 多行字符串需要 + 号连接</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> roadPoem = <span class=\"string\">'Then took the other, as just as fair,nt'</span></span><br><span class=\"line\">    + <span class=\"string\">'And having perhaps the better claimnt'</span></span><br><span class=\"line\">    + <span class=\"string\">'Because it was grassy and wanted wear,nt'</span></span><br><span class=\"line\">    + <span class=\"string\">'Though as for that the passing therent'</span></span><br><span class=\"line\">    + <span class=\"string\">'Had worn them really about the same,nt'</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> fourAgreements = <span class=\"string\">'You have the right to be you.n</span></span><br><span class=\"line\"><span class=\"string\">    You can only be you when you do your best.'</span>;</span><br></pre></td></tr></table></figure>\n<p>然而在ES6中，仅仅用反引号就可以解决了：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> roadPoem = <span class=\"string\">`Then took the other, as just as fair,</span></span><br><span class=\"line\"><span class=\"string\">    And having perhaps the better claim</span></span><br><span class=\"line\"><span class=\"string\">    Because it was grassy and wanted wear,</span></span><br><span class=\"line\"><span class=\"string\">    Though as for that the passing there</span></span><br><span class=\"line\"><span class=\"string\">    Had worn them really about the same,`</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> fourAgreements = <span class=\"string\">`You have the right to be you.</span></span><br><span class=\"line\"><span class=\"string\">    You can only be you when you do your best.`</span>;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<ol start=\"4\">\n<li><p><strong>解构赋值</strong></p>\n<p>这是一个比较难掌握的知识点，我们先用比较简单的例子切入。</p>\n<p>下面这些情况都是很常见的：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//ES5中获取data对象中的属性</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> data = response.data,    <span class=\"comment\">// data has properties info and imageLink </span></span><br><span class=\"line\">    info = data.info,</span><br><span class=\"line\">    imageLink = data.imageLink </span><br><span class=\"line\"><span class=\"comment\">//ES5获取一个模块中的方法</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> stringHandle = <span class=\"built_in\">require</span>(<span class=\"string\">'toolModule'</span>).stringHandle ;</span><br></pre></td></tr></table></figure>\n<p>ES6中，我们可以使用解构处理以上两种情况：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> &#123;info, imageLink&#125; = response.data;</span><br><span class=\"line\"><span class=\"keyword\">var</span> &#123;stringHandle&#125; = <span class=\"built_in\">require</span>(<span class=\"string\">'toolModule'</span>)</span><br></pre></td></tr></table></figure>\n<p>右侧的response.data和require(‘toolModule’)都是对象，与左侧的 { } 格式相同，首先要保证这一点。个人理解{info, imageLink} = response.data像是<strong>{info, imageLink} = {response.data.info, response.data.imageLink}这样一个对应关系</strong>，然后我们就可以直接使用 info 和 imageLink 这两个变量了。</p>\n</li>\n</ol>\n<ol start=\"5\">\n<li><p><strong>增强的对象文本</strong></p>\n<p>下面是一个典型ES5对象文本，里面有一些方法和属性：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> serviceBase = &#123;<span class=\"attr\">port</span>: <span class=\"number\">3000</span>, <span class=\"attr\">url</span>: <span class=\"string\">'azat.co'</span>&#125;,</span><br><span class=\"line\">    getAccounts = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;<span class=\"keyword\">return</span> [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> accountServiceES5 = &#123;</span><br><span class=\"line\">  port: serviceBase.port,</span><br><span class=\"line\">  url: serviceBase.url,</span><br><span class=\"line\">  getAccounts: getAccounts,</span><br><span class=\"line\">   toString: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"built_in\">JSON</span>.stringify(<span class=\"keyword\">this</span>.valueOf());</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  getUrl: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;<span class=\"keyword\">return</span> <span class=\"string\">\"http://\"</span> + <span class=\"keyword\">this</span>.url + <span class=\"string\">':'</span> + <span class=\"keyword\">this</span>.port&#125;,</span><br><span class=\"line\">  valueOf_1_2_3: getAccounts()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果我们想让它更有意思，我们可以用Object.create从serviceBase继承原型的方法：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> accountServiceES5ObjectCreate = <span class=\"built_in\">Object</span>.create(serviceBase)</span><br><span class=\"line\"><span class=\"keyword\">var</span> accountServiceES5ObjectCreate = &#123;</span><br><span class=\"line\">  getAccounts: getAccounts,</span><br><span class=\"line\">  toString: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">JSON</span>.stringify(<span class=\"keyword\">this</span>.valueOf());</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  getUrl: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;<span class=\"keyword\">return</span> <span class=\"string\">\"http://\"</span> + <span class=\"keyword\">this</span>.url + <span class=\"string\">':'</span> + <span class=\"keyword\">this</span>.port&#125;,</span><br><span class=\"line\">  valueOf_1_2_3: getAccounts()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<ol start=\"6\">\n<li><p><strong>箭头函数</strong></p>\n<p>这是我迫不及待想讲的一个特征，CoffeeScript 就是因为它丰富的箭头函数让很多开发者喜爱。在ES6中，也有了丰富的箭头函数。这些丰富的箭头是令人惊讶的因为它们将使许多操作变成现实，比如，</p>\n<p>以前我们使用闭包，this总是预期之外地产生改变，而箭头函数的迷人之处在于，现在你的this可以按照你的预期使用了，身处箭头函数里面，this还是原来的this。</p>\n<p>有了箭头函数在ES6中， 我们就不必用that = this或 self =  this  或 _this = this  或.bind(this)。例如，下面的代码用ES5就不是很优雅：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> _this = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">$(<span class=\"string\">'.btn'</span>).click(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">event</span>)</span>&#123;</span><br><span class=\"line\">  _this.sendData();</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>在ES6中就不需要用 _this = this：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$(<span class=\"string\">'.btn'</span>).click(<span class=\"function\">(<span class=\"params\">event</span>) =&gt;</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.sendData();</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>Promises</strong></p>\n<p>Promises 是一个有争议的话题。因此有许多略微不同的promise 实现语法。Q，bluebird，deferred.js，vow, avow, jquery 一些可以列出名字的。也有人说我们不需要promises，仅仅使用异步，生成器，回调等就够了。但令人高兴的是，在ES6中有标准的Promise实现。</p>\n<p>下面是一个简单的用setTimeout()实现的异步延迟加载函数:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'Yay!'</span>);</span><br><span class=\"line\">&#125;, <span class=\"number\">1000</span>);</span><br></pre></td></tr></table></figure>\n<p>或者用ES6的箭头函数：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> wait1000 =  <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>)=&gt;</span> &#123;</span><br><span class=\"line\">  setTimeout(resolve, <span class=\"number\">1000</span>);</span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'Yay!'</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>块作用域和构造 let 和 const</strong></p>\n<p>在ES6代码中，你可能已经看到那熟悉的身影let。在ES6里let并不是一个花俏的特性，它是更复杂的。Let是一种新的变量申明方式，它允许你把变量作用域控制在块级里面。</p>\n</li>\n</ol>\n<p>   在ES5中，大括号的块级作用域起不了任何作用：</p>\n   <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">calculateTotalAmount</span> (<span class=\"params\">vip</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> amount = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (vip) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> amount = <span class=\"number\">1</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  &#123; </span><br><span class=\"line\">    <span class=\"keyword\">var</span> amount = <span class=\"number\">100</span>;</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"keyword\">var</span> amount = <span class=\"number\">1000</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">  <span class=\"keyword\">return</span> amount;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(calculateTotalAmount(<span class=\"literal\">true</span>));　　　　<span class=\"comment\">// 1000，最后定义的生效，块级作用域无作用</span></span><br></pre></td></tr></table></figure>\n<p>   块级作用域中let定义的变量，只在此块级作用域中生效，外层无法访问。</p>\n   <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">calculateTotalAmount</span> (<span class=\"params\">vip</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> amount = <span class=\"number\">0</span>; </span><br><span class=\"line\">  <span class=\"keyword\">if</span> (vip) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> amount = <span class=\"number\">1</span>; </span><br><span class=\"line\">  &#125; </span><br><span class=\"line\">  &#123; </span><br><span class=\"line\">    <span class=\"keyword\">let</span> amount = <span class=\"number\">100</span>; </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"keyword\">let</span> amount = <span class=\"number\">1000</span>; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">  <span class=\"keyword\">return</span> amount;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(calculateTotalAmount(<span class=\"literal\">true</span>));　　<span class=\"comment\">// 0，用let定义的变量都不可被最外层访问</span></span><br></pre></td></tr></table></figure>\n<p>   这里简单提一下，假如if句改为 <strong>if( vip ){ amount = 1 } ，那么结果是1，因为这样相当于定义了一个全局变量。</strong></p>\n<p>   我们知道，const用于声明常量，同一常量只可声明一次，声明后不可修改，而下面的代码中对于同一常量声明了多次，却没有报错，原因就是每个常量都只属于它所在的块级作用域，互不影响。</p>\n<ol start=\"9\">\n<li><p><strong>类（Classes）</strong></p>\n<p>现在就来看看如何用ES6写一个类吧。ES6没有用函数, 而是使用原型实现类。我们创建一个类baseModel ，并且在这个类里定义了一个constructor 和一个 getName()方法：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">baseModel</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(options, data) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = <span class=\"string\">'Base'</span>;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.url = <span class=\"string\">'http://azat.co/api'</span>;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.data = data;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.options = options;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    getName() &#123; <span class=\"comment\">// class method</span></span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">`Class name: <span class=\"subst\">$&#123;<span class=\"keyword\">this</span>.name&#125;</span>`</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>AccountModel 从类baseModel 中继承而来:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AccountModel</span> <span class=\"keyword\">extends</span> <span class=\"title\">baseModel</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(options, data) &#123;</span><br><span class=\"line\">　　　　<span class=\"comment\">//为了调用父级构造函数，可用super()参数传递：</span></span><br><span class=\"line\">　　　　<span class=\"keyword\">super</span>(&#123;<span class=\"attr\">private</span>: <span class=\"literal\">true</span>&#125;, [<span class=\"string\">'32113123123'</span>, <span class=\"string\">'524214691'</span>]); <span class=\"comment\">//call the parent method with super</span></span><br><span class=\"line\">       <span class=\"keyword\">this</span>.name = <span class=\"string\">'Account Model'</span>;</span><br><span class=\"line\">       <span class=\"keyword\">this</span>.url +=<span class=\"string\">'/accounts/'</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"comment\">// 可以把 accountData 设置成一个属性：</span></span><br><span class=\"line\">　　get accountsData() &#123; <span class=\"comment\">//calculated attribute getter</span></span><br><span class=\"line\">     <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.data;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">----------------------</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> accounts = <span class=\"keyword\">new</span> AccountModel(<span class=\"number\">5</span>);</span><br><span class=\"line\">accounts.getName();    <span class=\"comment\">//Class name: Account Model</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'Data is %s'</span>, accounts.accountsData);    <span class=\"comment\">//Data is  32113123123,524214691</span></span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<ol start=\"10\">\n<li><p><strong>模块（Modules）</strong></p>\n<p>众所周知，在ES6以前JavaScript并不支持本地的模块。人们想出了AMD，RequireJS，CommonJS以及其它解决方法。现在ES6中可以用模块import 和export 操作了。</p>\n</li>\n</ol>\n   <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 在ES5中，你可以在 &lt;script&gt;中直接写可以运行的代码（简称IIFE），或者一些库像AMD。然而在ES6中，你可以用export导入你的类。下面举个例子，在ES5中,module.js有port变量和getAccounts 方法:</span></span><br><span class=\"line\"><span class=\"comment\">// dev.js文件</span></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  port: <span class=\"number\">3000</span>,</span><br><span class=\"line\">  getAccounts: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>   在ES5中，需要依赖require(‘module’) 导入dev.js：</p>\n   <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> service = <span class=\"built_in\">require</span>(<span class=\"string\">'dev.js'</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(service.port); <span class=\"comment\">// 3000</span></span><br></pre></td></tr></table></figure>\n<p>   但在ES6中，我们将用export and import。例如，这是我们用ES6 写的dev.js文件库：</p>\n   <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// dev.js文件</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">var</span> port = <span class=\"number\">3000</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getAccounts</span>(<span class=\"params\">url</span>) </span>&#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>   如果用ES6来导入到文件中，我们需用import {name} from ‘my-module’语法，例如：</p>\n   <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123;port, getAccounts&#125; <span class=\"keyword\">from</span> <span class=\"string\">'dev'</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(port); <span class=\"comment\">// 3000</span></span><br></pre></td></tr></table></figure>\n<p>   或者我们可以在文件中把整个模块导入, 并命名为 service：</p>\n   <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> service <span class=\"keyword\">from</span> <span class=\"string\">'dev'</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(service.port); <span class=\"comment\">// 3000</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"Vue框架面试题\"><a href=\"#Vue框架面试题\" class=\"headerlink\" title=\"Vue框架面试题\"></a>Vue框架面试题</h1><h2 id=\"V-show-指令，v-if-的区别？\"><a href=\"#V-show-指令，v-if-的区别？\" class=\"headerlink\" title=\"V-show 指令，v-if 的区别？\"></a>V-show 指令，v-if 的区别？</h2><p>条件渲染指令，与v-if 不同的是，无论 v-show 的值为 true 或 false，元素都会存在于HTML代码中，而只有当 v-if 的值为true元素才会存在于 THML 代码中，v-show 指令只是设置了元素 CSS 的 style 值。</p>\n<p>使用MVVM模式有4个好处：</p>\n<ol>\n<li><p>低耦合。view 可以独立于model 变化和修改，一个viewModel 可以绑定到不同的view上，当view 变化的时候model可以不变，当 Model 变化的时候 View 也可以不变。</p>\n</li>\n<li><p>可重用性。可以把一些视图的逻辑放在viewModel 里面，让很多View 重用这段视图逻辑</p>\n</li>\n<li><p>独立开发。开发人员专注与业务逻辑和数据的开发。设计人员可以专注于界面（View）的设计</p>\n</li>\n<li><p>可测试性。可以针对viewModel 来对界面进行测试</p>\n<p><img src=\"https://zhanglong292383147.gitee.io/picture_images/picture/Mianjingxuan/MVVM模式工作原理.png\" alt=\"\"></p>\n</li>\n</ol>\n<p>Vue.js 特点：</p>\n<p>简洁：页面由HTML模式板 + JSON数据 + Vue 案例组成</p>\n<p>数据驱动：自动计算属性和追踪依赖的模板表达式</p>\n<p>组件化：用于复用、解耦的组件来构造页面</p>\n<p>轻量：代码量小，不依赖其他库</p>\n<p>快速：精确有效批量 DOM 更新</p>\n<p>模板友好：可通过npm，bower等多种方式安装，很容易融入</p>\n<h2 id=\"怎么定义-vue-router-的动态路由？怎么获取传过来的动态参数？\"><a href=\"#怎么定义-vue-router-的动态路由？怎么获取传过来的动态参数？\" class=\"headerlink\" title=\"怎么定义 vue-router 的动态路由？怎么获取传过来的动态参数？\"></a>怎么定义 vue-router 的动态路由？怎么获取传过来的动态参数？</h2><p>在 router 目录下的index.js文件中，对 path 属性上 /:id 的 params.id 使用 router 对象</p>\n<h2 id=\"vue-router-有哪种导航钩子？\"><a href=\"#vue-router-有哪种导航钩子？\" class=\"headerlink\" title=\"vue-router 有哪种导航钩子？\"></a>vue-router 有哪种导航钩子？</h2><p>第一种：是全局导航钩子：router.beforeEach（to，from，next），作用：跳转前进进行判断拦截</p>\n<p>第二种：组件内的钩子</p>\n<p>第三种：单独路由独享组件</p>\n<h2 id=\"v-model-是什么？怎么使用？vue-中标签怎么绑定事件？\"><a href=\"#v-model-是什么？怎么使用？vue-中标签怎么绑定事件？\" class=\"headerlink\" title=\"v-model 是什么？怎么使用？vue 中标签怎么绑定事件？\"></a>v-model 是什么？怎么使用？vue 中标签怎么绑定事件？</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">可以实现双向绑定，指令 （v-class，v-for，v-if，v-show，v-on） vue 的 model 层的 data 属性。绑定事件&lt;input @click=del() /&gt;</span><br></pre></td></tr></table></figure>\n<h2 id=\"vuex-是什么？怎么使用？哪种功能场景使用它？\"><a href=\"#vuex-是什么？怎么使用？哪种功能场景使用它？\" class=\"headerlink\" title=\"vuex 是什么？怎么使用？哪种功能场景使用它？\"></a>vuex 是什么？怎么使用？哪种功能场景使用它？</h2><p>Vuex 是一个专为 Vue.js 应用程序开发的<strong>状态管理模式</strong>，在main.js 引入ctore，注入。新建一个目录 store、…export 场景有：单页应用中，组件之间的状态音乐播放器，登录状态，加入购物车</p>\n<hr>\n<p>每一个 Vuex 应用的核心就是 store（仓库）。“store”基本上就是一个容器，它包含着你的应用中大部分的<strong>状态 (state)</strong>。Vuex 和单纯的全局对象有以下两点不同：</p>\n<ol>\n<li>Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。</li>\n<li>你不能直接改变 store 中的状态。改变 store 中的状态的唯一途径就是显式地<strong>提交 (commit) mutation</strong>。这样使得我们可以方便地跟踪每一个状态的变化，从而让我们能够实现一些工具帮助我们更好地了解我们的应用。</li>\n</ol>\n<h2 id=\"你是怎么认识-Vuex-的？\"><a href=\"#你是怎么认识-Vuex-的？\" class=\"headerlink\" title=\"你是怎么认识 Vuex 的？\"></a>你是怎么认识 Vuex 的？</h2><p>Vuex 可以理解为一种开发模式或框架。通过状态（数据源）集中管理驱动组件的变化。</p>\n<p>应用级的状态集中放在 store（仓库） 中，改变状态的方式是提交 mutations，这是个同步的事物，异步逻辑应该封装在 action 中</p>\n<p><img src=\"https://zhanglong292383147.gitee.io/picture_images/picture/Mianjingxuan/Vuex是什么.jpg\" alt=\"\"></p>\n<ul>\n<li><strong>state</strong>，驱动应用的数据源；</li>\n<li><strong>view</strong>，以声明方式将 <strong>state</strong> 映射到视图；</li>\n<li><strong>actions</strong>，响应在 <strong>view</strong> 上的用户输入导致的状态变化。</li>\n</ul>\n<h2 id=\"vue-router是什么？它有哪些组件？\"><a href=\"#vue-router是什么？它有哪些组件？\" class=\"headerlink\" title=\"vue-router是什么？它有哪些组件？\"></a>vue-router是什么？它有哪些组件？</h2><p>vue用来写路由一个插件router-link，router-view</p>\n<h2 id=\"Vue的双向数据绑定原理是什么？\"><a href=\"#Vue的双向数据绑定原理是什么？\" class=\"headerlink\" title=\"Vue的双向数据绑定原理是什么？\"></a>Vue的双向数据绑定原理是什么？</h2><p><img src=\"https://zhanglong292383147.gitee.io/picture_images/picture/Mianjingxuan/VUE双向绑定原理.png\" alt=\"\"></p>\n<p>这里VM，就是 vue框架它相当于中间枢纽的作用，连接着 model 和 view</p>\n<p>当前台显示的 view 发生变化了，它会实时反应到 viewModel（上，如果有需要，viewModel会通过 Ajax 等方法将改变的数据传递给后台 model）</p>\n<p>同时从后台 model 获取过来的数据，通过 VM 将值响应到前台 UI 上</p>\n<p><img src=\"https://zhanglong292383147.gitee.io/picture_images/picture/Mianjingxuan/input事件数据绑定原理.png\" alt=\"\"></p>\n<p>VM的核心是 view 和 data</p>\n<p>当 data 有变化的时候它通过 <strong>object.defineProperty()</strong>  方法中的 <strong>set</strong> 方法进行监控，并调用在此之前已经定义好 <strong>data</strong> 和 <strong>view</strong> 的关系了的回调函数，来通知 view 进行数据的改变。</p>\n<p>而 view 发生改变则是通过底层的 input 事件来进行 data 的响应更改</p>\n<p>Vue 是通过 <strong>object.defineProperty()</strong> 来实现<strong>数据劫持</strong>的。（它可以来控制一个对象属性的一些特有操作，比如读写权、是否可以枚举）</p>\n<p>实现方法：观察者模式</p>\n<p>MVVM 框架类：</p>\n<p><img src=\"https://zhanglong292383147.gitee.io/picture_images/picture/Mianjingxuan/观察者模式的MVVM框架的工作原理.png\" alt=\"\"></p>\n<p>Observer（object.defineProperty 中的 set）<strong>监听</strong> data 的变化，当 data <strong>有变化</strong>的时候<strong>通知</strong>观察者列表 <strong>Dep</strong>（里面有与 Data 变化对应的Update 函数），watcher<strong>（监听器）</strong> 负责向<strong>观察者列表</strong>（Dep）<strong>添加</strong>（订阅）对应的<strong>更新函数</strong>，Dep 里的更新函数执行了之后将<em>最新的值</em> <strong>更新</strong> 到 <strong>View（视图）</strong>上</p>\n<h2 id=\"请详细说下你对-Vue-生命周期的理解？\"><a href=\"#请详细说下你对-Vue-生命周期的理解？\" class=\"headerlink\" title=\"请详细说下你对 Vue 生命周期的理解？\"></a>请详细说下你对 Vue 生命周期的理解？</h2><p>总共分 为 8个阶段：创建前 / 后，载入前 / 载入后，更新前 / 后，销毁前 / 后</p>\n<p>创建前 / 后：在 <strong>beforeCreate (创建前)</strong> 阶段，Vue实例的<strong>挂载元素</strong> el 和<strong>数据对象</strong> data 都为 <strong>undefined</strong>，还未初始化。在 <strong>created (创建后)</strong> 阶段，Vue 实例的<strong>数据对象</strong> data <strong>有</strong>了,  <strong>el</strong> 还<strong>没有</strong>。</p>\n<p>载入前 / 后：在<strong>beforeMount</strong> 阶段，Vue实例的 <strong>el</strong> 和 <strong>data</strong> 都<strong>初始化</strong>了，但还是挂载之前为虚拟的 DOM 节点，data.message 还未替换。在 <strong>mounted</strong> 阶段，Vue实例<strong>挂载完成</strong>，data.message 成功 <strong>渲染</strong></p>\n<p>更新前 / 后：当 <strong>data</strong> 变化时，会<strong>触发</strong> beforeUpdate 和 updated 方法。</p>\n<p>销毁前 / 后：在执行 destroy 方法后，对 data 的改变不会再触发函数，说明此时 Vue 实例已经<strong>解除</strong>了<strong>事件监听</strong>以及和 <strong>DOM 的绑定</strong>，但是 dom <strong>结构</strong>依然<strong>存在</strong></p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"app\"</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>&#123;&#123;info&#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">button</span> @<span class=\"attr\">click</span>=<span class=\"string\">\"info='hello1'\"</span>&gt;</span>更新info<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">button</span> @<span class=\"attr\">click</span>=<span class=\"string\">\"destroy\"</span>&gt;</span>销毁实例<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"keyword\">var</span> vm = <span class=\"keyword\">new</span> Vue(&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">            el: <span class=\"string\">\"#app\"</span>,</span></span><br><span class=\"line\"><span class=\"undefined\">            data: &#123;</span></span><br><span class=\"line\"><span class=\"javascript\">                info: <span class=\"string\">\"hello\"</span></span></span><br><span class=\"line\"><span class=\"undefined\">            &#125;,</span></span><br><span class=\"line\"><span class=\"javascript\">            <span class=\"comment\">// 在实例初始化之后，数据观测 (data observer) 和 event/watcher 配置之前被调用。</span></span></span><br><span class=\"line\"><span class=\"javascript\">            beforeCreate: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">                <span class=\"built_in\">console</span>.log(<span class=\"string\">\"===============beforeCreate============================================\"</span>)</span></span><br><span class=\"line\"><span class=\"javascript\">                <span class=\"comment\">// $el表示Vue 实例使用的根 DOM 元素。</span></span></span><br><span class=\"line\"><span class=\"javascript\">                <span class=\"built_in\">console</span>.log(<span class=\"string\">'$el'</span>, <span class=\"keyword\">this</span>.$el);</span></span><br><span class=\"line\"><span class=\"javascript\">                <span class=\"comment\">// $data Vue 实例观察的数据对象</span></span></span><br><span class=\"line\"><span class=\"javascript\">                <span class=\"built_in\">console</span>.log(<span class=\"string\">'$data'</span>, <span class=\"keyword\">this</span>.$data);</span></span><br><span class=\"line\"><span class=\"javascript\">                <span class=\"built_in\">console</span>.log(<span class=\"string\">\"info:\"</span>, <span class=\"keyword\">this</span>.info)</span></span><br><span class=\"line\"><span class=\"undefined\">            &#125;,</span></span><br><span class=\"line\"><span class=\"javascript\">            <span class=\"comment\">// 在实例创建完成后被立即调用。在这一步，实例已完成以下的配置：数据观测 (data observer)，属性和方法的运算，watch/event 事件回调。然而，挂载阶段还没开始，dom还未生成，$el 属性目前不可见。 一般都在created中发送请求</span></span></span><br><span class=\"line\"><span class=\"javascript\">            created: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">                <span class=\"built_in\">console</span>.log(<span class=\"string\">\"===============created=======================================\"</span>)</span></span><br><span class=\"line\"><span class=\"javascript\">                <span class=\"built_in\">console</span>.log(<span class=\"string\">'$el'</span>, <span class=\"keyword\">this</span>.$el);</span></span><br><span class=\"line\"><span class=\"javascript\">                <span class=\"built_in\">console</span>.log(<span class=\"string\">'$data'</span>, <span class=\"keyword\">this</span>.$data);</span></span><br><span class=\"line\"><span class=\"javascript\">                <span class=\"built_in\">console</span>.log(<span class=\"string\">\"info:\"</span>, <span class=\"keyword\">this</span>.info)</span></span><br><span class=\"line\"><span class=\"undefined\">            &#125;,</span></span><br><span class=\"line\"><span class=\"javascript\">            <span class=\"comment\">// 模板编译挂载之前调用，首先会判断对象是否有el选项。如果有的话就继续向下编译，如果没有el选项，则停止编译，也就意味着停止了生命周期，直到在该vue实例上调用vm.$mount(el)。接着判断是否有template属性，有的话就以template属性中的值作为模板，如果没有的话，就以el属性指向的作为模板。这里会生成vm.$el，但指令尚未被解析</span></span></span><br><span class=\"line\"><span class=\"javascript\">            beforeMount: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">                <span class=\"built_in\">console</span>.log(<span class=\"string\">\"===============beforeMount=========================================\"</span>)</span></span><br><span class=\"line\"><span class=\"javascript\">                <span class=\"built_in\">console</span>.log(<span class=\"string\">'$el'</span>, <span class=\"keyword\">this</span>.$el);</span></span><br><span class=\"line\"><span class=\"javascript\">                <span class=\"built_in\">console</span>.log(<span class=\"string\">'$data'</span>, <span class=\"keyword\">this</span>.$data);</span></span><br><span class=\"line\"><span class=\"javascript\">                <span class=\"built_in\">console</span>.log(<span class=\"string\">\"info:\"</span>, <span class=\"keyword\">this</span>.info)</span></span><br><span class=\"line\"><span class=\"undefined\">            &#125;,</span></span><br><span class=\"line\"><span class=\"javascript\">            <span class=\"comment\">// 模板编译挂载之后调用，vm.$el替换掉el指向的dom</span></span></span><br><span class=\"line\"><span class=\"javascript\">            mounted: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">                <span class=\"built_in\">console</span>.log(<span class=\"string\">\"===============mounted===========================================\"</span>)</span></span><br><span class=\"line\"><span class=\"javascript\">                <span class=\"built_in\">console</span>.log(<span class=\"string\">'$el'</span>, <span class=\"keyword\">this</span>.$el);</span></span><br><span class=\"line\"><span class=\"javascript\">                <span class=\"built_in\">console</span>.log(<span class=\"string\">'$data'</span>, <span class=\"keyword\">this</span>.$data);</span></span><br><span class=\"line\"><span class=\"javascript\">                <span class=\"built_in\">console</span>.log(<span class=\"string\">\"info:\"</span>, <span class=\"keyword\">this</span>.info)</span></span><br><span class=\"line\"><span class=\"undefined\">            &#125;,</span></span><br><span class=\"line\"><span class=\"javascript\">            <span class=\"comment\">// 数据变更导致虚拟DOM重新渲染之前调用</span></span></span><br><span class=\"line\"><span class=\"javascript\">            beforeUpdate: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">                <span class=\"built_in\">console</span>.log(<span class=\"string\">\"===============beforeUpdate============================================\"</span>);</span></span><br><span class=\"line\"><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"undefined\">            &#125;,</span></span><br><span class=\"line\"><span class=\"javascript\">            <span class=\"comment\">// 数据变更导致虚拟DOM重新渲染之后调用</span></span></span><br><span class=\"line\"><span class=\"javascript\">            updated: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">                <span class=\"built_in\">console</span>.log(<span class=\"string\">\"===============updated======================================================\"</span>);</span></span><br><span class=\"line\"><span class=\"undefined\">            &#125;,</span></span><br><span class=\"line\"><span class=\"javascript\">            <span class=\"comment\">// 实例销毁之前调用，在这一步，实例完全可用</span></span></span><br><span class=\"line\"><span class=\"javascript\">            beforeDestroy: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">                <span class=\"built_in\">console</span>.log(<span class=\"string\">\"===============beforeDestroy===============================================\"</span>)</span></span><br><span class=\"line\"><span class=\"javascript\">                <span class=\"built_in\">console</span>.log(<span class=\"string\">'$el'</span>, <span class=\"keyword\">this</span>.$el);</span></span><br><span class=\"line\"><span class=\"javascript\">                <span class=\"built_in\">console</span>.log(<span class=\"string\">'$data'</span>, <span class=\"keyword\">this</span>.$data);</span></span><br><span class=\"line\"><span class=\"javascript\">                <span class=\"built_in\">console</span>.log(<span class=\"string\">\"info:\"</span>, <span class=\"keyword\">this</span>.info)</span></span><br><span class=\"line\"><span class=\"undefined\">            &#125;,</span></span><br><span class=\"line\"><span class=\"javascript\">            <span class=\"comment\">// vue实例指向的所有东西解除绑定，包括watcher、事件、所以的子组件，后续就不再受vue实例控制了</span></span></span><br><span class=\"line\"><span class=\"javascript\">            destroyed: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">                <span class=\"built_in\">console</span>.log(<span class=\"string\">\"===============destroyed================================================\"</span>)</span></span><br><span class=\"line\"><span class=\"javascript\">                <span class=\"built_in\">console</span>.log(<span class=\"string\">'$el'</span>, <span class=\"keyword\">this</span>.$el);</span></span><br><span class=\"line\"><span class=\"javascript\">                <span class=\"built_in\">console</span>.log(<span class=\"string\">'$data'</span>, <span class=\"keyword\">this</span>.$data);</span></span><br><span class=\"line\"><span class=\"javascript\">                <span class=\"built_in\">console</span>.log(<span class=\"string\">\"info:\"</span>, <span class=\"keyword\">this</span>.info)</span></span><br><span class=\"line\"><span class=\"undefined\">            &#125;,</span></span><br><span class=\"line\"><span class=\"undefined\">            methods: &#123;</span></span><br><span class=\"line\"><span class=\"undefined\">                destroy() &#123;</span></span><br><span class=\"line\"><span class=\"javascript\">                    <span class=\"comment\">// 表示销毁组件</span></span></span><br><span class=\"line\"><span class=\"javascript\">                    <span class=\"keyword\">this</span>.$destroy()</span></span><br><span class=\"line\"><span class=\"undefined\">                &#125;,</span></span><br><span class=\"line\"><span class=\"undefined\">                udpateinfo() &#123;</span></span><br><span class=\"line\"><span class=\"javascript\">                    <span class=\"keyword\">this</span>.info = <span class=\"string\">'hello2'</span></span></span><br><span class=\"line\"><span class=\"undefined\">                &#125;</span></span><br><span class=\"line\"><span class=\"undefined\">            &#125;</span></span><br><span class=\"line\"><span class=\"undefined\">        &#125;)</span></span><br><span class=\"line\"><span class=\"undefined\">    </span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"Vue-组件封装过程？\"><a href=\"#Vue-组件封装过程？\" class=\"headerlink\" title=\"Vue 组件封装过程？\"></a>Vue 组件封装过程？</h2><p>首先，使用 Vue.extend() 创建一个组件</p>\n<p>然后，使用 Vue.component() 方法注册组件</p>\n<p>接着，如果子组件需要数据，可以在 props 中接受定义</p>\n<p>最后，子组件修改好数据之后，想把数据传递给父组件，可以使用 emit() 方法</p>\n<h2 id=\"Vue-loader-是什么？\"><a href=\"#Vue-loader-是什么？\" class=\"headerlink\" title=\"Vue-loader 是什么？\"></a>Vue-loader 是什么？</h2><p>解析 Vue 文件的一个加载器，跟 template/js/style 转换成 JS 模块</p>\n<p>提供了一些非常酷炫的特性：</p>\n<p>ES5默认可用；</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">在每个 Vue 组件内支持其他的 webpack 加载器，如用于 &lt;style&gt; 的 SASS 和用于&lt;template&gt;的 Jade</span><br><span class=\"line\"></span><br><span class=\"line\">把 &lt;style&gt;和&lt;template&gt;内引用的静态资源作为模块依赖项对待，并用 webpack 加载器处理。</span><br><span class=\"line\"></span><br><span class=\"line\">对每个组件模拟有作用域的 css</span><br><span class=\"line\"></span><br><span class=\"line\">开发阶段支持组件的热加载</span><br><span class=\"line\"></span><br><span class=\"line\">简单的说，webpack 和 vue-loader 的组合为你创作 Vue 应用一个更先进、更灵巧极其强大的前端开发模式</span><br></pre></td></tr></table></figure>\n<h2 id=\"使用它的用途有哪些？\"><a href=\"#使用它的用途有哪些？\" class=\"headerlink\" title=\"使用它的用途有哪些？\"></a>使用它的用途有哪些？</h2><p>JS 可以写 es6、style 样式可以 scss 或 less、template可以加 jade 等。</p>\n<h2 id=\"说出至少4种Vue当中的指令和它的用法\"><a href=\"#说出至少4种Vue当中的指令和它的用法\" class=\"headerlink\" title=\"说出至少4种Vue当中的指令和它的用法\"></a>说出至少4种Vue当中的指令和它的用法</h2><p>v-if：判断是否隐藏；</p>\n<p>v-for：数据循环出来；</p>\n<p>v-bind：class：绑定一个属性；</p>\n<p>v-model：实现双向绑定</p>\n<h2 id=\"自定义指令（v-check、v-focus）的方法有哪些？它有哪些钩子函数？还有哪些钩子函数参数？\"><a href=\"#自定义指令（v-check、v-focus）的方法有哪些？它有哪些钩子函数？还有哪些钩子函数参数？\" class=\"headerlink\" title=\"自定义指令（v-check、v-focus）的方法有哪些？它有哪些钩子函数？还有哪些钩子函数参数？\"></a>自定义指令（v-check、v-focus）的方法有哪些？它有哪些钩子函数？还有哪些钩子函数参数？</h2><p>全局定义指令：在 Vue 对象的 driective 方法里面有两个参数，一个是指令名称，另一个是函数。组件内定义指令：directives；</p>\n<p>钩子函数：bind（绑定事件触发），inserted（节点插入的时候触发）、update（组件内相关更新）</p>\n<p>钩子函数参数：el ， binding</p>\n<p>理解 Vue 自定义指令钩子函数：</p>\n<p>一个指令定义对象可以提供如下几个钩子函数（均为可选）：</p>\n<p>bind：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置</p>\n<p>inserted：被绑定元素插入父节点时调用（仅保证父节点存在，但不一定已被插入文档中）</p>\n<p>update：所在组件的 VNode 更新时调用，但是可能发生在其子 VNode 更新之前。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新</p>\n<p>componentUpdated：指令所在组件的 VNode 及其子 VNode 全部更新后调用。</p>\n<p>conbind：只调用一次，指令与元素解绑时调用。</p>\n<p>指令钩子函数会被传入以下参数：</p>\n<p>el：指令所绑定的元素，可以用来直接操作 DOM</p>\n<p>binding：一个对象，包含以下属性：</p>\n<p>name：指令名，不包含 v-前缀</p>\n<p>value：指令的绑定值，例如：v-my-directive=“ 1 + 1” 中，绑定值为2</p>\n<p>oldValue：指令绑定的前一个值，仅在 Update 和 compnentUpated 钩子中可用。无论值是否改变都可用</p>\n<p>expression：字符串形式的指令表达式。例如 v-my-directive=“ 1 + 1 ” 中，表达式为“1+1”</p>\n<p>avg：传给指令的参数，可选。例如：v-my-directive：foo 中，参数为 “foo”</p>\n<p>modifiers：一个包含修饰符的对象。例如：v-my-directive.foo.bar 中，修饰符对象为 { foo：true，bar：true }</p>\n<p>vnode：Vue 编译生成的虚拟节点。移步 VNode API 来了解更多详情</p>\n<p>oldVnode：上一个虚拟节点，仅在 update 和 componentUpdated 钩子中可用。</p>\n<h2 id=\"axios是什么？怎么使用？描述使用它实现登录功能的流程？\"><a href=\"#axios是什么？怎么使用？描述使用它实现登录功能的流程？\" class=\"headerlink\" title=\"axios是什么？怎么使用？描述使用它实现登录功能的流程？\"></a>axios是什么？怎么使用？描述使用它实现登录功能的流程？</h2><ol>\n<li>请求后台资源的模块。 npm i axios -s 装好</li>\n<li>然后发送的是跨域，需在配置文件中 config/index.js 进行设置</li>\n<li>后台如果是TP5 则定义一个资源路由。JS 使用import 进来，</li>\n<li>然后 .get 或 .post 返回在 .this 函数中如果成功</li>\n<li>失则则是在 .catch 函数中</li>\n</ol>\n<h2 id=\"axios-tp5-进价中，调用-axios-post-‘-api-user-‘-是进行的什么操作？axios-put-‘api-8’-呢？\"><a href=\"#axios-tp5-进价中，调用-axios-post-‘-api-user-‘-是进行的什么操作？axios-put-‘api-8’-呢？\" class=\"headerlink\" title=\"axios + tp5 进价中，调用 axios.post(‘ api/user ‘) 是进行的什么操作？axios.put(‘api/8’) 呢？\"></a>axios + tp5 进价中，调用 axios.post(‘ api/user ‘) 是进行的什么操作？axios.put(‘api/8’) 呢？</h2><p>跨域，添加用户操作，更新操作。</p>\n<h2 id=\"请说下具体使用-Vue-的理解？\"><a href=\"#请说下具体使用-Vue-的理解？\" class=\"headerlink\" title=\"请说下具体使用 Vue 的理解？\"></a>请说下具体使用 Vue 的理解？</h2><ol>\n<li>使用 Vue 不必担心布局更改和类名重复导致的 JS 重写，因为它是靠数据驱动双向绑定，底层是通过 Object.defineProperty() 定义的数据，set、get 函数原理实现。</li>\n<li>组件化开发，让项目的可拓展性、移植性更好，代码重用性更高，就好像农民工建房子，拿起自己的工具包就可以开工。项目经理坐等收楼就好。</li>\n<li>单页应用的体验零距离接触安卓原生应用，局部组件更新界面，让用户体验更快速省时。</li>\n<li>JS 的代码无形的规范，团队合作开发代码可阅读性更高。</li>\n</ol>\n<h2 id=\"你觉得哪些项目适合-Vue-框架？\"><a href=\"#你觉得哪些项目适合-Vue-框架？\" class=\"headerlink\" title=\"你觉得哪些项目适合 Vue 框架？\"></a>你觉得哪些项目适合 Vue 框架？</h2><ol>\n<li>数据信息量比较多的，反之类似企业网站就无需此框架了</li>\n<li>手机 web 和 app 应用多端共用一套界面的项目，因为使用 Vue.cli + webpack 后的前端目录，非常有利于项目的跨平台部署。</li>\n</ol>\n<h2 id=\"Vue-组件之间如何通信？\"><a href=\"#Vue-组件之间如何通信？\" class=\"headerlink\" title=\"Vue 组件之间如何通信？\"></a>Vue 组件之间如何通信？</h2><p>作为一个vue初学者不得不了解的就是组件间的数据通信(暂且不谈vuex)。通信方式根据组件之间的关系有不同之处。组件关系有下面三种：<strong>父–&gt;子</strong>、<strong>子–&gt;父</strong>、<strong>非父子</strong></p>\n<h4 id=\"父–-gt-子\"><a href=\"#父–-gt-子\" class=\"headerlink\" title=\"父–&gt;子\"></a>父–&gt;子</h4><p>父向子传递数据通过props</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//父组件代码</span></span><br><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">    &lt;header-box :title-txt=<span class=\"string\">\"showTitleTxt\"</span>&gt;<span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">header-box</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span></span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    <span class=\"keyword\">import</span> Header <span class=\"keyword\">from</span> <span class=\"string\">'./header'</span></span><br><span class=\"line\">    <span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">        name: <span class=\"string\">'index'</span>,</span><br><span class=\"line\">        components: &#123;</span><br><span class=\"line\">            <span class=\"string\">'header-box'</span>: Header</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        data () &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">                showTitleTxt: <span class=\"string\">'首页'</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&lt;<span class=\"regexp\">/script&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//子组件代码</span></span><br><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">    &lt;header&gt;</span><br><span class=\"line\">        &#123;&#123;thisTitleTxt&#125;&#125;</span><br><span class=\"line\">    &lt;<span class=\"regexp\">/header&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">&lt;/</span>template&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    <span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">        name: <span class=\"string\">'header-box'</span>,</span><br><span class=\"line\">        props: &#123;</span><br><span class=\"line\">            titleTxt: <span class=\"built_in\">String</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        data () &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">                thisTitleTxt: <span class=\"keyword\">this</span>.titleTxt</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&lt;<span class=\"regexp\">/script&gt;</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"子–-gt-父\"><a href=\"#子–-gt-父\" class=\"headerlink\" title=\"子–&gt;父\"></a>子–&gt;父</h4><blockquote>\n<p>子组件向父组件传递分为两种类型。<br>1、子组件改变父组件传递的props（你会发现通过props中的Object类型参数传输数据，可以通过子组件改变数据内容。这种方式是可行的，但是不推荐使用，因为官方定义prop是单向绑定）<br>2、通过$on和$emit</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//通过props实现传递</span></span><br><span class=\"line\"><span class=\"comment\">//父组件代码</span></span><br><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">    &lt;header-box :title-txt=<span class=\"string\">\"showTitleTxt\"</span>&gt;<span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">header-box</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span></span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    <span class=\"keyword\">import</span> Header <span class=\"keyword\">from</span> <span class=\"string\">'./header'</span></span><br><span class=\"line\">    <span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">        name: <span class=\"string\">'index'</span>,</span><br><span class=\"line\">        components: &#123;</span><br><span class=\"line\">            <span class=\"string\">'header-box'</span>: Header</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        data () &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">                showTitleTxt: &#123;</span><br><span class=\"line\">                    name: <span class=\"string\">'首页'</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&lt;<span class=\"regexp\">/script&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//子组件代码</span></span><br><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">    &lt;header @click=<span class=\"string\">\"changeTitleTxt\"</span>&gt;</span><br><span class=\"line\">        &#123;&#123;thisTitleTxt.name&#125;&#125;</span><br><span class=\"line\">    &lt;<span class=\"regexp\">/header&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">&lt;/</span>template&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    <span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">        name: <span class=\"string\">'header-box'</span>,</span><br><span class=\"line\">        props: &#123;</span><br><span class=\"line\">            titleTxt: <span class=\"built_in\">Object</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        data () &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">                thisTitleTxt: <span class=\"keyword\">this</span>.titleTxt.name</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        metheds: &#123;</span><br><span class=\"line\">            changeTitleTxt () &#123;</span><br><span class=\"line\">                <span class=\"keyword\">this</span>.titleTxt.name = <span class=\"string\">'切换'</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&lt;<span class=\"regexp\">/script&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//通过$on,$emit</span></span><br><span class=\"line\"><span class=\"comment\">//父组件代码</span></span><br><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">    &lt;div id=<span class=\"string\">\"counter-event-example\"</span>&gt;</span><br><span class=\"line\">      &lt;p&gt;&#123;&#123; total &#125;&#125;&lt;<span class=\"regexp\">/p&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">      &lt;button-counter v-on:increment=\"incrementTotal\"&gt;&lt;/</span>button-counter&gt;</span><br><span class=\"line\">&lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">&lt;/</span>template&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    <span class=\"keyword\">import</span> ButtonCounter <span class=\"keyword\">from</span> <span class=\"string\">'./buttonCounter'</span></span><br><span class=\"line\">    <span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">        name: <span class=\"string\">'index'</span>,</span><br><span class=\"line\">        components: &#123;</span><br><span class=\"line\">            <span class=\"string\">'button-conuter'</span>: ButtonCounter</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        data () &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">                total: <span class=\"number\">0</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        methods: &#123;</span><br><span class=\"line\">            incrementTotal () &#123;</span><br><span class=\"line\">                <span class=\"keyword\">this</span>.total++</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&lt;<span class=\"regexp\">/script&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//子组件代码</span></span><br><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">    &lt;button @click=<span class=\"string\">\"incrementCounter\"</span>&gt;&#123;&#123;counter&#125;&#125;&lt;<span class=\"regexp\">/button&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">&lt;/</span>template&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    <span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">        name: <span class=\"string\">'button-counter'</span>,</span><br><span class=\"line\">        data () &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">                counter: <span class=\"number\">0</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        metheds: &#123;</span><br><span class=\"line\">            incrementCounter () &#123;</span><br><span class=\"line\">                <span class=\"keyword\">this</span>.$emit(<span class=\"string\">'increment'</span>)</span><br><span class=\"line\">                <span class=\"keyword\">this</span>.counter++</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&lt;<span class=\"regexp\">/script&gt;</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"非父子\"><a href=\"#非父子\" class=\"headerlink\" title=\"非父子\"></a>非父子</h4><blockquote>\n<p>简单情况下我们可以通过使用一个空的Vue实例作为中央事件总线，（这里也可以使用app实例，而不需要新建一个空Vue实例）</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//main.js</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> bus = <span class=\"keyword\">new</span> Vue()</span><br><span class=\"line\">Vue.prototype.bus = bus</span><br></pre></td></tr></table></figure>\n<p>或者</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//main.js</span></span><br><span class=\"line\"><span class=\"keyword\">new</span> Vue(&#123;</span><br><span class=\"line\">  el: <span class=\"string\">'#app'</span>,</span><br><span class=\"line\">  router,</span><br><span class=\"line\">  template: <span class=\"string\">'&lt;App/&gt;'</span>,</span><br><span class=\"line\">  components: &#123; App &#125;,</span><br><span class=\"line\">  beforeCreate () &#123;</span><br><span class=\"line\">    Vue.prototype.bus = <span class=\"keyword\">this</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//header组件</span></span><br><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">    &lt;header @click=<span class=\"string\">\"changeTitle\"</span>&gt;&#123;&#123;title&#125;&#125;&lt;<span class=\"regexp\">/header&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">&lt;/</span>template&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">    name: <span class=\"string\">'header'</span>,</span><br><span class=\"line\">    data () &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">            title: <span class=\"string\">'头部'</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    methods: &#123;</span><br><span class=\"line\">        changeTitle () &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.bus.$emit(<span class=\"string\">'toChangeTitle'</span>,<span class=\"string\">'首页'</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;<span class=\"regexp\">/script&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//footer组件</span></span><br><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">    &lt;footer&gt;&#123;&#123;txt&#125;&#125;&lt;<span class=\"regexp\">/footer&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">&lt;/</span>template&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">    name: <span class=\"string\">'footer'</span>,</span><br><span class=\"line\">    mounted () &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.bus.$on(<span class=\"string\">'toChangeTitle'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">title</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(title)</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    data () &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">            txt: <span class=\"string\">'尾部'</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"关于vue在app首次加载缓慢的解决办法？\"><a href=\"#关于vue在app首次加载缓慢的解决办法？\" class=\"headerlink\" title=\"关于vue在app首次加载缓慢的解决办法？\"></a>关于vue在app首次加载缓慢的解决办法？</h2><p><em>1.路由懒加载</em></p>\n<p><img src=\"https:////upload-images.jianshu.io/upload_images/12205285-7190dce75d2c6b60.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/513/format/webp\" alt=\"img\"></p>\n<p>​                                            路由懒加载</p>\n<p>此方法会把原本打包到一个app.js文件分开成多个js文件打包，这样会减小单个文件的大小，但是不会减小整个js文件夹的大小。通过这种方式可以做到按需加载，只加载单个页面的js文件。</p>\n<p><em>2.组件异步加载</em></p>\n<p><img src=\"https:////upload-images.jianshu.io/upload_images/12205285-9aa4e5728fa3dce2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/372/format/webp\" alt=\"img\"></p>\n<p>组件异步加载</p>\n<p>加载首页的时候，可以先给首页的子组件设置v-if = “false”，在页面初始化的时候再给子组件设置为true，此方法利用了v-if的惰性，setTimeout会使子组件在所有的组件初始化完成并显示后再对其子组件进行初始化。</p>\n<ul>\n<li style=\"list-style: none\"><input type=\"checkbox\" checked> <strong>注：在实际开发中还遇到了另一种情况也可以用此方法解决，在入口js中获取了app的token，但是在具体页面中发现不管是在created还是mounted中都是有时候能获取到token，有时候又不可以，是因为执行顺序的原因，可以通过 setTimeout 时间设置为0 这种方法把用到token的请求方法给排到最后，这样就能保证请求方法中有token了。</strong></li>\n</ul>\n<p><em>3.使用异步组件，按需加载</em></p>\n<p>newVue({</p>\n<p>// …</p>\n<p>  components: {</p>\n<p>​        ‘my-component’:()=&gt;import(‘./my-async-component’)</p>\n<p>  }</p>\n<p>})</p>\n<p>es6的写法，<code>import</code> 函数会返回一个 <code>Promise</code> 对象。这样就实现了组件的按需加载，有需要的时候才会加载这个组件，同样也是优化首屏加载速度的一种方法。</p>\n<p>下面两张图片就可以清晰的了解 import xxx from “./xxx.vue” 与 import()方法 的不同，以及用import函数所带来的好处。</p>\n<p><img src=\"https:////upload-images.jianshu.io/upload_images/12205285-e3630781a7ba92e2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/656/format/webp\" alt=\"img\"></p>\n<p>  import xxx from “./xxx.vue”  </p>\n<p><img src=\"https:////upload-images.jianshu.io/upload_images/12205285-fdb9ddf46f9da18e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/677/format/webp\" alt=\"img\"></p>\n<p>   import()方法</p>\n<p>上面是两种方法，打包后所生成的文件，import函数的方法很明显多了几个js，这就是从原本 app.js 中分离出来的0.js，1.js，2.js。第一张图，在运行的时候会把app.js整个加载完，而第二张图会加载0.js+app.js，虽然多了一个文件，但实际上，后者整体加载的文件大小要比原本小很多。这就是按需加载，在需要1.js的时候才会加载它，而且加载过一次后就会缓存在本地，下次加载，会取缓存的文件。</p>\n<p>而且，因为import函数返回的是一个promise对象，因此可以用promise本身的then()和catch()方法去监听到组件的加载，如：</p>\n<p><img src=\"https:////upload-images.jianshu.io/upload_images/12205285-85fff817aae7b673.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/393/format/webp\" alt=\"img\"></p>\n<p><em>4.图片量多的时候可以进行分批的加载</em></p>\n<p>vue-lazyload插件，图片懒加载</p>\n<p><em>5.外部引入一些插件，不要在vue中引入</em></p>\n<p>列入，我在次项目中有用到moment.js这个插件，在vue内部引入后打包的项目大小要比在外部用src的方式引入打包的项目大个300k左右。</p>\n<p>首先，下载好moment.min.js包，然后在vue项目的webpack.base.conf.js中添加下图箭头所指向的那段代码</p>\n<p><img src=\"https:////upload-images.jianshu.io/upload_images/12205285-96a1a056b87bd667.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/439/format/webp\" alt=\"img\"></p>\n<p>加上上图的代码后是不会将moment.js给打包到js中的。</p>\n"},{"title":"flex布局教程","date":"2019-03-09T18:41:43.000Z","_content":"\n任何一个容器都可以指定为 Flex 布局\n\n```css\n.box{\n  display: flex;\n}\n```\n\n行内元素也可以使用 Flex 布局。\n\n```css\n.box{\n  display: inline-flex;\n}\n```\n\nWebkit 内核的浏览器，必须加上`-webkit`前缀。\n\n```css\n.box{\n  display: -webkit-flex; /* Safari */\n  display: flex;\n}\n```\n\n注意，设为 Flex 布局以后，子元素的`float`、`clear`和`vertical-align`属性将失效。\n\n## 二、基本概念\n\n采用 Flex 布局的元素，称为 Flex 容器（flex container），简称\"容器\"。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称\"项目\"。\n\n![](http://zhanglong292383147.gitee.io/picture_images/picture/Flex/flex_1.png)\n\n容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做`main start`，结束位置叫做`main end`；交叉轴的开始位置叫做`cross start`，结束位置叫做`cross end`。\n\n项目默认沿主轴排列。单个项目占据的主轴空间叫做`main size`，占据的交叉轴空间叫做`cross size`。\n\n## 三、容器的属性\n\n以下6个属性设置在容器上。\n\n> - flex-direction\n> - flex-wrap\n> - flex-flow\n> - justify-content\n> - align-items\n> - align-content\n\n### 3.1 flex-direction属性\n\n`flex-direction`属性决定主轴的方向（即项目的排列方向）。\n\n```css\n.box {\n  flex-direction: row | row-reverse | column | column-reverse;\n}\n```\n\n![](http://zhanglong292383147.gitee.io/picture_images/picture/Flex/flex_2.png)\n\n它可能有4个值。\n\n> - `row`（默认值）：主轴为水平方向，起点在左端。\n> - `row-reverse`：主轴为水平方向，起点在右端。\n> - `column`：主轴为垂直方向，起点在上沿。\n> - `column-reverse`：主轴为垂直方向，起点在下沿。\n\n### 3.2 flex-wrap属性\n\n默认情况下，项目都排在一条线（又称\"轴线\"）上。`flex-wrap`属性定义，如果一条轴线排不下，如何换行。\n\n![](http://zhanglong292383147.gitee.io/picture_images/picture/Flex/flex_3.png)\n\n```css\n.box{\n  flex-wrap: nowrap | wrap | wrap-reverse;\n}\n```\n\n它可能取三个值。\n\n（1）`nowrap`（默认）：不换行。\n\n![](http://zhanglong292383147.gitee.io/picture_images/picture/Flex/flex_4.png)\n\n（2）`wrap`：换行，第一行在上方。\n\n![](http://zhanglong292383147.gitee.io/picture_images/picture/Flex/flex_5.jpg)\n\n（3）`wrap-reverse`：换行，第一行在下方。\n\n![](http://zhanglong292383147.gitee.io/picture_images/picture/Flex/flex_6.jpg)\n\n### 3.3 flex-flow\n\n`flex-flow`属性是`flex-direction`属性和`flex-wrap`属性的简写形式，默认值为`row nowrap`。\n\n```css\n.box {\n  flex-flow: <flex-direction> || <flex-wrap>;\n}\n```\n\n### 3.4 justify-content属性\n\n`justify-content`属性定义了项目在主轴上的对齐方式。\n\n```css\n.box {\n  justify-content: flex-start | flex-end | center | space-between | space-around;\n}\n```\n\n![](http://zhanglong292383147.gitee.io/picture_images/picture/Flex/flex_7.png)\n\n它可能取5个值，具体对齐方式与轴的方向有关。下面假设主轴为从左到右。\n\n> - `flex-start`（默认值）：左对齐\n> - `flex-end`：右对齐\n> - `center`： 居中\n> - `space-between`：两端对齐，项目之间的间隔都相等。\n> - `space-around`：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。\n\n### 3.5 align-items属性\n\n`align-items`属性定义项目在交叉轴上如何对齐。\n\n```css\n.box {\n  align-items: flex-start | flex-end | center | baseline | stretch;\n}\n```\n\n![](http://zhanglong292383147.gitee.io/picture_images/picture/Flex/flex_8.png)\n\n它可能取5个值。具体的对齐方式与交叉轴的方向有关，下面假设交叉轴从上到下。\n\n> - `flex-start`：交叉轴的起点对齐。\n> - `flex-end`：交叉轴的终点对齐。\n> - `center`：交叉轴的中点对齐。\n> - `baseline`: 项目的第一行文字的基线对齐。\n> - `stretch`（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。\n\n### 3.6 align-content属性\n\n`align-content`属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。\n\n```css\n.box {\n  align-content: flex-start | flex-end | center | space-between | space-around | stretch;\n}\n```\n\n![](http://zhanglong292383147.gitee.io/picture_images/picture/Flex/flex_9.png)\n\n该属性可能取6个值。\n\n> - `flex-start`：与交叉轴的起点对齐。\n> - `flex-end`：与交叉轴的终点对齐。\n> - `center`：与交叉轴的中点对齐。\n> - `space-between`：与交叉轴两端对齐，轴线之间的间隔平均分布。\n> - `space-around`：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。\n> - `stretch`（默认值）：轴线占满整个交叉轴。\n\n### 四、项目的属性\n\n以下6个属性设置在项目上。\n\n> - `order`\n> - `flex-grow`\n> - `flex-shrink`\n> - `flex-basis`\n> - `flex`\n> - `align-self`\n\n### 4.1 order属性\n\n`order`属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。\n\n```css\n.item {\n  order: <integer>;\n}\n```\n\n![](http://zhanglong292383147.gitee.io/picture_images/picture/Flex/flex_10.png)\n\n### 4.2 flex-grow属性\n\n`flex-grow`属性定义项目的放大比例，默认为`0`，即如果存在剩余空间，也不放大。\n\n```css\n.item {\n  flex-grow: <number>; /* default 0 */\n}\n```\n\n![](http://zhanglong292383147.gitee.io/picture_images/picture/Flex/flex_11.png)\n\n如果所有项目的`flex-grow`属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的`flex-grow`属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。\n\n### 4.3 flex-shrink属性\n\n`flex-shrink`属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。\n\n```css\n.item {\n  flex-shrink: <number>; /* default 1 */\n}\n```\n\n![](http://zhanglong292383147.gitee.io/picture_images/picture/Flex/flex_12.jpg)\n\n如果所有项目的`flex-shrink`属性都为1，当空间不足时，都将等比例缩小。如果一个项目的`flex-shrink`属性为0，其他项目都为1，则空间不足时，前者不缩小。\n\n负值对该属性无效。\n\n### 4.4 flex-basis属性\n\n`flex-basis`属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为`auto`，即项目的本来大小。\n\n> ```css\n> .item {\n>   flex-basis: <length> | auto; /* default auto */\n> }\n> ```\n\n它可以设为跟`width`或`height`属性一样的值（比如350px），则项目将占据固定空间。\n\n### 4.5 flex属性\n\n`flex`属性是`flex-grow`, `flex-shrink` 和 `flex-basis`的简写，默认值为`0 1 auto`。后两个属性可选。\n\n```css\n.item {\n  flex: none | [ <'flex-grow'> <'flex-shrink'>? || <'flex-basis'> ]\n}\n```\n\n该属性有两个快捷值：`auto` (`1 1 auto`) 和 none (`0 0 auto`)。\n\n建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。\n\n### 4.6 align-self属性\n\n`align-self`属性允许单个项目有与其他项目不一样的对齐方式，可覆盖`align-items`属性。默认值为`auto`，表示继承父元素的`align-items`属性，如果没有父元素，则等同于`stretch`。\n\n```css\n.item {\n  align-self: auto | flex-start | flex-end | center | baseline | stretch;\n}\n```\n\n![](http://zhanglong292383147.gitee.io/picture_images/picture/Flex/flex_13.png)\n\n该属性可能取6个值，除了auto，其他都与align-items属性完全一致。","source":"_posts/flex布局教程.md","raw":"---\ntitle: flex布局教程\ndate: 2019-03-10 02:41:43\ntags: flex\n---\n\n任何一个容器都可以指定为 Flex 布局\n\n```css\n.box{\n  display: flex;\n}\n```\n\n行内元素也可以使用 Flex 布局。\n\n```css\n.box{\n  display: inline-flex;\n}\n```\n\nWebkit 内核的浏览器，必须加上`-webkit`前缀。\n\n```css\n.box{\n  display: -webkit-flex; /* Safari */\n  display: flex;\n}\n```\n\n注意，设为 Flex 布局以后，子元素的`float`、`clear`和`vertical-align`属性将失效。\n\n## 二、基本概念\n\n采用 Flex 布局的元素，称为 Flex 容器（flex container），简称\"容器\"。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称\"项目\"。\n\n![](http://zhanglong292383147.gitee.io/picture_images/picture/Flex/flex_1.png)\n\n容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做`main start`，结束位置叫做`main end`；交叉轴的开始位置叫做`cross start`，结束位置叫做`cross end`。\n\n项目默认沿主轴排列。单个项目占据的主轴空间叫做`main size`，占据的交叉轴空间叫做`cross size`。\n\n## 三、容器的属性\n\n以下6个属性设置在容器上。\n\n> - flex-direction\n> - flex-wrap\n> - flex-flow\n> - justify-content\n> - align-items\n> - align-content\n\n### 3.1 flex-direction属性\n\n`flex-direction`属性决定主轴的方向（即项目的排列方向）。\n\n```css\n.box {\n  flex-direction: row | row-reverse | column | column-reverse;\n}\n```\n\n![](http://zhanglong292383147.gitee.io/picture_images/picture/Flex/flex_2.png)\n\n它可能有4个值。\n\n> - `row`（默认值）：主轴为水平方向，起点在左端。\n> - `row-reverse`：主轴为水平方向，起点在右端。\n> - `column`：主轴为垂直方向，起点在上沿。\n> - `column-reverse`：主轴为垂直方向，起点在下沿。\n\n### 3.2 flex-wrap属性\n\n默认情况下，项目都排在一条线（又称\"轴线\"）上。`flex-wrap`属性定义，如果一条轴线排不下，如何换行。\n\n![](http://zhanglong292383147.gitee.io/picture_images/picture/Flex/flex_3.png)\n\n```css\n.box{\n  flex-wrap: nowrap | wrap | wrap-reverse;\n}\n```\n\n它可能取三个值。\n\n（1）`nowrap`（默认）：不换行。\n\n![](http://zhanglong292383147.gitee.io/picture_images/picture/Flex/flex_4.png)\n\n（2）`wrap`：换行，第一行在上方。\n\n![](http://zhanglong292383147.gitee.io/picture_images/picture/Flex/flex_5.jpg)\n\n（3）`wrap-reverse`：换行，第一行在下方。\n\n![](http://zhanglong292383147.gitee.io/picture_images/picture/Flex/flex_6.jpg)\n\n### 3.3 flex-flow\n\n`flex-flow`属性是`flex-direction`属性和`flex-wrap`属性的简写形式，默认值为`row nowrap`。\n\n```css\n.box {\n  flex-flow: <flex-direction> || <flex-wrap>;\n}\n```\n\n### 3.4 justify-content属性\n\n`justify-content`属性定义了项目在主轴上的对齐方式。\n\n```css\n.box {\n  justify-content: flex-start | flex-end | center | space-between | space-around;\n}\n```\n\n![](http://zhanglong292383147.gitee.io/picture_images/picture/Flex/flex_7.png)\n\n它可能取5个值，具体对齐方式与轴的方向有关。下面假设主轴为从左到右。\n\n> - `flex-start`（默认值）：左对齐\n> - `flex-end`：右对齐\n> - `center`： 居中\n> - `space-between`：两端对齐，项目之间的间隔都相等。\n> - `space-around`：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。\n\n### 3.5 align-items属性\n\n`align-items`属性定义项目在交叉轴上如何对齐。\n\n```css\n.box {\n  align-items: flex-start | flex-end | center | baseline | stretch;\n}\n```\n\n![](http://zhanglong292383147.gitee.io/picture_images/picture/Flex/flex_8.png)\n\n它可能取5个值。具体的对齐方式与交叉轴的方向有关，下面假设交叉轴从上到下。\n\n> - `flex-start`：交叉轴的起点对齐。\n> - `flex-end`：交叉轴的终点对齐。\n> - `center`：交叉轴的中点对齐。\n> - `baseline`: 项目的第一行文字的基线对齐。\n> - `stretch`（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。\n\n### 3.6 align-content属性\n\n`align-content`属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。\n\n```css\n.box {\n  align-content: flex-start | flex-end | center | space-between | space-around | stretch;\n}\n```\n\n![](http://zhanglong292383147.gitee.io/picture_images/picture/Flex/flex_9.png)\n\n该属性可能取6个值。\n\n> - `flex-start`：与交叉轴的起点对齐。\n> - `flex-end`：与交叉轴的终点对齐。\n> - `center`：与交叉轴的中点对齐。\n> - `space-between`：与交叉轴两端对齐，轴线之间的间隔平均分布。\n> - `space-around`：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。\n> - `stretch`（默认值）：轴线占满整个交叉轴。\n\n### 四、项目的属性\n\n以下6个属性设置在项目上。\n\n> - `order`\n> - `flex-grow`\n> - `flex-shrink`\n> - `flex-basis`\n> - `flex`\n> - `align-self`\n\n### 4.1 order属性\n\n`order`属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。\n\n```css\n.item {\n  order: <integer>;\n}\n```\n\n![](http://zhanglong292383147.gitee.io/picture_images/picture/Flex/flex_10.png)\n\n### 4.2 flex-grow属性\n\n`flex-grow`属性定义项目的放大比例，默认为`0`，即如果存在剩余空间，也不放大。\n\n```css\n.item {\n  flex-grow: <number>; /* default 0 */\n}\n```\n\n![](http://zhanglong292383147.gitee.io/picture_images/picture/Flex/flex_11.png)\n\n如果所有项目的`flex-grow`属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的`flex-grow`属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。\n\n### 4.3 flex-shrink属性\n\n`flex-shrink`属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。\n\n```css\n.item {\n  flex-shrink: <number>; /* default 1 */\n}\n```\n\n![](http://zhanglong292383147.gitee.io/picture_images/picture/Flex/flex_12.jpg)\n\n如果所有项目的`flex-shrink`属性都为1，当空间不足时，都将等比例缩小。如果一个项目的`flex-shrink`属性为0，其他项目都为1，则空间不足时，前者不缩小。\n\n负值对该属性无效。\n\n### 4.4 flex-basis属性\n\n`flex-basis`属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为`auto`，即项目的本来大小。\n\n> ```css\n> .item {\n>   flex-basis: <length> | auto; /* default auto */\n> }\n> ```\n\n它可以设为跟`width`或`height`属性一样的值（比如350px），则项目将占据固定空间。\n\n### 4.5 flex属性\n\n`flex`属性是`flex-grow`, `flex-shrink` 和 `flex-basis`的简写，默认值为`0 1 auto`。后两个属性可选。\n\n```css\n.item {\n  flex: none | [ <'flex-grow'> <'flex-shrink'>? || <'flex-basis'> ]\n}\n```\n\n该属性有两个快捷值：`auto` (`1 1 auto`) 和 none (`0 0 auto`)。\n\n建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。\n\n### 4.6 align-self属性\n\n`align-self`属性允许单个项目有与其他项目不一样的对齐方式，可覆盖`align-items`属性。默认值为`auto`，表示继承父元素的`align-items`属性，如果没有父元素，则等同于`stretch`。\n\n```css\n.item {\n  align-self: auto | flex-start | flex-end | center | baseline | stretch;\n}\n```\n\n![](http://zhanglong292383147.gitee.io/picture_images/picture/Flex/flex_13.png)\n\n该属性可能取6个值，除了auto，其他都与align-items属性完全一致。","slug":"flex布局教程","published":1,"updated":"2019-03-09T18:42:13.070Z","_id":"cjt1u57hh0001u0npg6033q4r","comments":1,"layout":"post","photos":[],"link":"","content":"<p>任何一个容器都可以指定为 Flex 布局</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.box</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">display</span>: flex;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>行内元素也可以使用 Flex 布局。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.box</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">display</span>: inline-flex;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Webkit 内核的浏览器，必须加上<code>-webkit</code>前缀。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.box</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">display</span>: -webkit-flex; <span class=\"comment\">/* Safari */</span></span><br><span class=\"line\">  <span class=\"attribute\">display</span>: flex;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>注意，设为 Flex 布局以后，子元素的<code>float</code>、<code>clear</code>和<code>vertical-align</code>属性将失效。</p>\n<h2 id=\"二、基本概念\"><a href=\"#二、基本概念\" class=\"headerlink\" title=\"二、基本概念\"></a>二、基本概念</h2><p>采用 Flex 布局的元素，称为 Flex 容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称”项目”。</p>\n<p><img src=\"http://zhanglong292383147.gitee.io/picture_images/picture/Flex/flex_1.png\" alt=\"\"></p>\n<p>容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做<code>main start</code>，结束位置叫做<code>main end</code>；交叉轴的开始位置叫做<code>cross start</code>，结束位置叫做<code>cross end</code>。</p>\n<p>项目默认沿主轴排列。单个项目占据的主轴空间叫做<code>main size</code>，占据的交叉轴空间叫做<code>cross size</code>。</p>\n<h2 id=\"三、容器的属性\"><a href=\"#三、容器的属性\" class=\"headerlink\" title=\"三、容器的属性\"></a>三、容器的属性</h2><p>以下6个属性设置在容器上。</p>\n<blockquote>\n<ul>\n<li>flex-direction</li>\n<li>flex-wrap</li>\n<li>flex-flow</li>\n<li>justify-content</li>\n<li>align-items</li>\n<li>align-content</li>\n</ul>\n</blockquote>\n<h3 id=\"3-1-flex-direction属性\"><a href=\"#3-1-flex-direction属性\" class=\"headerlink\" title=\"3.1 flex-direction属性\"></a>3.1 flex-direction属性</h3><p><code>flex-direction</code>属性决定主轴的方向（即项目的排列方向）。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.box</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">flex-direction</span>: row | row-reverse | column | column-reverse;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://zhanglong292383147.gitee.io/picture_images/picture/Flex/flex_2.png\" alt=\"\"></p>\n<p>它可能有4个值。</p>\n<blockquote>\n<ul>\n<li><code>row</code>（默认值）：主轴为水平方向，起点在左端。</li>\n<li><code>row-reverse</code>：主轴为水平方向，起点在右端。</li>\n<li><code>column</code>：主轴为垂直方向，起点在上沿。</li>\n<li><code>column-reverse</code>：主轴为垂直方向，起点在下沿。</li>\n</ul>\n</blockquote>\n<h3 id=\"3-2-flex-wrap属性\"><a href=\"#3-2-flex-wrap属性\" class=\"headerlink\" title=\"3.2 flex-wrap属性\"></a>3.2 flex-wrap属性</h3><p>默认情况下，项目都排在一条线（又称”轴线”）上。<code>flex-wrap</code>属性定义，如果一条轴线排不下，如何换行。</p>\n<p><img src=\"http://zhanglong292383147.gitee.io/picture_images/picture/Flex/flex_3.png\" alt=\"\"></p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.box</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">flex-wrap</span>: nowrap | wrap | wrap-reverse;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>它可能取三个值。</p>\n<p>（1）<code>nowrap</code>（默认）：不换行。</p>\n<p><img src=\"http://zhanglong292383147.gitee.io/picture_images/picture/Flex/flex_4.png\" alt=\"\"></p>\n<p>（2）<code>wrap</code>：换行，第一行在上方。</p>\n<p><img src=\"http://zhanglong292383147.gitee.io/picture_images/picture/Flex/flex_5.jpg\" alt=\"\"></p>\n<p>（3）<code>wrap-reverse</code>：换行，第一行在下方。</p>\n<p><img src=\"http://zhanglong292383147.gitee.io/picture_images/picture/Flex/flex_6.jpg\" alt=\"\"></p>\n<h3 id=\"3-3-flex-flow\"><a href=\"#3-3-flex-flow\" class=\"headerlink\" title=\"3.3 flex-flow\"></a>3.3 flex-flow</h3><p><code>flex-flow</code>属性是<code>flex-direction</code>属性和<code>flex-wrap</code>属性的简写形式，默认值为<code>row nowrap</code>。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.box</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">flex-flow</span>: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-4-justify-content属性\"><a href=\"#3-4-justify-content属性\" class=\"headerlink\" title=\"3.4 justify-content属性\"></a>3.4 justify-content属性</h3><p><code>justify-content</code>属性定义了项目在主轴上的对齐方式。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.box</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">justify-content</span>: flex-start | flex-end | center | space-between | space-around;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://zhanglong292383147.gitee.io/picture_images/picture/Flex/flex_7.png\" alt=\"\"></p>\n<p>它可能取5个值，具体对齐方式与轴的方向有关。下面假设主轴为从左到右。</p>\n<blockquote>\n<ul>\n<li><code>flex-start</code>（默认值）：左对齐</li>\n<li><code>flex-end</code>：右对齐</li>\n<li><code>center</code>： 居中</li>\n<li><code>space-between</code>：两端对齐，项目之间的间隔都相等。</li>\n<li><code>space-around</code>：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。</li>\n</ul>\n</blockquote>\n<h3 id=\"3-5-align-items属性\"><a href=\"#3-5-align-items属性\" class=\"headerlink\" title=\"3.5 align-items属性\"></a>3.5 align-items属性</h3><p><code>align-items</code>属性定义项目在交叉轴上如何对齐。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.box</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">align-items</span>: flex-start | flex-end | center | baseline | stretch;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://zhanglong292383147.gitee.io/picture_images/picture/Flex/flex_8.png\" alt=\"\"></p>\n<p>它可能取5个值。具体的对齐方式与交叉轴的方向有关，下面假设交叉轴从上到下。</p>\n<blockquote>\n<ul>\n<li><code>flex-start</code>：交叉轴的起点对齐。</li>\n<li><code>flex-end</code>：交叉轴的终点对齐。</li>\n<li><code>center</code>：交叉轴的中点对齐。</li>\n<li><code>baseline</code>: 项目的第一行文字的基线对齐。</li>\n<li><code>stretch</code>（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。</li>\n</ul>\n</blockquote>\n<h3 id=\"3-6-align-content属性\"><a href=\"#3-6-align-content属性\" class=\"headerlink\" title=\"3.6 align-content属性\"></a>3.6 align-content属性</h3><p><code>align-content</code>属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.box</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">align-content</span>: flex-start | flex-end | center | space-between | space-around | stretch;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://zhanglong292383147.gitee.io/picture_images/picture/Flex/flex_9.png\" alt=\"\"></p>\n<p>该属性可能取6个值。</p>\n<blockquote>\n<ul>\n<li><code>flex-start</code>：与交叉轴的起点对齐。</li>\n<li><code>flex-end</code>：与交叉轴的终点对齐。</li>\n<li><code>center</code>：与交叉轴的中点对齐。</li>\n<li><code>space-between</code>：与交叉轴两端对齐，轴线之间的间隔平均分布。</li>\n<li><code>space-around</code>：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。</li>\n<li><code>stretch</code>（默认值）：轴线占满整个交叉轴。</li>\n</ul>\n</blockquote>\n<h3 id=\"四、项目的属性\"><a href=\"#四、项目的属性\" class=\"headerlink\" title=\"四、项目的属性\"></a>四、项目的属性</h3><p>以下6个属性设置在项目上。</p>\n<blockquote>\n<ul>\n<li><code>order</code></li>\n<li><code>flex-grow</code></li>\n<li><code>flex-shrink</code></li>\n<li><code>flex-basis</code></li>\n<li><code>flex</code></li>\n<li><code>align-self</code></li>\n</ul>\n</blockquote>\n<h3 id=\"4-1-order属性\"><a href=\"#4-1-order属性\" class=\"headerlink\" title=\"4.1 order属性\"></a>4.1 order属性</h3><p><code>order</code>属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.item</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">order</span>: &lt;integer&gt;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://zhanglong292383147.gitee.io/picture_images/picture/Flex/flex_10.png\" alt=\"\"></p>\n<h3 id=\"4-2-flex-grow属性\"><a href=\"#4-2-flex-grow属性\" class=\"headerlink\" title=\"4.2 flex-grow属性\"></a>4.2 flex-grow属性</h3><p><code>flex-grow</code>属性定义项目的放大比例，默认为<code>0</code>，即如果存在剩余空间，也不放大。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.item</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">flex-grow</span>: &lt;number&gt;; <span class=\"comment\">/* default 0 */</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://zhanglong292383147.gitee.io/picture_images/picture/Flex/flex_11.png\" alt=\"\"></p>\n<p>如果所有项目的<code>flex-grow</code>属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的<code>flex-grow</code>属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。</p>\n<h3 id=\"4-3-flex-shrink属性\"><a href=\"#4-3-flex-shrink属性\" class=\"headerlink\" title=\"4.3 flex-shrink属性\"></a>4.3 flex-shrink属性</h3><p><code>flex-shrink</code>属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.item</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">flex-shrink</span>: &lt;number&gt;; <span class=\"comment\">/* default 1 */</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://zhanglong292383147.gitee.io/picture_images/picture/Flex/flex_12.jpg\" alt=\"\"></p>\n<p>如果所有项目的<code>flex-shrink</code>属性都为1，当空间不足时，都将等比例缩小。如果一个项目的<code>flex-shrink</code>属性为0，其他项目都为1，则空间不足时，前者不缩小。</p>\n<p>负值对该属性无效。</p>\n<h3 id=\"4-4-flex-basis属性\"><a href=\"#4-4-flex-basis属性\" class=\"headerlink\" title=\"4.4 flex-basis属性\"></a>4.4 flex-basis属性</h3><p><code>flex-basis</code>属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为<code>auto</code>，即项目的本来大小。</p>\n<blockquote>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; <span class=\"selector-class\">.item</span> &#123;</span><br><span class=\"line\">&gt;   flex-basis: &lt;length&gt; | auto; /* default auto */</span><br><span class=\"line\">&gt; &#125;</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>它可以设为跟<code>width</code>或<code>height</code>属性一样的值（比如350px），则项目将占据固定空间。</p>\n<h3 id=\"4-5-flex属性\"><a href=\"#4-5-flex属性\" class=\"headerlink\" title=\"4.5 flex属性\"></a>4.5 flex属性</h3><p><code>flex</code>属性是<code>flex-grow</code>, <code>flex-shrink</code> 和 <code>flex-basis</code>的简写，默认值为<code>0 1 auto</code>。后两个属性可选。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.item</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">flex</span>: none | [ &lt;<span class=\"string\">'flex-grow'</span>&gt; &lt;<span class=\"string\">'flex-shrink'</span>&gt;? || &lt;<span class=\"string\">'flex-basis'</span>&gt; ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>该属性有两个快捷值：<code>auto</code> (<code>1 1 auto</code>) 和 none (<code>0 0 auto</code>)。</p>\n<p>建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。</p>\n<h3 id=\"4-6-align-self属性\"><a href=\"#4-6-align-self属性\" class=\"headerlink\" title=\"4.6 align-self属性\"></a>4.6 align-self属性</h3><p><code>align-self</code>属性允许单个项目有与其他项目不一样的对齐方式，可覆盖<code>align-items</code>属性。默认值为<code>auto</code>，表示继承父元素的<code>align-items</code>属性，如果没有父元素，则等同于<code>stretch</code>。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.item</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">align-self</span>: auto | flex-start | flex-end | center | baseline | stretch;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://zhanglong292383147.gitee.io/picture_images/picture/Flex/flex_13.png\" alt=\"\"></p>\n<p>该属性可能取6个值，除了auto，其他都与align-items属性完全一致。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>任何一个容器都可以指定为 Flex 布局</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.box</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">display</span>: flex;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>行内元素也可以使用 Flex 布局。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.box</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">display</span>: inline-flex;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Webkit 内核的浏览器，必须加上<code>-webkit</code>前缀。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.box</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">display</span>: -webkit-flex; <span class=\"comment\">/* Safari */</span></span><br><span class=\"line\">  <span class=\"attribute\">display</span>: flex;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>注意，设为 Flex 布局以后，子元素的<code>float</code>、<code>clear</code>和<code>vertical-align</code>属性将失效。</p>\n<h2 id=\"二、基本概念\"><a href=\"#二、基本概念\" class=\"headerlink\" title=\"二、基本概念\"></a>二、基本概念</h2><p>采用 Flex 布局的元素，称为 Flex 容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称”项目”。</p>\n<p><img src=\"http://zhanglong292383147.gitee.io/picture_images/picture/Flex/flex_1.png\" alt=\"\"></p>\n<p>容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做<code>main start</code>，结束位置叫做<code>main end</code>；交叉轴的开始位置叫做<code>cross start</code>，结束位置叫做<code>cross end</code>。</p>\n<p>项目默认沿主轴排列。单个项目占据的主轴空间叫做<code>main size</code>，占据的交叉轴空间叫做<code>cross size</code>。</p>\n<h2 id=\"三、容器的属性\"><a href=\"#三、容器的属性\" class=\"headerlink\" title=\"三、容器的属性\"></a>三、容器的属性</h2><p>以下6个属性设置在容器上。</p>\n<blockquote>\n<ul>\n<li>flex-direction</li>\n<li>flex-wrap</li>\n<li>flex-flow</li>\n<li>justify-content</li>\n<li>align-items</li>\n<li>align-content</li>\n</ul>\n</blockquote>\n<h3 id=\"3-1-flex-direction属性\"><a href=\"#3-1-flex-direction属性\" class=\"headerlink\" title=\"3.1 flex-direction属性\"></a>3.1 flex-direction属性</h3><p><code>flex-direction</code>属性决定主轴的方向（即项目的排列方向）。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.box</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">flex-direction</span>: row | row-reverse | column | column-reverse;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://zhanglong292383147.gitee.io/picture_images/picture/Flex/flex_2.png\" alt=\"\"></p>\n<p>它可能有4个值。</p>\n<blockquote>\n<ul>\n<li><code>row</code>（默认值）：主轴为水平方向，起点在左端。</li>\n<li><code>row-reverse</code>：主轴为水平方向，起点在右端。</li>\n<li><code>column</code>：主轴为垂直方向，起点在上沿。</li>\n<li><code>column-reverse</code>：主轴为垂直方向，起点在下沿。</li>\n</ul>\n</blockquote>\n<h3 id=\"3-2-flex-wrap属性\"><a href=\"#3-2-flex-wrap属性\" class=\"headerlink\" title=\"3.2 flex-wrap属性\"></a>3.2 flex-wrap属性</h3><p>默认情况下，项目都排在一条线（又称”轴线”）上。<code>flex-wrap</code>属性定义，如果一条轴线排不下，如何换行。</p>\n<p><img src=\"http://zhanglong292383147.gitee.io/picture_images/picture/Flex/flex_3.png\" alt=\"\"></p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.box</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">flex-wrap</span>: nowrap | wrap | wrap-reverse;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>它可能取三个值。</p>\n<p>（1）<code>nowrap</code>（默认）：不换行。</p>\n<p><img src=\"http://zhanglong292383147.gitee.io/picture_images/picture/Flex/flex_4.png\" alt=\"\"></p>\n<p>（2）<code>wrap</code>：换行，第一行在上方。</p>\n<p><img src=\"http://zhanglong292383147.gitee.io/picture_images/picture/Flex/flex_5.jpg\" alt=\"\"></p>\n<p>（3）<code>wrap-reverse</code>：换行，第一行在下方。</p>\n<p><img src=\"http://zhanglong292383147.gitee.io/picture_images/picture/Flex/flex_6.jpg\" alt=\"\"></p>\n<h3 id=\"3-3-flex-flow\"><a href=\"#3-3-flex-flow\" class=\"headerlink\" title=\"3.3 flex-flow\"></a>3.3 flex-flow</h3><p><code>flex-flow</code>属性是<code>flex-direction</code>属性和<code>flex-wrap</code>属性的简写形式，默认值为<code>row nowrap</code>。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.box</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">flex-flow</span>: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-4-justify-content属性\"><a href=\"#3-4-justify-content属性\" class=\"headerlink\" title=\"3.4 justify-content属性\"></a>3.4 justify-content属性</h3><p><code>justify-content</code>属性定义了项目在主轴上的对齐方式。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.box</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">justify-content</span>: flex-start | flex-end | center | space-between | space-around;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://zhanglong292383147.gitee.io/picture_images/picture/Flex/flex_7.png\" alt=\"\"></p>\n<p>它可能取5个值，具体对齐方式与轴的方向有关。下面假设主轴为从左到右。</p>\n<blockquote>\n<ul>\n<li><code>flex-start</code>（默认值）：左对齐</li>\n<li><code>flex-end</code>：右对齐</li>\n<li><code>center</code>： 居中</li>\n<li><code>space-between</code>：两端对齐，项目之间的间隔都相等。</li>\n<li><code>space-around</code>：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。</li>\n</ul>\n</blockquote>\n<h3 id=\"3-5-align-items属性\"><a href=\"#3-5-align-items属性\" class=\"headerlink\" title=\"3.5 align-items属性\"></a>3.5 align-items属性</h3><p><code>align-items</code>属性定义项目在交叉轴上如何对齐。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.box</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">align-items</span>: flex-start | flex-end | center | baseline | stretch;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://zhanglong292383147.gitee.io/picture_images/picture/Flex/flex_8.png\" alt=\"\"></p>\n<p>它可能取5个值。具体的对齐方式与交叉轴的方向有关，下面假设交叉轴从上到下。</p>\n<blockquote>\n<ul>\n<li><code>flex-start</code>：交叉轴的起点对齐。</li>\n<li><code>flex-end</code>：交叉轴的终点对齐。</li>\n<li><code>center</code>：交叉轴的中点对齐。</li>\n<li><code>baseline</code>: 项目的第一行文字的基线对齐。</li>\n<li><code>stretch</code>（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。</li>\n</ul>\n</blockquote>\n<h3 id=\"3-6-align-content属性\"><a href=\"#3-6-align-content属性\" class=\"headerlink\" title=\"3.6 align-content属性\"></a>3.6 align-content属性</h3><p><code>align-content</code>属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.box</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">align-content</span>: flex-start | flex-end | center | space-between | space-around | stretch;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://zhanglong292383147.gitee.io/picture_images/picture/Flex/flex_9.png\" alt=\"\"></p>\n<p>该属性可能取6个值。</p>\n<blockquote>\n<ul>\n<li><code>flex-start</code>：与交叉轴的起点对齐。</li>\n<li><code>flex-end</code>：与交叉轴的终点对齐。</li>\n<li><code>center</code>：与交叉轴的中点对齐。</li>\n<li><code>space-between</code>：与交叉轴两端对齐，轴线之间的间隔平均分布。</li>\n<li><code>space-around</code>：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。</li>\n<li><code>stretch</code>（默认值）：轴线占满整个交叉轴。</li>\n</ul>\n</blockquote>\n<h3 id=\"四、项目的属性\"><a href=\"#四、项目的属性\" class=\"headerlink\" title=\"四、项目的属性\"></a>四、项目的属性</h3><p>以下6个属性设置在项目上。</p>\n<blockquote>\n<ul>\n<li><code>order</code></li>\n<li><code>flex-grow</code></li>\n<li><code>flex-shrink</code></li>\n<li><code>flex-basis</code></li>\n<li><code>flex</code></li>\n<li><code>align-self</code></li>\n</ul>\n</blockquote>\n<h3 id=\"4-1-order属性\"><a href=\"#4-1-order属性\" class=\"headerlink\" title=\"4.1 order属性\"></a>4.1 order属性</h3><p><code>order</code>属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.item</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">order</span>: &lt;integer&gt;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://zhanglong292383147.gitee.io/picture_images/picture/Flex/flex_10.png\" alt=\"\"></p>\n<h3 id=\"4-2-flex-grow属性\"><a href=\"#4-2-flex-grow属性\" class=\"headerlink\" title=\"4.2 flex-grow属性\"></a>4.2 flex-grow属性</h3><p><code>flex-grow</code>属性定义项目的放大比例，默认为<code>0</code>，即如果存在剩余空间，也不放大。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.item</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">flex-grow</span>: &lt;number&gt;; <span class=\"comment\">/* default 0 */</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://zhanglong292383147.gitee.io/picture_images/picture/Flex/flex_11.png\" alt=\"\"></p>\n<p>如果所有项目的<code>flex-grow</code>属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的<code>flex-grow</code>属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。</p>\n<h3 id=\"4-3-flex-shrink属性\"><a href=\"#4-3-flex-shrink属性\" class=\"headerlink\" title=\"4.3 flex-shrink属性\"></a>4.3 flex-shrink属性</h3><p><code>flex-shrink</code>属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.item</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">flex-shrink</span>: &lt;number&gt;; <span class=\"comment\">/* default 1 */</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://zhanglong292383147.gitee.io/picture_images/picture/Flex/flex_12.jpg\" alt=\"\"></p>\n<p>如果所有项目的<code>flex-shrink</code>属性都为1，当空间不足时，都将等比例缩小。如果一个项目的<code>flex-shrink</code>属性为0，其他项目都为1，则空间不足时，前者不缩小。</p>\n<p>负值对该属性无效。</p>\n<h3 id=\"4-4-flex-basis属性\"><a href=\"#4-4-flex-basis属性\" class=\"headerlink\" title=\"4.4 flex-basis属性\"></a>4.4 flex-basis属性</h3><p><code>flex-basis</code>属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为<code>auto</code>，即项目的本来大小。</p>\n<blockquote>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; <span class=\"selector-class\">.item</span> &#123;</span><br><span class=\"line\">&gt;   flex-basis: &lt;length&gt; | auto; /* default auto */</span><br><span class=\"line\">&gt; &#125;</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>它可以设为跟<code>width</code>或<code>height</code>属性一样的值（比如350px），则项目将占据固定空间。</p>\n<h3 id=\"4-5-flex属性\"><a href=\"#4-5-flex属性\" class=\"headerlink\" title=\"4.5 flex属性\"></a>4.5 flex属性</h3><p><code>flex</code>属性是<code>flex-grow</code>, <code>flex-shrink</code> 和 <code>flex-basis</code>的简写，默认值为<code>0 1 auto</code>。后两个属性可选。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.item</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">flex</span>: none | [ &lt;<span class=\"string\">'flex-grow'</span>&gt; &lt;<span class=\"string\">'flex-shrink'</span>&gt;? || &lt;<span class=\"string\">'flex-basis'</span>&gt; ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>该属性有两个快捷值：<code>auto</code> (<code>1 1 auto</code>) 和 none (<code>0 0 auto</code>)。</p>\n<p>建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。</p>\n<h3 id=\"4-6-align-self属性\"><a href=\"#4-6-align-self属性\" class=\"headerlink\" title=\"4.6 align-self属性\"></a>4.6 align-self属性</h3><p><code>align-self</code>属性允许单个项目有与其他项目不一样的对齐方式，可覆盖<code>align-items</code>属性。默认值为<code>auto</code>，表示继承父元素的<code>align-items</code>属性，如果没有父元素，则等同于<code>stretch</code>。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.item</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">align-self</span>: auto | flex-start | flex-end | center | baseline | stretch;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://zhanglong292383147.gitee.io/picture_images/picture/Flex/flex_13.png\" alt=\"\"></p>\n<p>该属性可能取6个值，除了auto，其他都与align-items属性完全一致。</p>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cjt1u57hh0001u0npg6033q4r","tag_id":"cjt1u62iw0000swnpionimtpn","_id":"cjt1u62j50001swnp115wrq19"}],"Tag":[{"name":"tags","_id":"cjt1pka6n00049gnpuzzvnnxm"},{"name":"flex","_id":"cjt1u62iw0000swnpionimtpn"}]}}